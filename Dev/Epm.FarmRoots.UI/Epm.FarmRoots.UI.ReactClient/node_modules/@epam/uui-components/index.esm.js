import * as React from 'react';
import React__default, { useState, forwardRef, useEffect, useRef, useImperativeHandle, useContext, useCallback, useMemo, createContext, useLayoutEffect } from 'react';
import { UuiContext, cx, isEventTargetInsideClickable, uuiMarkers, uuiElement, uuiMod, labelMod, useArrayDataSource, orderBy, useLayoutEffectSafeForSsr, useUuiContext, closestTargetParentByCondition, isClientSide, arrayToMatrix, getSeparatedValue, i18n as i18n$1, preventDefaultIfTargetFocused, getMinMaxValidatedValue, getCalculatedValue, range, Lens, DndActor, getOrderBetween, blurFocusedElement, isMobile, usePrevious, mobilePopperModifier } from '@epam/uui-core';
import cx$1 from 'classnames';
import { CSSTransition, TransitionGroup } from 'react-transition-group';
import { Scrollbars } from 'react-custom-scrollbars-2';
import FocusLock, { FreeFocusInside } from 'react-focus-lock';
import { Manager, Reference, Popper } from 'react-popper';
import ReactDOM from 'react-dom';
import dayjs from 'dayjs';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import localeData from 'dayjs/plugin/localeData.js';
import isToday from 'dayjs/plugin/isToday.js';
import updateLocale from 'dayjs/plugin/updateLocale.js';
import isEqual from 'react-fast-compare';

var css$J = {"container":"L4hxLY"};

class Text extends React.Component {
    constructor() {
        super(...arguments);
        this.onClick = (e) => {
            this.props.onClick && this.props.onClick(e);
            this.context.uuiAnalytics.sendEvent(this.props.clickAnalyticsEvent);
        };
    }
    render() {
        return (React.createElement("div", Object.assign({ onClick: this.props.onClick && this.onClick, className: cx(this.props.cx, css$J.container), ref: this.props.forwardedRef }, this.props.rawProps), this.props.children));
    }
}
Text.contextType = UuiContext;

class RichTextView extends React.Component {
    getViewByProps(content) {
        return React.createElement("div", Object.assign({ dangerouslySetInnerHTML: { __html: content }, className: cx(this.props.cx) }, this.props.rawProps));
    }
    getViewByChildren(content) {
        return (React.createElement("div", Object.assign({ className: cx(this.props.cx) }, this.props.rawProps), content));
    }
    render() {
        let content = this.getViewByChildren(this.props.children);
        if (this.props.htmlContent) {
            content = this.getViewByProps(this.props.htmlContent);
        }
        return content;
    }
}

var css$I = {"flexSpacer":"-sukhf"};

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function FlexSpacer(props) {
    return React.createElement("div", { className: css$I.flexSpacer });
}

const FlexCell = /* @__PURE__ */React.forwardRef((props, ref) => {
    var _a;
    const actualStyle = Object.assign(Object.assign(Object.assign({}, (_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.style), { minWidth: props.minWidth ? `${props.minWidth}px` : 0, flexGrow: props.grow, flexShrink: props.shrink, flexBasis: props.width ? (props.width === 'auto' || props.width === '100%' ? props.width : `${props.width}px`) : '0', textAlign: props.textAlign, alignSelf: props.alignSelf }), props.style);
    return (React.createElement("div", Object.assign({ className: cx(props.cx), onClick: props.onClick ? (e) => !isEventTargetInsideClickable(e) && props.onClick(e) : undefined }, props.rawProps, { style: actualStyle, ref: ref }), props.children));
});

var css$H = {"container":"vxOoib","align-items-center":"s-LjTV","align-items-top":"kbA6kv","align-items-bottom":"oiX320","align-items-stretch":"qufH-8","justify-content-center":"VRr3jr","justify-content-space-between":"_-7mFft","justify-content-space-around":"NP-jWQ","justify-content-space-evenly":"ZU-4jl","justify-content-start":"dFLA8T","justify-content-end":"T3d-te","alignItemsCenter":"s-LjTV","alignItemsTop":"kbA6kv","alignItemsBottom":"oiX320","alignItemsStretch":"qufH-8","justifyContentCenter":"VRr3jr","justifyContentSpaceBetween":"_-7mFft","justifyContentSpaceAround":"NP-jWQ","justifyContentSpaceEvenly":"ZU-4jl","justifyContentStart":"dFLA8T","justifyContentEnd":"T3d-te"};

const FlexRow = /* @__PURE__ */React.forwardRef((props, ref) => {
    var _a;
    return (React.createElement("div", Object.assign({ ref: ref, onClick: props.onClick ? (e) => !isEventTargetInsideClickable(e) && props.onClick(e) : undefined, className: cx('uui-flex-row', props.cx, css$H.container, props.onClick && uuiMarkers.clickable, css$H['align-items-' + (props.alignItems === undefined ? 'center' : props.alignItems)], (props === null || props === void 0 ? void 0 : props.justifyContent) && css$H[`justify-content-${props.justifyContent}`]) }, props.rawProps, { style: Object.assign({ columnGap: props.columnGap && `${props.columnGap}px`, rowGap: props.rowGap && `${props.rowGap}px` }, (_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.style) }), props.children));
});

var css$G = {"container":"mM4U8f"};

class VPanel extends React.Component {
    constructor() {
        super(...arguments);
        this.handleClick = (e) => {
            this.props.onClick && !isEventTargetInsideClickable(e) && this.props.onClick(e);
            this.context.uuiAnalytics.sendEvent(this.props.clickAnalyticsEvent);
        };
    }
    render() {
        return (React.createElement("div", Object.assign({ onClick: this.props.onClick && this.handleClick, style: this.props.style, className: cx(this.props.cx, css$G.container, this.props.onClick && uuiMarkers.clickable), ref: this.props.forwardedRef }, this.props.rawProps), this.props.children));
    }
}
VPanel.contextType = UuiContext;

var css$F = {"container":"-a19YL","flipY":"AR9H3P","rotate-90cw":"h3cQ-i","rotate-180":"_3h6i3U","rotate-90ccw":"P-arc5","rotate90Cw":"h3cQ-i","rotate180":"_3h6i3U","rotate90Ccw":"P-arc5"};

const Svg = /* @__PURE__ */React.forwardRef((props, ref) => {
    if (!props.svg)
        return null;
    const { svg, fillColor, height, width, } = props;
    const svgProps = Object.assign({ className: cx$1(props.cx), fill: fillColor }, props.rawProps);
    if (height !== undefined)
        svgProps.height = height;
    if (width !== undefined)
        svgProps.width = width;
    return React.createElement(svg, Object.assign(Object.assign({}, svgProps), { ref }));
});

const IconContainer = /* @__PURE__ */React.forwardRef((props, ref) => {
    var _a, _b;
    const isClickable = !props.isDisabled && props.onClick;
    return (React.createElement("div", Object.assign({ className: cx(css$F.container, uuiElement.icon, props.isDisabled ? uuiMod.disabled : uuiMod.enabled, isClickable && uuiMarkers.clickable, props.cx, (_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.className), ref: ref, onClick: isClickable ? props.onClick : undefined, tabIndex: isClickable ? props.tabIndex : undefined, style: Object.assign(Object.assign({}, props.style), (_b = props.rawProps) === null || _b === void 0 ? void 0 : _b.style) }, props.rawProps),
        React.createElement(Svg, { svg: props.icon, width: props.size, height: props.size, cx: cx(props.flipY && css$F.flipY, props.rotate && css$F['rotate-' + props.rotate]) })));
});

var css$E = {"container":"LoCM29","arrow":"_3lVmPd"};

const uuiAccordion = {
    container: 'uui-accordion-container',
    title: 'uui-accordion-title',
    toggler: 'uui-accordion-toggler',
    toggleContainer: 'uui-accordion-toggle-container',
    body: 'uui-accordion-body',
};
const isEditableAccordionProps = (props) => props.onValueChange !== undefined;
const Accordion = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    const [state, setState] = useState({
        opened: isEditableAccordionProps(props) ? props.value : false,
    });
    const isOpened = () => {
        return isEditableAccordionProps(props) ? props.value : state.opened;
    };
    const toggleAccordion = () => {
        const isAccordionOpened = isOpened();
        if (isEditableAccordionProps(props)) {
            props.onValueChange(!isAccordionOpened);
        }
        else {
            setState({ opened: !isAccordionOpened });
        }
    };
    const handleKeyDown = (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            toggleAccordion();
        }
    };
    const renderHeader = () => {
        var _a;
        const isAccordionOpened = isOpened();
        return (React__default.createElement("div", Object.assign({ onKeyDown: !props.isDisabled ? handleKeyDown : undefined, onClick: !props.isDisabled ? toggleAccordion : undefined, tabIndex: !props.isDisabled ? 0 : -1, className: cx(uuiAccordion.toggler, isAccordionOpened && uuiMod.opened, props.isDisabled && uuiMod.disabled) }, props.rawProps),
            React__default.createElement("div", { className: cx(uuiAccordion.toggleContainer) },
                props.renderTitle ? props.renderTitle(isAccordionOpened) : React__default.createElement("div", { className: cx(uuiAccordion.title) }, props.title), (_a = props.renderAdditionalItems) === null || _a === void 0 ? void 0 :
                _a.call(props, isAccordionOpened),
                props.dropdownIcon !== null && (React__default.createElement(IconContainer, { icon: props.dropdownIcon, flipY: isAccordionOpened, cx: [props.isDisabled && uuiMod.disabled, css$E.arrow] })))));
    };
    const renderBody = () => (React__default.createElement("div", { className: uuiAccordion.body, role: "region" }, props.children));
    const isAccordionOpened = isOpened();
    return (React__default.createElement("div", { ref: ref, "aria-disabled": props.isDisabled, "aria-expanded": isAccordionOpened, className: cx(uuiAccordion.container, css$E.container, isAccordionOpened && !props.isDisabled && uuiMod.opened, props.isDisabled && uuiMod.disabled, props.cx) },
        renderHeader(),
        props.children && isAccordionOpened ? renderBody() : null));
});

const i18n = {
    mainMenu: {
        moreButtonCaption: 'More',
    },
    datePicker: {
        locale: 'en',
    },
    pickerList: {
        rowsSelected: (rows) => ` (${rows} selected)`,
        showAll: 'SHOW ALL',
    },
    pickerToggler: {
        createItemValue: (length, entityName) => `+ ${length} ${entityName}`,
    },
    pickerInput: {
        defaultPlaceholder: (entity) => `Please select ${entity}`,
    },
    labeledInput: {
        optionalFieldLabel: 'This field is optional',
    },
    numericInput: {
        locale: undefined,
    },
};

var css$D = {"container":"u6SXsT","labelWrapper":"G2XB0H","optional-field-wrapper":"fLrVYp","right-children-position":"a8LsY6","optionalFieldWrapper":"fLrVYp","rightChildrenPosition":"a8LsY6"};

const uuiLabeledInput = {
    infoIcon: 'uui-labeled-input-info-icon',
    asterisk: 'uui-labeled-input-asterisk',
    optional: 'uui-labeled-input-optional',
    charCounter: 'uui-labeled-input-char-counter',
    footNote: 'uui-labeled-input-footnote',
    sideNote: 'uui-labeled-input-sidenote',
};
const LabeledInput = /* @__PURE__ */React.forwardRef((props, ref) => {
    var _a;
    const Tooltip = props.Tooltip;
    const isCanBeOptional = !props.isRequired && props.labelPosition !== 'left' && props.isOptional;
    const isOnlyCharCounter = !props.footnote && (props.charCounter && props.maxLength && !props.isInvalid);
    const getSideNote = (sideNote) => {
        return (typeof sideNote === 'string')
            ? (React.createElement("div", { className: uuiLabeledInput.sideNote }, sideNote)) : sideNote;
    };
    const getCharCounter = () => {
        var _a;
        return (React.createElement("div", { className: uuiLabeledInput.charCounter }, `${((_a = props.value) === null || _a === void 0 ? void 0 : _a.length) || '0'}/${props.maxLength}`));
    };
    const getInvalidSection = () => {
        const isCharCounterAllow = props.charCounter && props.maxLength;
        return (React.createElement(FlexRow, { alignItems: "top", columnGap: 12 },
            React.createElement("div", { role: "alert", className: uuiElement.invalidMessage }, props.validationMessage),
            isCharCounterAllow && getCharCounter()));
    };
    const getFootnoteSection = () => {
        const isCharCounterAllow = props.charCounter && props.maxLength && !props.isInvalid;
        return (React.createElement(FlexRow, { alignItems: "top", columnGap: 12 },
            React.createElement("div", { className: uuiLabeledInput.footNote }, props.footnote),
            isCharCounterAllow && getCharCounter()));
    };
    return (React.createElement("div", Object.assign({ className: cx(css$D.container, props.cx), ref: ref }, props.rawProps),
        React.createElement("div", { className: cx(labelMod[props.labelPosition ? props.labelPosition : 'top']) },
            props.label && (React.createElement("div", { className: css$D.labelWrapper },
                React.createElement("label", { htmlFor: props.htmlFor, className: uuiElement.label, dir: (_a = props === null || props === void 0 ? void 0 : props.rawProps) === null || _a === void 0 ? void 0 : _a.dir },
                    props.label,
                    props.isRequired && React.createElement("span", { className: uuiLabeledInput.asterisk }, "*"),
                    props.info && Tooltip && (React.createElement(Tooltip, { content: props.info },
                        React.createElement(IconContainer, { icon: props.infoIcon, cx: uuiLabeledInput.infoIcon }))),
                    isCanBeOptional && (React.createElement("div", { className: css$D.optionalFieldWrapper },
                        React.createElement("div", { className: uuiLabeledInput.optional }, i18n.labeledInput.optionalFieldLabel)))),
                props.sidenote && (React.createElement(React.Fragment, null,
                    React.createElement(FlexSpacer, null),
                    getSideNote(props.sidenote))))),
            React.createElement("div", { className: props.labelPosition === 'left' ? css$D.rightChildrenPosition : undefined }, props.children)),
        props.isInvalid && getInvalidSection(),
        props.footnote && getFootnoteSection(),
        isOnlyCharCounter && getCharCounter()));
});

var css$C = {"container":"_5y0jSI","uui-focus":"a91c8U","uuiFocus":"a91c8U"};

const ControlGroup = /* @__PURE__ */React.forwardRef((props, ref) => {
    return (React.createElement("div", Object.assign({ role: "group", className: cx(css$C.container, props.cx), ref: ref }, props.rawProps), props.children));
});

function Tree(props) {
    const dataSource = useArrayDataSource({
        items: props.items,
        getId: (i) => i.id,
    }, [props.items]);
    const view = dataSource.useView(Object.assign(Object.assign({}, props.value), { topIndex: 0, visibleCount: Number.MAX_SAFE_INTEGER }), props.onValueChange, {
        getParentId: (i) => i.parentId,
        getSearchFields: props.getSearchFields || ((i) => [i.name]),
    });
    const rows = view.getVisibleRows();
    if (rows.length === 0)
        return null;
    return React.createElement(React.Fragment, null, rows.map((i) => props.renderRow(i)));
}

var css$B = {"container":"_0kGeCK"};

const classNames = {
    container: 'uui-blocker-container',
    blocker: 'uui-blocker',
};
const uuiBlocker = {
    enter: 'uui-blocker-enter',
    enterActive: 'uui-blocker-enter-active',
    exit: 'uui-blocker-exit',
    exitActive: 'uui-blocker-exit-active',
};
const Blocker = /* @__PURE__ */forwardRef((props, ref) => {
    const transitionRef = React__default.createRef();
    return (React__default.createElement("div", Object.assign({ className: cx(css$B.container, classNames.container, props.cx), style: { minHeight: props.isEnabled && props.spacerHeight ? `${props.spacerHeight}px` : undefined }, ref: ref, role: "status", "aria-live": "polite", "aria-busy": props.isEnabled ? 'true' : 'false', "aria-label": props.isEnabled ? 'Loading' : '' }, props.rawProps),
        React__default.createElement(CSSTransition, { in: props.isEnabled, nodeRef: transitionRef, classNames: uuiBlocker, timeout: { enter: 2000, exit: 1000 }, mountOnEnter: true, unmountOnExit: true },
            React__default.createElement("div", { ref: transitionRef, className: classNames.blocker }, !props.hideSpinner && props.renderSpinner && props.renderSpinner(props)))));
});

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function useDocumentDir() {
    const [dir, setDir] = useState(window.document.dir);
    useEffect(() => {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'dir') {
                    setDir(window.document.dir);
                }
            });
        });
        observer.observe(document.documentElement, { attributes: true });
        return () => {
            observer.disconnect();
        };
    }, []);
    return dir;
}

var css$A = {"root":"bNeMRP"};

var uuiScrollbars;
(function (uuiScrollbars) {
    uuiScrollbars["uuiShadowTop"] = "uui-shadow-top";
    uuiScrollbars["uuiShadowBottom"] = "uui-shadow-bottom";
    uuiScrollbars["uuiThumbVertical"] = "uui-thumb-vertical";
    uuiScrollbars["uuiThumbHorizontal"] = "uui-thumb-horizontal";
    uuiScrollbars["uuiTrackVertical"] = "uui-track-vertical";
    uuiScrollbars["uuiTrackHorizontal"] = "uui-track-horizontal";
    uuiScrollbars["uuiShadowTopVisible"] = "uui-shadow-top-visible";
    uuiScrollbars["uuiShadowBottomVisible"] = "uui-shadow-bottom-visible";
})(uuiScrollbars || (uuiScrollbars = {}));
const ScrollBars = /* @__PURE__ */forwardRef((_a, ref) => {
    var { style: outerStyle, hasBottomShadow, hasTopShadow, rawProps, cx: outerCx } = _a, props = __rest(_a, ["style", "hasBottomShadow", "hasTopShadow", "rawProps", "cx"]);
    const bars = useRef();
    useImperativeHandle(ref, () => bars.current, [bars.current]);
    const handleUpdateScroll = (event) => {
        var _a, _b;
        if (!bars.current)
            return;
        event && ((_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, event));
        const scrollBars = (_b = bars.current) === null || _b === void 0 ? void 0 : _b.container;
        if (!scrollBars)
            return;
        const { scrollTop, scrollHeight, clientHeight } = bars.current.getValues();
        const showTopShadow = hasTopShadow && scrollTop > 0;
        const showBottomShadow = hasBottomShadow && scrollHeight - clientHeight > scrollTop;
        if (showTopShadow)
            scrollBars.classList.add(uuiScrollbars.uuiShadowTopVisible);
        else
            scrollBars.classList.remove(uuiScrollbars.uuiShadowTopVisible);
        if (showBottomShadow)
            scrollBars.classList.add(uuiScrollbars.uuiShadowBottomVisible);
        else
            scrollBars.classList.remove(uuiScrollbars.uuiShadowBottomVisible);
    };
    useEffect(handleUpdateScroll);
    const dir = useDocumentDir();
    const getIndent = (margin) => {
        // for windows we need to get positive right margin to hide native scrollbar
        if (dir === 'rtl') {
            if (margin === 0)
                return { right: margin };
            const marginNum = typeof margin === 'string' ? parseInt(margin, 10) : margin;
            return { right: Math.abs(marginNum) + 'px' };
        }
        return {};
    };
    const customRenderView = (_a) => {
        var { style: innerStyle } = _a, rest = __rest(_a, ["style"]);
        const propsRenderView = props.renderView;
        const rv = propsRenderView === null || propsRenderView === void 0 ? void 0 : propsRenderView(Object.assign({ style: Object.assign(Object.assign({}, innerStyle), Object.assign({ position: 'relative', flex: '1 1 auto' }, getIndent(innerStyle === null || innerStyle === void 0 ? void 0 : innerStyle.marginRight))) }, rest));
        return rv || React__default.createElement("div", Object.assign({ style: Object.assign(Object.assign({}, innerStyle), Object.assign({ position: 'relative', flex: '1 1 auto' }, getIndent(innerStyle === null || innerStyle === void 0 ? void 0 : innerStyle.marginRight))) }, rest));
    };
    const customProps = __rest(props, ["renderView"]);
    return (React__default.createElement(Scrollbars, Object.assign({ className: cx(css$A.root, outerCx, props.className, hasTopShadow && uuiScrollbars.uuiShadowTop, hasBottomShadow && uuiScrollbars.uuiShadowBottom), renderView: (params) => customRenderView(params), renderTrackHorizontal: (props) => React__default.createElement("div", Object.assign({}, props, { className: uuiScrollbars.uuiTrackHorizontal })), renderTrackVertical: (props) => React__default.createElement("div", Object.assign({}, props, { className: uuiScrollbars.uuiTrackVertical })), renderThumbHorizontal: () => React__default.createElement("div", { className: uuiScrollbars.uuiThumbHorizontal }), renderThumbVertical: () => React__default.createElement("div", { className: uuiScrollbars.uuiThumbVertical }), style: Object.assign({ display: 'flex' }, outerStyle), onScroll: handleUpdateScroll, hideTracksWhenNotNeeded: true, ref: bars }, customProps, rawProps)));
});

var css$z = {"main-wrapper":"-bPDBK","mainWrapper":"-bPDBK"};

const layoutItems = (items, containerWidth, itemsWidth, itemsGap, previousCollapsedContainerPriority) => {
    let sumChildrenWidth = 0;
    const itemsByPriority = orderBy(items, ({ priority }) => priority, 'desc');
    let maxHiddenItemPriority = previousCollapsedContainerPriority || -1;
    itemsByPriority.forEach((item) => {
        if (sumChildrenWidth + itemsWidth[item.id] > containerWidth) {
            if (item.priority > maxHiddenItemPriority) {
                maxHiddenItemPriority = item.priority;
            }
        }
        sumChildrenWidth += itemsWidth[item.id] + itemsGap;
    });
    return {
        displayed: items.filter((i) => i.priority > maxHiddenItemPriority),
        hidden: items.filter((i) => i.priority <= maxHiddenItemPriority),
        maxHiddenItemPriority: maxHiddenItemPriority,
    };
};
const measureAdaptiveItems = (items, containerWidth, itemsWidth, itemsGap) => {
    const itemsWithoutCollapsedContainer = items.filter((i) => !i.collapsedContainer);
    let result = layoutItems(itemsWithoutCollapsedContainer, containerWidth, itemsWidth, itemsGap);
    if (result.hidden.length > 0) {
        let collapsedContainer = null;
        // if we have more than one collapsed container, we should take into account last hidden container priority to also hide other items with same priority at the same time
        let previousCollapsedContainer = null;
        // if max hidden item priority more than collapsed container priority, try to re-layout items with another container with higher priority
        while (collapsedContainer === null || result.maxHiddenItemPriority >= collapsedContainer.priority) {
            previousCollapsedContainer = collapsedContainer;
            collapsedContainer = orderBy(
            // eslint-disable-next-line no-loop-func
            items.filter((i) => i.collapsedContainer && i.priority > result.maxHiddenItemPriority), ({ priority }) => priority)[0];
            if (!collapsedContainer) {
                return result;
            }
            // eslint-disable-next-line no-loop-func
            const itemsWithCollapsedContainer = items.filter((i) => (i.collapsedContainer ? i.id === collapsedContainer.id : true));
            result = layoutItems(itemsWithCollapsedContainer, containerWidth, itemsWidth, itemsGap, previousCollapsedContainer === null || previousCollapsedContainer === void 0 ? void 0 : previousCollapsedContainer.priority);
        }
    }
    return result;
};

function AdaptivePanel(props) {
    const [itemsWidth, setItemsWidth] = useState();
    const [isChanged, setIsChanged] = useState(false);
    const wrapperRef = useRef(null);
    const displayedRowRef = useRef(null);
    const itemsGap = props.itemsGap ? Number(props.itemsGap) : 0;
    const getItemsWidth = () => {
        if (!displayedRowRef.current) {
            return;
        }
        const children = Array.from(displayedRowRef.current.children);
        if (!children.length)
            return;
        const calculatedItemsWidth = {};
        children.forEach((child, index) => {
            calculatedItemsWidth[props.items[index].id] = Math.floor(child.getBoundingClientRect().width);
        });
        return calculatedItemsWidth;
    };
    useLayoutEffectSafeForSsr(() => {
        if (isChanged || !itemsWidth) {
            const newItemsWidth = getItemsWidth();
            setItemsWidth(newItemsWidth);
            setIsChanged(false);
        }
    });
    useEffect(() => {
        const resizeObserver = new ResizeObserver((entries) => requestAnimationFrame(() => {
            if (!Array.isArray(entries) || !entries.length)
                return;
            setIsChanged(true);
        }));
        resizeObserver.observe(displayedRowRef.current);
        resizeObserver.observe(wrapperRef.current);
        return () => {
            resizeObserver.disconnect();
        };
    }, []);
    const renderItems = () => {
        if (isChanged || !itemsWidth) {
            return props.items.map((i) => i.render(i, [], props.items));
        }
        const wrapperWidth = (wrapperRef === null || wrapperRef === void 0 ? void 0 : wrapperRef.current) ? Math.floor(wrapperRef.current.getBoundingClientRect().width) : 0;
        const measuredItems = measureAdaptiveItems(props.items, wrapperWidth, itemsWidth, itemsGap);
        return measuredItems.displayed.map((i) => i.render(i, measuredItems.hidden, measuredItems.displayed));
    };
    return (React__default.createElement("div", Object.assign({}, props.rawProps, { className: cx$1(props.cx, css$z.mainWrapper), ref: wrapperRef }),
        React__default.createElement(FlexRow, { columnGap: props === null || props === void 0 ? void 0 : props.itemsGap, ref: displayedRowRef }, renderItems())));
}

function Modals() {
    const context = useContext(UuiContext);
    const [, setCount] = useState(0);
    useEffect(() => {
        if (!context)
            return;
        context.uuiModals.subscribe(() => {
            setCount((state) => state + 1);
        });
    }, [context]);
    return (React.createElement(React.Fragment, null, context.uuiModals.getOperations().map((modalOperation) => {
        return React.createElement(modalOperation.component, modalOperation.props);
    })));
}

var css$y = {"container":"_2rY0kE"};

const ModalBlocker = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    const context = useContext(UuiContext);
    useEffect(() => {
        let unsubscribeFromRouter = null;
        document.body.style.overflow = 'hidden';
        !props.disableCloseByEsc && window.addEventListener('keydown', keydownHandler);
        if (!props.disableCloseOnRouterChange) {
            unsubscribeFromRouter = context.uuiRouter.listen(() => {
                urlChangeHandler();
            });
        }
        return () => {
            !props.disableCloseByEsc && window.removeEventListener('keydown', keydownHandler);
            if (!context.uuiModals.getOperations().length) {
                document.body.style.overflow = 'visible';
            }
            if (unsubscribeFromRouter) {
                unsubscribeFromRouter();
            }
        };
    }, []);
    const urlChangeHandler = () => {
        !props.disableCloseOnRouterChange && context.uuiModals.closeAll();
    };
    const keydownHandler = (e) => {
        if (e.key === 'Escape') {
            props.abort();
        }
    };
    const handleBlockerClick = () => {
        if (!props.disallowClickOutside) {
            props.abort();
        }
    };
    return (React__default.createElement("div", Object.assign({ className: cx(css$y.container, props.cx), style: { zIndex: props.zIndex }, ref: ref }, props.rawProps),
        React__default.createElement("div", { className: uuiElement.modalBlocker, onClick: handleBlockerClick, "aria-label": "Click to close a modal" }),
        React__default.createElement(FocusLock, { autoFocus: false, returnFocus: true, disabled: props.disableFocusLock }, props.children)));
});

var css$x = {};

const PopoverArrow = /* @__PURE__ */React__default.forwardRef(({ arrowProps, placement }, ref) => {
    return React__default.createElement("div", { ref: ref, className: cx('uui-popover-arrow', css$x.root), style: arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.style, "data-placement": placement });
});

const DropdownContainer = /* @__PURE__ */React.forwardRef((props, ref) => {
    const { focusLock = true, returnFocus = true, persistentFocus = true, closeOnEsc = true, } = props;
    function renderDropdownContainer() {
        var _a, _b;
        return (React.createElement(VPanel, { forwardedRef: !focusLock ? ref : undefined, cx: cx(uuiElement.dropdownBody, uuiMarkers.lockFocus, props.cx), style: Object.assign(Object.assign({}, props.style), { minWidth: props.width, minHeight: props.height, maxHeight: props.maxHeight, maxWidth: (_a = props.maxWidth) !== null && _a !== void 0 ? _a : props.width }), rawProps: Object.assign({ tabIndex: -1 }, props.rawProps) },
            props.children,
            props.showArrow && (React.createElement(PopoverArrow, { ref: (_b = props === null || props === void 0 ? void 0 : props.arrowProps) === null || _b === void 0 ? void 0 : _b.ref, arrowProps: props === null || props === void 0 ? void 0 : props.arrowProps, placement: (props === null || props === void 0 ? void 0 : props.placement) || 'bottom-start' }))));
    }
    const handleEscape = (e) => {
        var _a, _b;
        (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (e.key === 'Escape' && closeOnEsc && props.isOpen) {
            e.preventDefault();
            (_b = props.onClose) === null || _b === void 0 ? void 0 : _b.call(props);
        }
    };
    return focusLock
        ? (React.createElement(FocusLock, { ref: ref, returnFocus: returnFocus && { preventScroll: true }, persistentFocus: persistentFocus, lockProps: Object.assign(Object.assign({}, ({ onKeyDown: handleEscape })), props.lockProps), shards: props.shards, autoFocus: false, as: props.as }, renderDropdownContainer()))
        : renderDropdownContainer();
});

const Portal = (props) => {
    const { uuiLayout } = useUuiContext();
    const rootElement = props.target || uuiLayout.getPortalRoot();
    return ReactDOM.createPortal(props.children, rootElement, props.key);
};

const isInteractedOutsideDropdown = (e, stopNodes) => {
    const [bodyNode] = stopNodes;
    if (stopNodes.some((node) => e.composedPath().includes(node))) {
        // Interacted inside any of the stop nodes
        return false;
    }
    // Interacted outside stop nodes, but on any "popper" with higher z-index - such interaction is considered as "inside"
    // (e.g. when child dropdown popover is clicked)
    const closestPopper = closestTargetParentByCondition(e, '.uui-popper');
    const closestPopperIndex = closestPopper ? +closestPopper.style.zIndex : 0;
    const bodyNodeIndex = bodyNode ? +bodyNode.style.zIndex : 0;
    return closestPopperIndex <= bodyNodeIndex;
};

class Dropdown extends React.Component {
    constructor(props) {
        super(props);
        this.targetNode = null;
        this.bodyNode = null;
        this.openDropdownTimerId = null;
        this.closeDropdownTimerId = null;
        this.state = {
            opened: this.props.value || false,
            bodyBoundingRect: {
                y: null, x: null, height: null, width: null,
            },
        };
        this.handleOpenedChange = (opened) => {
            if (opened && this.props.closeOnMouseLeave === 'boundary') {
                window.addEventListener('mousemove', this.handleMouseMove);
            }
            else if (!opened && this.props.closeOnMouseLeave === 'boundary') {
                window.removeEventListener('mousemove', this.handleMouseMove);
            }
            if (this.props.onValueChange) {
                this.props.onValueChange(opened);
            }
            else {
                this.setState({ opened });
            }
            if (opened) {
                this.lastOpenedMs = new Date().getTime();
            }
        };
        this.isOpened = () => {
            return this.props.value !== undefined ? this.props.value : this.state.opened;
        };
        this.handleTargetClick = (e) => {
            if (!this.props.isNotUnfoldable && !(e && isEventTargetInsideClickable(e))) {
                const currentValue = this.isOpened();
                const newValue = this.props.closeOnTargetClick === false ? true : !currentValue;
                if (currentValue !== newValue) {
                    this.handleOpenedChange(newValue);
                }
            }
        };
        this.handleMouseEnter = () => {
            this.clearCloseDropdownTimer();
            if (this.props.openDelay) {
                this.setOpenDropdownTimer();
            }
            else {
                this.handleOpenedChange(true);
            }
        };
        this.handleMouseLeave = () => {
            this.clearOpenDropdownTimer();
            if (this.props.closeOnMouseLeave !== 'boundary') {
                // For boundary mode we have separate logic on onMouseMove handler
                if (this.props.closeDelay) {
                    this.isOpened() && this.setCloseDropdownTimer(this.props.closeDelay);
                }
                else {
                    this.handleOpenedChange(false);
                }
            }
        };
        this.handleMouseMove = (e) => {
            var _a;
            if (this.isInteractedOutside(e) && this.isClientInArea(e) && !this.closeDropdownTimerId) {
                // User cursor in boundary area, but not inside toggler or body
                this.clearOpenDropdownTimer();
                this.setCloseDropdownTimer((_a = this.props.closeDelay) !== null && _a !== void 0 ? _a : 1500);
            }
            else if (this.isInteractedOutside(e) && !this.isClientInArea(e)) {
                // User leave boundary area, close dropdown immediately or with this.props.closeDelay
                if (this.props.closeDelay && !this.closeDropdownTimerId) {
                    this.isOpened() && this.setCloseDropdownTimer(this.props.closeDelay);
                }
                else if (!this.props.closeDelay) {
                    this.clearCloseDropdownTimer();
                    this.handleOpenedChange(false);
                }
            }
            else if (!this.isInteractedOutside(e) && this.closeDropdownTimerId) {
                // User returned to the toggler or body area, we need to clear close timer
                this.clearCloseDropdownTimer();
            }
        };
        this.onClose = () => {
            if (this.props.onClose)
                this.props.onClose();
            else
                this.handleOpenedChange(false);
        };
        this.getTargetClickHandler = () => {
            const { openOnClick, openOnHover } = this.props;
            if (openOnClick
                || !openOnHover) {
                return this.handleTargetClick;
            }
            return undefined;
        };
        this.getIsInteractedOutside = (event) => {
            return isInteractedOutsideDropdown(event, [
                this.bodyNode,
                this.targetNode,
            ]);
        };
        this.setForwardedRef = (node) => {
            if (!this.props.forwardedRef)
                return;
            if (typeof this.props.forwardedRef === 'function') {
                this.props.forwardedRef(node);
            }
            else {
                this.props.forwardedRef.current = node;
            }
        };
        this.getPlacement = (placement) => {
            var _a;
            if (((_a = window.document) === null || _a === void 0 ? void 0 : _a.dir) === 'rtl') {
                if (!placement)
                    return 'bottom-end';
                return placement.replace('start', 'end');
            }
            return placement;
        };
        this.renderDropdownBody = ({ ref, placement, style, update, isReferenceHidden, arrowProps, }) => {
            var _a;
            const setRef = (node) => {
                ref(node);
                this.bodyNode = node;
            };
            if (isReferenceHidden && this.props.closeBodyOnTogglerHidden !== false && this.isOpened()) {
                // Yes, we know that it's hack and we can perform setState in render, but we don't have other way to do it in this case
                setTimeout(() => this.handleOpenedChange(false), 0);
                return null;
            }
            // @ts-ignore
            return (React.createElement(FreeFocusInside, null,
                React.createElement("div", { role: "dialog", className: "uui-popper", "aria-hidden": !this.isOpened(), ref: setRef, style: Object.assign(Object.assign({}, style), { zIndex: this.props.zIndex != null ? this.props.zIndex : (_a = this.layer) === null || _a === void 0 ? void 0 : _a.zIndex }), "data-placement": this.getPlacement(placement) }, this.props.renderBody({
                    onClose: this.onClose,
                    togglerWidth: this.togglerWidth,
                    togglerHeight: this.togglerHeight,
                    scheduleUpdate: update,
                    isOpen: this.isOpened(),
                    arrowProps: arrowProps,
                    placement: this.getPlacement(placement),
                }))));
        };
        this.isInteractedOutside = (e) => {
            if (!this.isOpened())
                return false;
            return this.getIsInteractedOutside(e);
        };
        this.clickOutsideHandler = (e) => {
            if (this.isInteractedOutside(e)) {
                this.handleOpenedChange(false);
            }
        };
    }
    componentDidMount() {
        var _a, _b, _c, _d, _e;
        this.layer = (_a = this.context.uuiLayout) === null || _a === void 0 ? void 0 : _a.getLayer();
        window.addEventListener('dragstart', this.clickOutsideHandler);
        if (this.props.openOnHover && !this.props.openOnClick) {
            (_c = (_b = this.targetNode) === null || _b === void 0 ? void 0 : _b.addEventListener) === null || _c === void 0 ? void 0 : _c.call(_b, 'mouseenter', this.handleMouseEnter);
            if (this.props.closeOnMouseLeave !== false) {
                (_e = (_d = this.targetNode) === null || _d === void 0 ? void 0 : _d.addEventListener) === null || _e === void 0 ? void 0 : _e.call(_d, 'mouseleave', this.handleMouseLeave);
            }
        }
        if (this.props.closeOnClickOutside !== false) {
            window.addEventListener('click', this.clickOutsideHandler, true);
        }
    }
    componentWillUnmount() {
        var _a, _b, _c, _d, _e;
        window.removeEventListener('dragstart', this.clickOutsideHandler);
        (_b = (_a = this.targetNode) === null || _a === void 0 ? void 0 : _a.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(_a, 'mouseenter', this.handleMouseEnter);
        (_d = (_c = this.targetNode) === null || _c === void 0 ? void 0 : _c.removeEventListener) === null || _d === void 0 ? void 0 : _d.call(_c, 'mouseleave', this.handleMouseLeave);
        window.removeEventListener('click', this.clickOutsideHandler, true);
        window.removeEventListener('mousemove', this.handleMouseMove);
        this.layer && ((_e = this.context.uuiLayout) === null || _e === void 0 ? void 0 : _e.releaseLayer(this.layer));
    }
    isClientInArea(e) {
        var _a;
        const areaPadding = 30;
        const rect = (_a = this.bodyNode) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (rect) {
            const { y, x, height, width, } = rect;
            if (y && x && width && height) {
                return x - areaPadding <= e.clientX && e.clientX <= x + areaPadding + width && y - areaPadding <= e.clientY && e.clientY <= y + height + areaPadding;
            }
        }
        return false;
    }
    setOpenDropdownTimer() {
        this.openDropdownTimerId = setTimeout(() => {
            this.handleOpenedChange(true);
            this.clearOpenDropdownTimer();
        }, this.props.openDelay || 0);
    }
    setCloseDropdownTimer(delay) {
        this.closeDropdownTimerId = setTimeout(() => {
            this.handleOpenedChange(false);
            this.clearCloseDropdownTimer();
        }, delay);
    }
    clearOpenDropdownTimer() {
        if (this.openDropdownTimerId) {
            clearTimeout(this.openDropdownTimerId);
            this.openDropdownTimerId = null;
        }
    }
    clearCloseDropdownTimer() {
        if (this.closeDropdownTimerId) {
            clearTimeout(this.closeDropdownTimerId);
            this.closeDropdownTimerId = null;
        }
    }
    renderTarget(targetProps) {
        const innerRef = (node) => {
            if (!node) {
                return;
            }
            this.targetNode = node;
            if (typeof targetProps.ref === 'function') {
                targetProps.ref(this.targetNode);
            }
            else if (targetProps.ref) {
                targetProps.ref.current = this.targetNode;
            }
            this.setForwardedRef(this.targetNode);
        };
        return this.props.renderTarget({
            onClick: this.getTargetClickHandler(),
            isOpen: this.isOpened(),
            isDropdown: true,
            ref: innerRef,
            toggleDropdownOpening: this.handleOpenedChange,
            isInteractedOutside: this.getIsInteractedOutside,
        });
    }
    updateTogglerSize() {
        if (this.targetNode) {
            const { width, height } = this.targetNode.getBoundingClientRect();
            this.togglerWidth = width;
            this.togglerHeight = height;
        }
    }
    render() {
        const shouldShowBody = this.isOpened() && !this.props.isNotUnfoldable;
        const defaultModifiers = [
            {
                name: 'preventOverflow',
                options: {
                    rootBoundary: 'viewport',
                    boundary: this.props.boundaryElement,
                },
            }, {
                name: 'hide',
                enabled: true,
            },
        ];
        if (shouldShowBody) {
            this.updateTogglerSize();
        }
        return (React.createElement(Manager, null,
            React.createElement(Reference, null, (targetProps) => this.renderTarget(targetProps)),
            shouldShowBody && (React.createElement(Portal, { target: this.props.portalTarget },
                React.createElement(Popper, { placement: this.getPlacement(this.props.placement) || 'bottom-start', strategy: "fixed", modifiers: [...defaultModifiers, ...(this.props.modifiers || [])] }, this.renderDropdownBody)))));
    }
}
Dropdown.contextType = UuiContext;

function Tooltip(props) {
    const { cx: tooltipCX, maxWidth, children, closeOnMouseLeave, rawProps, } = props;
    const isTooltipExist = () => !!props.content || !!props.renderContent;
    const renderTooltip = (bodyProps) => {
        var _a;
        if (isTooltipExist()) {
            return (React.createElement(DropdownContainer, Object.assign({ focusLock: false, showArrow: true, maxWidth: maxWidth !== null && maxWidth !== void 0 ? maxWidth : 300, cx: cx(tooltipCX, uuiElement.tooltipContainer) }, bodyProps),
                React.createElement("div", Object.assign({ role: "tooltip", "aria-hidden": isTooltipExist(), className: uuiElement.tooltipBody }, rawProps), props.content || ((_a = props.renderContent) === null || _a === void 0 ? void 0 : _a.call(props)))));
        }
        else {
            return null;
        }
    };
    const renderTarget = (props) => React.Children.map(children, (child, idx) => {
        if (idx > 0 || !React.isValidElement(child))
            return child;
        return React.cloneElement(child, { ref: props.ref });
    });
    return (React.createElement(Dropdown, Object.assign({}, props, { renderBody: (props) => renderTooltip(props), openOnHover: true, closeOnMouseLeave: closeOnMouseLeave !== null && closeOnMouseLeave !== void 0 ? closeOnMouseLeave : 'toggler', placement: props.placement || 'top', modifiers: [{ name: 'offset', options: { offset: props.offset || [0, 12] } }], renderTarget: (props) => renderTarget(props) })));
}

const ModalWindow = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    return (React__default.createElement(VPanel, { style: props.style, cx: cx(uuiElement.modalWindow, props.cx), rawProps: Object.assign({ 'aria-modal': true, role: 'dialog' }, props.rawProps), forwardedRef: ref }, props.children));
});

/**
 * Adds a marker to the shadow host which helps the LayoutContext
 * to find this portal root element if it's located under shadow DOM.
 *
 * @param node
 * @param id
 */
function makePortalRootDiscoverable(node, id) {
    if (node) {
        const root = node.getRootNode();
        if (root instanceof ShadowRoot) {
            const hostElem = root.host;
            const name = 'data-shadow-host-id';
            hostElem.setAttribute(name, id);
            return () => {
                hostElem.removeAttribute(name);
            };
        }
    }
    return () => { };
}
function PortalRoot() {
    const { uuiLayout } = useUuiContext();
    const ref = React__default.useRef(null);
    const id = uuiLayout.getPortalRootId();
    // TODO: immprove on server side
    React__default.useLayoutEffect(() => {
        if (isClientSide) {
            return makePortalRootDiscoverable(ref.current, id);
        }
    }, [id]);
    return (React__default.createElement("div", { id: id, ref: ref }));
}

var css$w = {"container":"FeVsj9"};

const itemsOffset = 12;
const offset = 30;
const uuiSnackbar = {
    snackbar: 'uui-snackbar',
    itemWrapper: {
        self: 'uui-snackbar-item-wrapper-self',
        enter: 'uui-snackbar-item-wrapper-enter',
        exit: 'uui-snackbar-item-wrapper-exit',
        enterActive: 'uui-snackbar-item-wrapper-enter-active',
        exitActive: 'uui-snackbar-item-wrapper-exit-active',
    },
    itemWrapperCenter: {
        self: 'uui-snackbar-item-wrapper-center-self',
        enter: 'uui-snackbar-item-wrapper-enter',
        exit: 'uui-snackbar-item-wrapper-center-exit',
        enterActive: 'uui-snackbar-item-wrapper-enter-active',
        exitActive: 'uui-snackbar-item-wrapper-center-exit-active',
    },
    itemWrapperBottomCenter: {
        self: 'uui-snackbar-item-wrapper-center-self',
        enter: 'uui-snackbar-item-wrapper-enter',
        exit: 'uui-snackbar-item-wrapper-bottom-center-exit',
        enterActive: 'uui-snackbar-item-wrapper-enter-active',
        exitActive: 'uui-snackbar-item-wrapper-bottom-center-exit-active',
    },
    item: {
        self: 'uui-snackbar-item-self',
    },
    text: 'uui-snackbar-text',
    close: 'uui-snackbar-close',
    itemWrapperRight: {
        self: 'uui-snackbar-item-wrapper-right-self',
        enter: 'uui-snackbar-item-wrapper-enter',
        exit: 'uui-snackbar-item-wrapper-right-exit',
        enterActive: 'uui-snackbar-item-wrapper-enter-active',
        exitActive: 'uui-snackbar-item-wrapper-right-exit-active',
    },
};
class Snackbar extends React.Component {
    constructor() {
        super(...arguments);
        this.itemsHeights = {};
    }
    componentDidMount() {
        this.context.uuiNotifications.subscribe(() => this.forceUpdate());
    }
    updateHeight(item, node) {
        if (node) {
            const height = node.clientHeight;
            if (this.itemsHeights[item.props.id] !== height) {
                this.itemsHeights[item.props.id] = height;
                setTimeout(() => this.forceUpdate(), 0);
            }
        }
    }
    renderItem(item, position) {
        const isItemOnBottom = item.config.position === 'bot-left' || item.config.position === 'bot-right' || item.config.position === 'bot-center' || !item.config.position;
        const isItemOnLeftSide = item.config.position === 'bot-left' || item.config.position === 'top-left' || !item.config.position;
        const isItemOnCenter = item.config.position === 'bot-center' || item.config.position === 'top-center';
        let style = uuiSnackbar.itemWrapper;
        if (isItemOnCenter) {
            style = isItemOnBottom ? uuiSnackbar.itemWrapperBottomCenter : uuiSnackbar.itemWrapperCenter;
        }
        else if (!isItemOnLeftSide) {
            style = uuiSnackbar.itemWrapperRight;
        }
        const transitionRef = React.createRef();
        let className;
        if (isItemOnLeftSide) {
            className = uuiSnackbar.itemWrapper.self;
        }
        else {
            className = isItemOnCenter ? uuiSnackbar.itemWrapperCenter.self : uuiSnackbar.itemWrapperRight.self;
        }
        return (React.createElement(CSSTransition, { nodeRef: transitionRef, classNames: style, timeout: 200, key: item.props.id },
            React.createElement("div", { ref: transitionRef, className: className, key: item.props.key, style: isItemOnBottom ? { bottom: position } : { top: position } },
                React.createElement("div", { className: cx(uuiSnackbar.item.self), ref: (node) => this.updateHeight(item, node) }, React.createElement(item.component, item.props)))));
    }
    renderItemWithOffset(offsetCounterParam) {
        let offsetCounter = offsetCounterParam;
        return (item) => {
            const height = this.itemsHeights[item.props.id] || 0;
            const renderItem = this.renderItem(item, height > 0 ? offsetCounter : -300);
            offsetCounter += height + itemsOffset;
            return renderItem;
        };
    }
    render() {
        const items = this.props.notifications ? this.props.notifications : this.context.uuiNotifications.getNotifications().slice().reverse();
        const botLeftOffset = offset;
        const botRightOffset = offset;
        const topLeftOffset = offset;
        const topRightOffset = offset;
        const topCenterOffset = offset;
        const botCenterOffset = offset;
        const botLeftItems = items
            .filter((item) => item.config.position === 'bot-left' || !item.config.position)
            .map(this.renderItemWithOffset(botLeftOffset));
        const botRightItems = items.filter((item) => item.config.position === 'bot-right').map(this.renderItemWithOffset(botRightOffset));
        const topLeftItems = items.filter((item) => item.config.position === 'top-left').map(this.renderItemWithOffset(topLeftOffset));
        const topRightItems = items.filter((item) => item.config.position === 'top-right').map(this.renderItemWithOffset(topRightOffset));
        const topCenterItems = items.filter((item) => item.config.position === 'top-center').map(this.renderItemWithOffset(topCenterOffset));
        const botCenterItems = items.filter((item) => item.config.position === 'bot-center').map(this.renderItemWithOffset(botCenterOffset));
        return (React.createElement("div", Object.assign({ className: cx(css$w.container, uuiSnackbar.snackbar, this.props.cx) }, this.props.rawProps, { ref: this.props.forwardedRef }),
            React.createElement(TransitionGroup, null,
                botLeftItems,
                botRightItems,
                topLeftItems,
                topRightItems,
                topCenterItems,
                botCenterItems)));
    }
}
Snackbar.contextType = UuiContext;

var css$v = {"container":"_7pPf9Q","no-icon":"XsGVFC","noIcon":"XsGVFC"};

class DragHandle extends React.Component {
    render() {
        const { rawProps, dragHandleIcon, isDisabled } = this.props;
        const classes = cx$1(this.props.cx, css$v.container, 'uui-drag-handle', !dragHandleIcon && css$v.noIcon, isDisabled && uuiMod.disabled);
        return (React.createElement("div", Object.assign({ className: classes }, rawProps), dragHandleIcon && React.createElement(IconContainer, { icon: dragHandleIcon, isDisabled: isDisabled })));
    }
}

var css$u = {"container":"W6C2nB"};

const Checkbox = /* @__PURE__ */React.forwardRef((props, ref) => {
    const context = useUuiContext();
    const handleChange = (e) => {
        !isEventTargetInsideClickable(e) && props.onValueChange(!props.value);
        if (props.getValueChangeAnalyticsEvent) {
            const event = props.getValueChangeAnalyticsEvent(!props.value, props.value);
            context.uuiAnalytics.sendEvent(event);
        }
    };
    const handleAriaCheckedValue = (indeterminate, value) => {
        if (indeterminate) {
            return 'mixed';
        }
        return value == null ? false : value;
    };
    const label = props.renderLabel ? props.renderLabel() : props.label;
    const ariaCheckedValue = handleAriaCheckedValue(props.indeterminate, props.value);
    return (React.createElement("label", Object.assign({ className: cx(css$u.container, uuiElement.checkboxContainer, props.cx, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, props.isInvalid && uuiMod.invalid, !props.isReadonly && !props.isDisabled && uuiMarkers.clickable), ref: ref }, props.rawProps),
        React.createElement("div", { className: cx(uuiElement.checkbox, (props.value || props.indeterminate) && uuiMod.checked), onFocus: props.onFocus, onBlur: props.onBlur },
            React.createElement("input", { type: "checkbox", onChange: !props.isReadonly ? handleChange : undefined, disabled: props.isDisabled, "aria-disabled": props.isDisabled || undefined, readOnly: props.isReadonly, "aria-readonly": props.isReadonly || undefined, checked: props.value || false, "aria-checked": ariaCheckedValue, required: props.isRequired, "aria-required": props.isRequired || undefined, tabIndex: props.tabIndex || props.isReadonly || props.isDisabled ? -1 : 0, id: props.id }),
            props.value && !props.indeterminate && React.createElement(IconContainer, { icon: props.icon }),
            props.indeterminate && React.createElement(IconContainer, { icon: props.indeterminateIcon })),
        label && React.createElement("div", { className: uuiElement.inputLabel }, label)));
});

/* eslint-disable no-restricted-imports */
const uuiDayjs = /* @__PURE__ */TREE_SHAKEABLE_INIT();
function TREE_SHAKEABLE_INIT() {
    let extended = false;
    return {
        get dayjs() {
            if (!extended) {
                dayjs.extend(isSameOrBefore);
                dayjs.extend(isSameOrAfter);
                //
                dayjs.extend(localeData);
                dayjs.extend(isToday);
                dayjs.extend(updateLocale);
                extended = true;
            }
            if (dayjs.locale() !== i18n.datePicker.locale) {
                dayjs.locale(i18n.datePicker.locale);
            }
            /**
             * Currently, locales which starts from Sunday used.
             * That is why it's safe to set weekStart: 1 for all locales to start for Monday
             */
            if (dayjs.localeData().firstDayOfWeek() !== 1) {
                dayjs.updateLocale(i18n.datePicker.locale, {
                    weekStart: 1,
                });
            }
            return dayjs;
        },
    };
}

const uuiDaySelection = {
    container: 'uui-calendar-container',
    content: 'uui-calendar-content',
    weekdaysContainer: 'uui-calendar-weekdays-container',
    weekday: 'uui-calendar-weekday',
    days: 'uui-calendar-days',
    dayCell: 'uui-calendar-day-cell',
    day: 'uui-calendar-day',
    currentDay: 'uui-calendar-current-day',
    selectedDay: 'uui-calendar-selected-day',
    filteredDay: 'uui-calendar-filtered-day',
    previousMonthEmptyDay: 'uui-calendar-previous-month-empty-day',
    clickableDay: 'uui-calendar-clickable-day',
    dayWrapper: 'uui-calendar-day-wrapper',
    holiday: 'uui-calendar-day-holiday',
};

function Day(props) {
    const isCurrent = props.value.isToday();
    const isPassedFilter = props.filter ? props.filter(props.value) : true;
    const dayNumber = props.renderDayNumber
        ? props.renderDayNumber(props.value)
        : props.value.format('D');
    const selectDay = () => {
        isPassedFilter && props.onValueChange(props.value);
    };
    const isDisabled = props.isDisabled || (props.filter && !props.filter(props.value));
    return (React.createElement("div", Object.assign({ onClick: selectDay, onKeyDown: (e) => e.key === 'Enter' && selectDay(), tabIndex: !isDisabled ? 0 : -1, className: cx([
            isPassedFilter && uuiDaySelection.clickableDay,
            isPassedFilter && uuiMarkers.clickable,
            isCurrent && uuiDaySelection.currentDay,
            props.isSelected && uuiDaySelection.selectedDay,
            isDisabled && uuiDaySelection.filteredDay,
            props.cx,
            uuiDaySelection.dayWrapper,
            props.isHoliday && uuiDaySelection.holiday,
        ]), ref: props.forwardedRef }, props.rawProps),
        React.createElement("div", { className: uuiDaySelection.day }, dayNumber)));
}

var css$t = {"container":"KisFtH"};

const DAYS_COUNT_IN_WEEK = 7;
const getPrevMonthFromCurrent = (currentDate) => {
    return currentDate.subtract(1, 'month');
};
const getDays = (start, end, date) => {
    const daysMomentObjects = [];
    for (let i = start; i <= end; i += 1) {
        daysMomentObjects.push(date.date(i));
    }
    return daysMomentObjects;
};
const isHoliday = (day) => {
    return day.day() === 0 || day.day() === 6;
};
function isSelected(day, value) {
    if (uuiDayjs.dayjs.isDayjs(value)) {
        return day.isSame(value);
    }
    else if (Array.isArray(value)) {
        return value.find((selectedDay) => day.isSame(selectedDay));
    }
    return false;
}
function Calendar(props) {
    var _a;
    const getDaysToRender = (days) => days.map((day, index) => {
        return (React__default.createElement("div", { className: uuiDaySelection.dayCell, key: `day-${props.month.valueOf()}-${day && day.valueOf()}-${index}` }, props.renderDay ? (props.renderDay({
            value: day,
            onValueChange: (v) => {
                props.onValueChange(v);
            },
            filter: props.filter,
            isHoliday: props.isHoliday ? props.isHoliday(day) : isHoliday(day),
            isSelected: isSelected(day, props.value),
            isDisabled: props.isDisabled,
        })) : (React__default.createElement(Day, { value: day, onValueChange: (v) => {
                props.onValueChange(v);
            }, filter: props.filter, isHoliday: props.isHoliday ? props.isHoliday(day) : isHoliday(day), isSelected: isSelected(day, props.value), isDisabled: props.isDisabled }))));
    });
    const getDaysMatrix = (currentDate) => {
        const dayOfLastWeekInPrevMonth = getPrevMonthFromCurrent(currentDate).endOf('month').day();
        // get days of current month
        const days = Array.from({ length: dayOfLastWeekInPrevMonth }, (_, index) => {
            return (React__default.createElement("div", { className: uuiDaySelection.dayCell, tabIndex: -1, key: `day-${props.month.valueOf()}-${index}` }));
        }).concat(getDaysToRender(getDays(1, currentDate === null || currentDate === void 0 ? void 0 : currentDate.daysInMonth(), currentDate)));
        return arrayToMatrix(days, DAYS_COUNT_IN_WEEK);
    };
    const daysMatrix = getDaysMatrix((_a = props.month) === null || _a === void 0 ? void 0 : _a.startOf('day'));
    const weeksHeight = daysMatrix.length * 36;
    const renderDaysTable = () => daysMatrix.map((week, index) => {
        const key = `${props.month.valueOf()}-${index}`;
        return React__default.createElement("div", { key: key }, week.map((day) => day));
    });
    const renderWeekdays = () => {
        return uuiDayjs.dayjs.weekdaysShort(true).map((weekday, index) => (React__default.createElement("div", { key: `${weekday}-${index}`, className: uuiDaySelection.weekday }, weekday)));
    };
    return (React__default.createElement("div", Object.assign({ ref: props.forwardedRef, className: cx(css$t.container, uuiDaySelection.container, props.cx) }, props.rawProps),
        React__default.createElement("div", { className: uuiDaySelection.content },
            React__default.createElement("div", { className: uuiDaySelection.weekdaysContainer }, renderWeekdays()),
            React__default.createElement("div", { className: uuiDaySelection.days, style: { height: weeksHeight } }, renderDaysTable()))));
}

const uuiPresets = {
    container: 'uui-presets-container',
    header: 'uui-presets-header',
    item: 'uui-presets-item',
};
const getPresets = (presets) => {
    return Object.keys(presets).map((key) => (Object.assign(Object.assign({}, presets[key].getRange()), { name: presets[key].name, key }))).sort((a, b) => a.order - b.order);
};
function CalendarPresets(props) {
    return (React.createElement("div", Object.assign({ ref: props.forwardedRef, className: cx(uuiPresets.container, props.cx) }, props.rawProps),
        React.createElement("div", { className: uuiPresets.header }, "Presets"),
        getPresets(props.presets).map((item) => (React.createElement("div", { key: item.key, className: uuiPresets.item, onClick: () => props.onPresetSet(item) }, item.name)))));
}

var css$s = {"container":"Bs6LBg"};

const MONTH_ROW_LENGTH$1 = 3;
const uuiMonthSelection = {
    container: 'uui-monthselection-container',
    content: 'uui-monthselection-content',
    monthContainer: 'uui-monthselection-month-container',
    monthsRow: 'uui-monthselection-months-row',
    month: 'uui-monthselection-month',
    currentMonth: 'uui-monthselection-current-month',
};
function MonthSelection(props) {
    const renderMonth = (month, index) => {
        const isSelected = props.selectedDate.year() === props.value.year() && month === props.selectedDate.format('MMM');
        return (React.createElement("div", { key: month, tabIndex: 0, className: cx(isSelected && uuiMonthSelection.currentMonth, uuiMonthSelection.month), onClick: () => props.onValueChange(props.value.month(index)), onKeyDown: (e) => { e.key === 'Enter' && props.onValueChange(props.value.month(index)); } }, month));
    };
    const MONTHS_SHORT_ARRAY = uuiDayjs.dayjs.monthsShort();
    return (React.createElement("div", Object.assign({ ref: props.forwardedRef, className: cx(css$s.container, uuiMonthSelection.container, props.cx) }, props.rawProps),
        React.createElement("div", { className: uuiMonthSelection.content },
            React.createElement("div", { className: uuiMonthSelection.monthContainer }, arrayToMatrix(MONTHS_SHORT_ARRAY, MONTH_ROW_LENGTH$1).map((monthsRow, index) => (React.createElement("div", { key: index, className: uuiMonthSelection.monthsRow }, monthsRow.map((month) => {
                const monthIndex = MONTHS_SHORT_ARRAY.findIndex((it) => it === month);
                return renderMonth(month, monthIndex);
            }))))))));
}

var css$r = {"container":"or3QFe"};

const MONTH_ROW_LENGTH = 4;
const uuiYearSelection = {
    container: 'uui-yearselection-container',
    content: 'uui-yearselection-content',
    yearContainer: 'uui-yearselection-year-container',
    yearRow: 'uui-yearselection-year-row',
    year: 'uui-yearselection-year',
    currentYear: 'uui-yearselection-current-year',
};
const getYears = (currentYear) => {
    return new Array(16).fill(0).map((_, index) => currentYear - 5 + index);
};
function YearSelection(props) {
    return (React.createElement("div", Object.assign({ className: cx(css$r.container, uuiYearSelection.container, props.cx) }, props.rawProps),
        React.createElement("div", { className: uuiYearSelection.content },
            React.createElement("div", { className: uuiYearSelection.yearContainer }, arrayToMatrix(getYears(props.value.year()), MONTH_ROW_LENGTH).map((yearRow, index) => (React.createElement("div", { key: index, className: uuiYearSelection.yearRow }, yearRow.map((year) => (React.createElement("div", { key: year, tabIndex: 0, className: cx(year === props.selectedDate.year() && uuiYearSelection.currentYear, uuiYearSelection.year), onClick: () => props.onValueChange(props.value.year(year)), onKeyDown: (e) => { e.key === 'Enter' && props.onValueChange(props.value.year(year)); } }, year))))))))));
}

var css$q = {"container":"qtsrJj","align-right":"tlZjo-","alignRight":"tlZjo-"};

const uuiNumericInput = {
    upButton: 'uui-numeric-input-up-button',
    downButton: 'uui-numeric-input-down-button',
    buttonGroup: 'uui-numeric-input-button-group',
    withoutArrows: 'uui-numeric-input-without-arrows',
};
const getFractionDigits = (formatOptions) => {
    const { maximumFractionDigits } = new Intl.NumberFormat(i18n$1.locale, formatOptions).resolvedOptions();
    return maximumFractionDigits;
};
const NumericInput = /* @__PURE__ */React.forwardRef((props, ref) => {
    const { value: initialValue = null, min: initialMin, max: initialMax, formatOptions: initialFormatOptions, step, formatValue, } = props;
    const value = initialValue != null ? +initialValue : null;
    const min = initialMin !== null && initialMin !== void 0 ? initialMin : 0;
    const max = initialMax !== null && initialMax !== void 0 ? initialMax : Number.MAX_SAFE_INTEGER;
    const formatOptions = initialFormatOptions !== null && initialFormatOptions !== void 0 ? initialFormatOptions : { maximumFractionDigits: 0 };
    const placeholderValue = React.useMemo(() => {
        if (typeof value === 'number') {
            if (formatValue)
                return formatValue(value);
            return props.disableLocaleFormatting ? value.toString() : getSeparatedValue(value, formatOptions, i18n$1.locale);
        }
        return props.placeholder || '0';
    }, [
        props.placeholder, props.disableLocaleFormatting, formatOptions, value,
    ]);
    const context = useUuiContext();
    const [inFocus, setInFocus] = React.useState(false);
    const handleChange = (event) => {
        let newValue = event.target.value === '' ? null : +event.target.value;
        const fractionDigits = getFractionDigits(formatOptions);
        if (newValue !== null) {
            newValue = +newValue.toFixed(fractionDigits);
        }
        props.onValueChange(newValue);
        if (props.getValueChangeAnalyticsEvent) {
            const analyticsEvent = props.getValueChangeAnalyticsEvent(newValue, props.value);
            context.uuiAnalytics.sendEvent(analyticsEvent);
        }
    };
    const handleFocus = (event) => {
        var _a;
        setInFocus(true);
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, event);
    };
    const handleBlur = (event) => {
        var _a, _b;
        setInFocus(false);
        // clearing the input when entering invalid data using special characters
        if (inputRef.current && ((_a = event.target.validity) === null || _a === void 0 ? void 0 : _a.badInput)) {
            inputRef.current.value = '';
        }
        else {
            if (value !== null) {
                const validatedValue = getMinMaxValidatedValue({ value, min, max });
                if (validatedValue !== value) {
                    props.onValueChange(validatedValue);
                }
            }
        }
        (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, event);
    };
    const handleIncreaseValue = () => {
        let newValue = getCalculatedValue({ value, step, action: 'incr' });
        newValue = getMinMaxValidatedValue({ value: newValue, min, max });
        props.onValueChange(newValue);
    };
    const handleDecreaseValue = () => {
        let newValue = getCalculatedValue({ value, step, action: 'decr' });
        newValue = getMinMaxValidatedValue({ value: newValue, min, max });
        props.onValueChange(newValue);
    };
    const handleArrowKeyDown = (e) => {
        const otherKeysArePressed = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;
        if (e.key === 'ArrowUp' && !otherKeysArePressed) {
            e.preventDefault();
            handleIncreaseValue();
        }
        if (e.key === 'ArrowDown' && !otherKeysArePressed) {
            e.preventDefault();
            handleDecreaseValue();
        }
    };
    const inputRef = React.useRef(null);
    // disable changing the value by scrolling the wheel when the input is in focus and hover
    React.useEffect(() => {
        var _a;
        (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener('wheel', preventDefaultIfTargetFocused, { passive: false });
        return () => {
            var _a;
            (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('wheel', preventDefaultIfTargetFocused);
        };
    }, []);
    const isPlaceholderColored = React.useMemo(() => Boolean(props.value || props.value === 0), [props.value]);
    const inputValue = React.useMemo(() => (inFocus && (props.value || props.value === 0) ? props.value : ''), [props.value, inFocus]);
    const showArrows = !props.disableArrows && !props.isReadonly && !props.isDisabled;
    const handleWrapperFocus = () => {
        var _a;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    return (React.createElement("div", Object.assign({ className: cx(css$q.container, uuiElement.inputBox, props.isReadonly && uuiMod.readonly, props.isDisabled && uuiMod.disabled, props.isInvalid && uuiMod.invalid, !props.isReadonly && inFocus && uuiMod.focus, !props.isReadonly && !props.isDisabled && uuiMarkers.clickable, !showArrows && uuiNumericInput.withoutArrows, props.cx), onClick: props.onClick, onFocus: handleWrapperFocus, onKeyDown: handleArrowKeyDown, tabIndex: -1, ref: ref }, props.rawProps),
        React.createElement("input", { type: "number", className: cx(uuiElement.input, props.inputCx, props.align === 'right' && css$q.alignRight, isPlaceholderColored && uuiElement.valueInPlaceholder), disabled: props.isDisabled, readOnly: props.isReadonly, tabIndex: inFocus || props.isReadonly || props.isDisabled ? -1 : 0, "aria-required": props.isRequired, value: inputValue, inputMode: "numeric", placeholder: placeholderValue, onChange: handleChange, onFocus: handleFocus, onBlur: handleBlur, min: min, max: max, step: step, id: props.id, ref: inputRef }),
        showArrows && (React.createElement("div", { className: uuiNumericInput.buttonGroup },
            React.createElement(IconContainer, { cx: uuiNumericInput.upButton, icon: props.upIcon, onClick: handleIncreaseValue, isDisabled: props.isDisabled, rawProps: { role: 'button' } }),
            React.createElement(IconContainer, { cx: uuiNumericInput.downButton, icon: props.downIcon, onClick: handleDecreaseValue, isDisabled: props.isDisabled, rawProps: { role: 'button' } })))));
});

var css$p = {"container":"LsPlOS","circle":"u5jtvO"};

const RadioInput = /* @__PURE__ */React.forwardRef((props, ref) => {
    const context = useUuiContext();
    const handleChange = () => {
        props.onValueChange(!props.value);
        if (props.getValueChangeAnalyticsEvent) {
            const event = props.getValueChangeAnalyticsEvent(!props.value, props.value);
            context.uuiAnalytics.sendEvent(event);
        }
    };
    return (React.createElement("label", Object.assign({ className: cx(css$p.container, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, props.isInvalid && uuiMod.invalid, props.cx, !props.isReadonly && !props.isDisabled && uuiMarkers.clickable), ref: ref }, props.rawProps),
        React.createElement("div", { className: cx(uuiElement.radioInput, props.value && uuiMod.checked), onFocus: props.onFocus, onBlur: props.onBlur },
            React.createElement("input", { name: props.name, type: "radio", onChange: !props.isReadonly ? handleChange : undefined, disabled: props.isDisabled, "aria-disabled": props.isDisabled || undefined, readOnly: props.isReadonly, "aria-readonly": props.isReadonly || undefined, required: props.isRequired, "aria-required": props.isRequired || undefined, checked: props.value || false, "aria-checked": props.value || false, id: props.id, tabIndex: props.tabIndex }),
            props.value && React.createElement(IconContainer, { icon: props.icon, cx: css$p.circle })),
        (props.renderLabel || props.label) && (React.createElement("div", { className: uuiElement.inputLabel }, props.renderLabel ? props.renderLabel() : props.label))));
});

var css$o = {"container":"AB3XQk","container--readonly":"KkbH4g","containerReadonly":"KkbH4g"};

class BaseRating extends React.Component {
    constructor(props) {
        super(props);
        this.handleRef = (container) => {
            var _a, _b;
            this.container = container;
            (_b = (_a = this.props).forwardedRef) === null || _b === void 0 ? void 0 : _b.call(_a, container);
        };
        this.state = {};
    }
    componentDidMount() {
        this.setState({
            rating: this.checkRating(this.props.value),
            containerWidth: this.getContainerWidth(),
        });
    }
    componentDidUpdate(prevProps) {
        if (this.state.containerWidth !== this.getContainerWidth()) {
            this.setState({
                containerWidth: this.getContainerWidth(),
            });
        }
        if (this.props.value !== prevProps.value) {
            this.setState({
                rating: this.checkRating(this.props.value),
            });
        }
    }
    getContainerWidth() {
        var _a;
        return (_a = this.container) === null || _a === void 0 ? void 0 : _a.offsetWidth;
    }
    getContainerOffsetLeft() {
        return this.container.getBoundingClientRect().left;
    }
    getNumberOfMarks() {
        const step = this.props.step || 1;
        return (this.props.to - this.props.from) / step + 1;
    }
    getMarkWidth() {
        return this.state.containerWidth / this.getNumberOfMarks();
    }
    checkRating(rating) {
        if (!rating && rating !== 0) {
            return rating;
        }
        else if (rating < this.props.from - this.props.step) {
            return this.props.from;
        }
        else if (rating > this.props.to) {
            return this.props.to;
        }
        else {
            return rating;
        }
    }
    getRatingFromWidth(width) {
        const step = this.props.step || 1;
        return step * Math.ceil(width / this.getMarkWidth()) + (this.props.from - step);
    }
    onMouseMove(e) {
        const width = e.pageX - this.getContainerOffsetLeft();
        if (width > 0 && width <= this.state.containerWidth) {
            this.setState({ rating: this.checkRating(this.getRatingFromWidth(width)) });
        }
    }
    onMouseLeave() {
        this.setState({ rating: this.checkRating(this.props.value) });
    }
    onMouseUp(e) {
        const width = e.pageX - this.getContainerOffsetLeft();
        this.props.onValueChange(this.checkRating(this.getRatingFromWidth(width)));
    }
    onTouchEnd(e) {
        const touch = e.changedTouches[0];
        const width = touch.pageX - this.getContainerOffsetLeft();
        this.props.onValueChange(this.checkRating(this.getRatingFromWidth(width)));
    }
    onKeyDown(e) {
        const { from, to } = this.props;
        const { rating } = this.state;
        const step = this.props.step || 1;
        if (e.key === 'ArrowLeft') {
            if (rating - step < from)
                return;
            else
                this.setState({ rating: rating - step });
        }
        else if (e.key === 'ArrowRight') {
            if (rating + step > to)
                return;
            else
                this.setState({ rating: rating + step });
        }
    }
    render() {
        const isReadonly = this.props.isReadonly || this.props.isDisabled;
        return (React.createElement("div", Object.assign({ role: "slider", "aria-valuenow": this.props.value || 0, "aria-valuemax": this.props.to, "aria-valuemin": this.props.from, tabIndex: 0, onKeyDown: (e) => !isReadonly && this.onKeyDown(e), className: cx(css$o.container, this.props.isDisabled && uuiMod.disabled, isReadonly && css$o.containerReadonly, this.props.cx), onMouseMove: (e) => !isReadonly && this.onMouseMove(e), onMouseLeave: () => !isReadonly && this.onMouseLeave(), onMouseUp: (e) => !isReadonly && this.onMouseUp(e), onTouchEnd: (e) => !isReadonly && this.onTouchEnd(e), ref: this.handleRef }, this.props.rawProps), this.props.renderRating(this.state.rating, this.getMarkWidth(), this.getNumberOfMarks())));
    }
}

var css$n = {"container":"dZUPv3"};

const uuiRating = {
    rating: 'uui-rating',
    star: 'uui-rating-star',
    emptyStarContainer: 'uui-rating-empty-star-container',
    filledStarContainer: 'uui-rating-filled-star-container',
};
const maxValue = 5;
class Rating extends React.Component {
    constructor() {
        super(...arguments);
        this.getFilledStarsWidth = (rating, markWidth) => {
            const step = this.props.step || 1;
            return !!rating ? (rating / step) * markWidth : 0;
        };
        this.hidingTooltip = (rating) => {
            if (this.props.hideTooltip) {
                return null;
            }
            else {
                return this.props.hint ? this.props.hint(rating) : `${rating} / ${maxValue}`;
            }
        };
        this.getEmptyStars = (rating) => {
            const Tooltip = this.props.Tooltip;
            const emptyStars = [];
            for (let i = 0; i < maxValue; i++) {
                Tooltip
                    && emptyStars.push(React.createElement(Tooltip, { key: 'star-' + i, placement: "top", content: this.hidingTooltip(rating), cx: css$n.tooltip },
                        React.createElement("div", { className: uuiRating.star },
                            React.createElement(IconContainer, { icon: this.props.emptyStarIcon }))));
            }
            return emptyStars;
        };
        this.getFilledStars = (rating) => {
            const Tooltip = this.props.Tooltip;
            const filledStars = [];
            for (let i = 0; i < maxValue; i++) {
                Tooltip
                    && filledStars.push(React.createElement(Tooltip, { key: i, placement: "top", content: this.hidingTooltip(rating), cx: css$n.tooltip },
                        React.createElement("div", { className: uuiRating.star },
                            React.createElement(IconContainer, { icon: this.props.filledStarIcon }))));
            }
            return filledStars;
        };
        this.renderRating = (rating, markWidth) => {
            return (React.createElement("div", { key: rating, className: css$n.container },
                React.createElement("div", { key: "e", className: uuiRating.emptyStarContainer }, this.getEmptyStars(rating)),
                React.createElement("div", { key: "f", className: uuiRating.filledStarContainer, style: { width: this.getFilledStarsWidth(rating, markWidth) } }, this.getFilledStars(rating))));
        };
    }
    render() {
        return React.createElement(BaseRating, Object.assign({}, this.props, { from: this.props.step || 1, to: maxValue, step: this.props.step, renderRating: this.renderRating }));
    }
}

const uuiSlider = {
    container: 'uui-slider-container',
    slider: 'uui-slider',
    filled: 'uui-slider-filled',
    handle: 'uui-slider-handle',
    scale: 'uui-slider-scale',
    scaleNumber: 'uui-slider-scale-number',
    scaleDot: 'uui-slider-scale-dot',
    scaleFilledDot: 'uui-slider-scale-filled-dot',
};
class SliderBase extends React.Component {
    constructor() {
        super(...arguments);
        this.getFloatPrecision = (step) => {
            const stepString = step.toString();
            const decimalIndex = stepString.indexOf('.');
            return decimalIndex >= 0 ? stepString.length - decimalIndex - 1 : 0;
        };
        this.handleResize = () => {
            var _a;
            if (this.state.valueWidth * (this.props.max - this.props.min) !== ((_a = this.slider) === null || _a === void 0 ? void 0 : _a.offsetWidth)) {
                this.forceUpdate();
            }
        };
        this.handleMouseDown = () => {
            this.setState({ isActive: true });
        };
        this.handleMouseUp = () => {
            this.state.isActive && this.setState({ isActive: false });
        };
        this.getValue = (mouseX, valueWidth) => {
            if (mouseX < this.slider.getBoundingClientRect().left) {
                return this.props.min;
            }
            else if (mouseX > this.slider.getBoundingClientRect().right) {
                return this.props.max;
            }
            else {
                return this.roundToStep((mouseX - this.slider.getBoundingClientRect().left) / valueWidth + this.props.min, this.props.step);
            }
        };
    }
    componentDidMount() {
        this.setState({ valueWidth: this.slider && this.slider.offsetWidth / (this.props.max - this.props.min) });
        document.addEventListener('mouseup', this.handleMouseUp);
        window.addEventListener('resize', this.handleResize);
    }
    componentWillUnmount() {
        document.removeEventListener('mouseup', this.handleMouseUp);
        window.removeEventListener('resize', this.handleResize);
    }
    roundToStep(value, step) {
        const precision = this.getFloatPrecision(step);
        let rounded = this.props.min + Math.round(Math.abs((value - this.props.min) / step)) * step;
        rounded = parseFloat(rounded.toFixed(precision));
        if (rounded < this.props.min) {
            return this.props.min;
        }
        else if (rounded > this.props.max) {
            return this.props.max;
        }
        else {
            return rounded;
        }
    }
}

var css$m = {"root":"JCp3RP"};

var css$l = {"container":"S8uzhJ","tooltip-wrapper":"_1GoAJ-","tooltipWrapper":"_1GoAJ-"};

class SliderHandle extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isHovered: false,
        };
        this.handleMouseMove = (e) => {
            if (this.props.isActive) {
                this.props.onUpdate(e.clientX);
            }
        };
        this.handleMouseDown = (e) => {
            e.preventDefault();
            this.props.handleActiveState && this.props.handleActiveState(true);
        };
        this.handleMouseUp = () => {
            if (this.props.isActive) {
                this.props.handleActiveState && this.props.handleActiveState(false);
            }
        };
        this.handleMouseEnter = () => {
            this.setState({ isHovered: true });
        };
        this.handleMouseLeave = () => {
            this.setState({ isHovered: false });
        };
        this.handleFocus = (e) => {
            e.preventDefault();
            this.props.handleActiveState && this.props.handleActiveState(true);
            this.setState({ isHovered: true });
        };
        this.handleBlur = (e) => {
            e.preventDefault();
            this.props.handleActiveState && this.props.handleActiveState(false);
            this.setState({ isHovered: false });
        };
        this.handleKeyDown = (e) => {
            if (e.key === 'ArrowLeft') {
                this.props.onKeyDownUpdate('left');
            }
            else if (e.key === 'ArrowRight') {
                this.props.onKeyDownUpdate('right');
            }
        };
    }
    componentDidMount() {
        var _a, _b;
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
        (_a = this.sliderHandle) === null || _a === void 0 ? void 0 : _a.addEventListener('mouseenter', this.handleMouseEnter);
        (_b = this.sliderHandle) === null || _b === void 0 ? void 0 : _b.addEventListener('mouseleave', this.handleMouseLeave);
    }
    componentWillUnmount() {
        var _a, _b;
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        (_a = this.sliderHandle) === null || _a === void 0 ? void 0 : _a.removeEventListener('mouseenter', this.handleMouseEnter);
        (_b = this.sliderHandle) === null || _b === void 0 ? void 0 : _b.removeEventListener('mouseleave', this.handleMouseLeave);
    }
    renderTooltip() {
        const content = this.props.tooltipContent;
        return React.createElement("div", { className: uuiElement.tooltipBody }, content);
    }
    render() {
        return (React.createElement(Manager, null,
            React.createElement(Reference, null, (targetProps) => (React.createElement("div", Object.assign({ tabIndex: 0, ref: (handle) => {
                    this.sliderHandle = handle;
                    targetProps.ref(handle);
                }, className: cx(uuiSlider.handle, this.props.cx), style: { transform: `translateX(${this.props.offset || 0}px)` }, onMouseDown: this.handleMouseDown, onMouseUp: this.handleMouseUp, onKeyDown: this.handleKeyDown, onFocus: this.handleFocus, onBlur: this.handleBlur }, this.props.rawProps)))),
            React.createElement(Portal, null,
                React.createElement(Popper, { placement: "top", key: this.props.offset }, ({ ref, style, placement }) => {
                    return ((this.props.isActive || this.state.isHovered) && (React.createElement("div", { ref: ref, style: style, "data-placement": placement, className: cx(this.props.cx, css$l.container, uuiElement.tooltipContainer, css$l.tooltipWrapper) },
                        this.props.showTooltip && this.renderTooltip(),
                        React.createElement("div", { className: uuiElement.tooltipArrow }))));
                }))));
    }
}

class SliderScaleElement extends React.Component {
    constructor() {
        super(...arguments);
        this.calculateLabelPosition = () => {
            if (this.props.offset === 0) {
                return 0;
            }
            if (this.props.sliderWidth === parseInt(`${this.props.offset}`, 10)) {
                return this.props.offset - Math.ceil(this.scaleNumber ? this.state.scaleNumberWidth : 0) + 2 * this.props.sliderMargin;
            }
            return this.props.offset + this.props.sliderMargin - Math.ceil(this.scaleNumber ? this.state.scaleNumberWidth / 2 : 0);
        };
    }
    componentDidMount() {
        if (this.scaleNumber && this.scaleDot) {
            this.setState({ scaleDotWidth: this.scaleDot.offsetWidth, scaleNumberWidth: this.scaleNumber.offsetWidth });
        }
    }
    render() {
        const dotOffset = this.props.offset + this.props.sliderMargin - (this.scaleDot ? this.state.scaleDotWidth / 2 : 0);
        const numberOffset = this.calculateLabelPosition();
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: cx(uuiSlider.scaleDot, this.props.isFilledDot && uuiSlider.scaleFilledDot), ref: (scaleDotRef) => (this.scaleDot = scaleDotRef), style: { transform: `translateX(${dotOffset}px)` } }),
            React.createElement("div", { className: uuiSlider.scaleNumber, ref: (scaleNumberRef) => (this.scaleNumber = scaleNumberRef), style: { transform: `translateX(${numberOffset}px)` } }, this.props.label)));
    }
}

class SliderScaleBase extends React.Component {
    constructor() {
        super(...arguments);
        this.getPrecision = (step) => {
            const stepString = step.toString();
            const decimalIndex = stepString.indexOf('.');
            return decimalIndex >= 0 ? stepString.length - decimalIndex - 1 : 0;
        };
        this.generateScale = (step) => {
            const min = this.props.min;
            const max = this.props.max;
            const precision = this.getPrecision(step);
            const count = (max - min) / step;
            const scale = [min];
            for (let i = 1; i < count; i += 1) {
                const newValue = parseFloat((min + i * step).toFixed(precision));
                scale.push(newValue);
            }
            scale.push(max);
            return scale;
        };
    }
    render() {
        return React.createElement("div", { className: uuiSlider.scale }, this.renderSliderScaleElements());
    }
}

class RangeSliderScale extends SliderScaleBase {
    renderSliderScaleElements() {
        const splitAt = this.props.splitAt || this.props.max;
        const sliderWidth = this.props.slider && this.props.slider.offsetWidth;
        return this.generateScale(splitAt).map((value) => {
            const offset = (value - this.props.min) * this.props.valueWidth;
            const sliderMargin = isClientSide && this.props.slider && +window.getComputedStyle(this.props.slider).marginLeft.slice(0, -2);
            return (React.createElement(SliderScaleElement, { key: value, sliderWidth: sliderWidth, offset: offset, isFilledDot: this.props.handleOffset.from <= offset && offset <= this.props.handleOffset.to, label: value, sliderMargin: sliderMargin }));
        });
    }
}

class RangeSlider extends SliderBase {
    constructor() {
        super(...arguments);
        this.state = {
            isActive: false,
            valueWidth: 0,
            activeHandle: '',
        };
        this.onHandleValueChange = (mouseX, handleType, valueWidth) => {
            if (!this.state.activeHandle) {
                this.setState({ activeHandle: handleType });
            }
            if (this.getValue(mouseX, valueWidth) > this.props.value.to && this.state.activeHandle === 'from') {
                this.props.onValueChange({ from: this.props.value.to, to: this.props.value.to });
                this.setState({ activeHandle: 'to' });
            }
            else if (this.props.value.from > this.getValue(mouseX, valueWidth) && this.state.activeHandle === 'to') {
                this.props.onValueChange({ from: this.props.value.from, to: this.props.value.from });
                this.setState({ activeHandle: 'from' });
            }
            switch (this.state.activeHandle) {
                case 'from':
                    this.props.onValueChange({ from: this.getValue(mouseX, valueWidth), to: (this.props.value && this.props.value.to) || this.props.min });
                    break;
                case 'to':
                    this.props.onValueChange({ from: (this.props.value && this.props.value.from) || this.props.min, to: this.getValue(mouseX, valueWidth) });
                    break;
            }
        };
        this.handleMouseClick = (e) => {
            e.preventDefault();
            if (this.props.value.to - this.getValue(e.clientX, this.getValueWidth()) > this.getValue(e.clientX, this.getValueWidth()) - this.props.value.from) {
                this.props.onValueChange({ from: this.getValue(e.clientX, this.getValueWidth()), to: this.props.value.to });
            }
            else {
                this.props.onValueChange({ from: this.props.value.from, to: this.getValue(e.clientX, this.getValueWidth()) });
            }
        };
    }
    normalize(value) {
        if (!value && value !== 0) {
            return this.props.min;
        }
        return value > this.props.max ? this.props.max : value < this.props.min ? this.props.min : value;
    }
    getValueWidth() {
        return this.slider ? this.slider.offsetWidth / (this.props.max - this.props.min) : 0;
    }
    handleKeyDown(type, normValue) {
        const { step } = this.props;
        const { from, to } = normValue;
        const { activeHandle } = this.state;
        if (type === 'left') {
            this.props.onValueChange({
                from: activeHandle === 'from' ? this.normalize(from - step) : from,
                to: activeHandle === 'to' ? this.normalize(to - step) : to,
            });
        }
        else if (type === 'right') {
            this.props.onValueChange({
                from: activeHandle === 'from' ? this.normalize(from + step) : from,
                to: activeHandle === 'to' ? this.normalize(to + step) : to,
            });
        }
    }
    render() {
        var _a, _b;
        const from = this.props.value && this.props.value.from != null ? this.props.value.from : this.props.min;
        const to = this.props.value && this.props.value.to != null ? this.props.value.to : this.props.max;
        const normValueFrom = this.roundToStep(this.normalize(from), this.props.step);
        const normValueTo = this.roundToStep(this.normalize(to), this.props.step);
        const valueWidth = this.getValueWidth();
        const fromHandleOffset = (normValueFrom - this.props.min) * valueWidth;
        const toHandleOffset = (normValueTo - this.props.min) * valueWidth;
        return (React.createElement("div", Object.assign({ className: cx(uuiSlider.container, css$m.root, this.props.isDisabled && uuiMod.disabled, this.props.cx), onClick: this.handleMouseClick, ref: this.props.forwardedRef }, this.props.rawProps),
            React.createElement("div", { ref: (slider) => (this.slider = slider), className: cx(uuiSlider.slider, this.state.activeHandle && uuiMod.active) }),
            React.createElement("div", { className: uuiSlider.filled, style: {
                    width: (normValueFrom < normValueTo ? normValueTo - normValueFrom : normValueFrom - normValueTo) * valueWidth,
                    left: (normValueFrom < normValueTo ? normValueFrom - this.props.min : normValueTo - this.props.min) * valueWidth,
                } }),
            React.createElement(RangeSliderScale, { handleOffset: { from: fromHandleOffset, to: toHandleOffset }, slider: this.slider, min: this.props.min, max: this.props.max, splitAt: this.props.splitAt, valueWidth: valueWidth }),
            React.createElement(SliderHandle, { cx: this.props.cx, isActive: this.state.activeHandle === 'from', offset: fromHandleOffset, tooltipContent: normValueFrom, onUpdate: (mouseX) => this.onHandleValueChange(mouseX, 'from', valueWidth), onKeyDownUpdate: (type) => this.handleKeyDown(type, { from: normValueFrom, to: normValueTo }), handleActiveState: (isActive) => this.setState({ activeHandle: isActive ? 'from' : null }), rawProps: {
                    'aria-label': this.props.rawProps && this.props.rawProps['aria-label'] ? this.props.rawProps['aria-label'] : 'From',
                    'aria-valuenow': (_a = this.props.value) === null || _a === void 0 ? void 0 : _a.from,
                    'aria-valuemax': this.props.max,
                    'aria-valuemin': this.props.min,
                    role: 'slider',
                } }),
            React.createElement(SliderHandle, { cx: this.props.cx, isActive: this.state.activeHandle === 'to', offset: toHandleOffset, tooltipContent: normValueTo, onUpdate: (mouseX) => this.onHandleValueChange(mouseX, 'to', valueWidth), handleActiveState: (isActive) => this.setState({ activeHandle: isActive ? 'to' : null }), onKeyDownUpdate: (type) => this.handleKeyDown(type, { from: normValueFrom, to: normValueTo }), rawProps: {
                    'aria-label': this.props.rawProps && this.props.rawProps['aria-label'] ? this.props.rawProps['aria-label'] : 'To',
                    'aria-valuenow': (_b = this.props.value) === null || _b === void 0 ? void 0 : _b.to,
                    'aria-valuemax': this.props.max,
                    'aria-valuemin': this.props.min,
                    role: 'slider',
                } })));
    }
}

class SliderScale extends SliderScaleBase {
    renderSliderScaleElements() {
        var _a;
        const splitAt = this.props.splitAt || this.props.max - this.props.min;
        const sliderWidth = (_a = this.props.slider) === null || _a === void 0 ? void 0 : _a.offsetWidth;
        return this.generateScale(splitAt).map((value, index) => {
            const offset = (value - this.props.min) * this.props.valueWidth;
            const sliderMargin = isClientSide && this.props.slider && +window.getComputedStyle(this.props.slider).marginLeft.slice(0, -2);
            return (React.createElement(SliderScaleElement, { key: index, offset: offset, sliderWidth: sliderWidth, isFilledDot: this.props.handleOffset > offset, label: this.props.renderLabel ? this.props.renderLabel(value) : value, sliderMargin: sliderMargin }));
        });
    }
}

class Slider extends SliderBase {
    constructor() {
        super(...arguments);
        this.state = {
            isActive: false,
        };
    }
    normalize(value) {
        if (!value && value !== 0) {
            return this.props.min;
        }
        return value > this.props.max ? this.props.max : value < this.props.min ? this.props.min : value;
    }
    handleKeyDownUpdate(type) {
        const { value, step, min, max } = this.props;
        const floatPrecision = this.getFloatPrecision(step);
        if (type === 'left') {
            const newValue = ((value * floatPrecision - step * floatPrecision) / floatPrecision);
            if (newValue < min)
                return;
            else
                this.props.onValueChange(newValue);
        }
        else if (type === 'right') {
            const newValue = ((value * floatPrecision + step * floatPrecision) / floatPrecision);
            if (newValue > max)
                return;
            this.props.onValueChange(newValue);
        }
    }
    render() {
        const normValue = this.roundToStep(this.normalize(this.props.value), this.props.step);
        const valueWidth = (this.slider && this.slider.offsetWidth / (this.props.max - this.props.min)) || 0;
        const filledOffset = (normValue - this.props.min) * valueWidth;
        return (React.createElement("div", Object.assign({ className: cx(uuiSlider.container, css$m.root, this.props.isDisabled && uuiMod.disabled, this.props.cx, this.state.isActive && uuiMod.active), onClick: (e) => this.props.onValueChange(this.getValue(e.clientX, valueWidth)), onMouseDown: this.handleMouseDown, ref: this.props.forwardedRef }, this.props.rawProps),
            React.createElement("div", { ref: (slider) => (this.slider = slider), className: cx(uuiSlider.slider) }),
            React.createElement("div", { className: uuiSlider.filled, style: { width: filledOffset } }),
            React.createElement(SliderScale, { handleOffset: filledOffset, slider: this.slider, min: this.props.min, max: this.props.max, splitAt: this.props.splitAt, valueWidth: valueWidth, renderLabel: this.props.renderLabel }),
            React.createElement(SliderHandle, { cx: this.props.cx, isActive: this.state.isActive, tooltipContent: normValue, offset: filledOffset, onKeyDownUpdate: (type) => this.handleKeyDownUpdate(type), onUpdate: (mouseX) => this.props.onValueChange(this.getValue(mouseX, valueWidth)), handleActiveState: (newValue) => this.setState({ isActive: newValue }), showTooltip: this.props.showTooltip !== undefined ? this.props.showTooltip : true, rawProps: {
                    'aria-label': this.props.rawProps ? this.props.rawProps['aria-label'] : undefined,
                    'aria-valuenow': this.props.value,
                    'aria-valuemin': this.props.min,
                    'aria-valuemax': this.props.max,
                    role: 'slider',
                } })));
    }
}

var css$k = {"container":"DXz9dK"};

const Switch = /* @__PURE__ */React.forwardRef((props, ref) => {
    const context = useUuiContext();
    const toggle = () => {
        props.onValueChange(!props.value);
        if (props.getValueChangeAnalyticsEvent) {
            const event = props.getValueChangeAnalyticsEvent(!props.value, props.value);
            context.uuiAnalytics.sendEvent(event);
        }
    };
    return (React.createElement("label", Object.assign({ className: cx('uui-switch', css$k.container, props.cx, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, !props.isReadonly && !props.isDisabled && uuiMarkers.clickable), ref: ref }, props.rawProps),
        React.createElement("div", { className: cx(uuiElement.switchBody, props.value && uuiMod.checked), onFocus: props.onFocus, onBlur: props.onBlur },
            React.createElement("input", { type: "checkbox", role: "switch", onChange: !props.isReadonly ? toggle : undefined, readOnly: props.isReadonly, "aria-readonly": props.isReadonly || undefined, disabled: props.isDisabled, "aria-disabled": props.isDisabled, checked: props.value || false, "aria-checked": props.value || false, required: props.isRequired, tabIndex: props.tabIndex, id: props.id }),
            React.createElement("div", { className: uuiElement.switchToggler })),
        props.label && React.createElement("div", { className: uuiElement.inputLabel }, props.label)));
});

var css$j = {"container":"WJPuoS","auto-size":"eVzSx2","no-auto-size":"Qba4HL","autoSize":"eVzSx2","noAutoSize":"Qba4HL"};

const TextArea = /* @__PURE__ */React.forwardRef((props, ref) => {
    var _a;
    const [state, setState] = useState({
        inFocus: false,
    });
    const textAreaRef = useRef(null);
    const prevValue = useRef(null);
    const getParentOverflows = (el) => {
        const arr = [];
        while (el && el.parentNode && el.parentNode instanceof Element) {
            if (el.parentNode.scrollTop) {
                arr.push({
                    node: el.parentNode,
                    scrollTop: el.parentNode.scrollTop,
                });
            }
            el = el.parentNode;
        }
        return arr;
    };
    const updateHeight = () => {
        /* https://stackoverflow.com/questions/454202/creating-a-textarea-with-auto-resize */
        if (props.autoSize) {
            const node = textAreaRef.current;
            if (node) {
                const overflows = getParentOverflows(node);
                node.style.height = 'auto';
                const borderWidth = node.offsetHeight - node.clientHeight;
                node.style.height = node.scrollHeight + borderWidth + 'px';
                overflows.forEach((el) => {
                    el.node.scrollTop = el.scrollTop;
                });
            }
        }
    };
    useEffect(() => {
        // Delay auto-size hack to the next tick.
        // Helps with performance if there are many TextAreas on the page
        setTimeout(() => updateHeight(), 0);
    }, []);
    useEffect(() => {
        if ((prevValue === null || prevValue === void 0 ? void 0 : prevValue.current) !== props.value) {
            updateHeight();
        }
        prevValue.current = props.value;
    }, [props.value]);
    const handleChange = (e) => {
        // Android does not support maxLength
        // https://studysection.com/blog/the-html-maxlength-attribute-is-not-working-as-expected-on-android-phones/
        const targetValue = e.target.value;
        let newValue;
        if (props.maxLength && targetValue.length > props.maxLength) {
            newValue = targetValue.slice(0, props.maxLength);
        }
        else {
            newValue = targetValue;
        }
        props.onValueChange(newValue);
    };
    const handleFocus = (e) => {
        props.onFocus && props.onFocus(e);
        setState(() => ({ inFocus: true }));
    };
    const handleBlur = (e) => {
        props.onBlur && props.onBlur(e);
        setState(() => ({ inFocus: false }));
    };
    const handleWrapperFocus = () => {
        var _a;
        (_a = textAreaRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    return (React.createElement("div", Object.assign({ className: cx(css$j.container, uuiElement.inputBox, props.cx) }, props.rawProps, { tabIndex: -1, onFocus: handleWrapperFocus, ref: ref }),
        React.createElement("textarea", { autoFocus: props.autoFocus, placeholder: props.placeholder, className: cx(!props.isDisabled && uuiMarkers.clickable, props.autoSize || props.isDisabled || props.isReadonly ? css$j.autoSize : css$j.noAutoSize, uuiElement.input, !props.isReadonly && state.inFocus && uuiMod.focus, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, props.isInvalid && uuiMod.invalid, props.inputCx), rows: props.rows != null ? props.rows : props.autoSize ? 1 : undefined, id: props.id, readOnly: props.isReadonly, "aria-readonly": props.isReadonly, required: props.isRequired, disabled: props.isDisabled, "aria-disabled": props.isDisabled, onChange: handleChange, value: props.value || '', maxLength: props.maxLength, onFocus: handleFocus, onBlur: handleBlur, ref: textAreaRef, onKeyDown: props.onKeyDown, tabIndex: (state.inFocus || props.isReadonly || props.isDisabled) ? -1 : 0, dir: (_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.dir })));
});

var css$i = {"container":"lkkZri","hidden":"uT2jLv","pointer":"nHWO2Q"};

const ENTER = 'Enter';
const ESCAPE = 'Escape';
const TextInput = /* @__PURE__ */React.forwardRef((props, ref) => {
    const context = useUuiContext();
    const [inFocus, setInFocus] = React.useState(false);
    const inputElement = React.useRef();
    const handleChange = (e) => {
        // Android does not support maxLength
        // https://studysection.com/blog/the-html-maxlength-attribute-is-not-working-as-expected-on-android-phones/
        const targetValue = e.target.value;
        let newValue;
        if (props.maxLength && targetValue.length > props.maxLength) {
            newValue = targetValue.slice(0, props.maxLength);
        }
        else {
            newValue = targetValue;
        }
        props.onValueChange(newValue);
        if (props.getValueChangeAnalyticsEvent) {
            const event = props.getValueChangeAnalyticsEvent(newValue, props.value);
            context.uuiAnalytics.sendEvent(event);
        }
    };
    const handleKeyDown = (e) => {
        var _a, _b, _c;
        (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (e.key === ENTER)
            (_b = props.onAccept) === null || _b === void 0 ? void 0 : _b.call(props);
        else if (e.key === ESCAPE)
            (_c = props.onCancel) === null || _c === void 0 ? void 0 : _c.call(props);
    };
    const handleFocus = (event) => {
        var _a;
        setInFocus(true);
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, event);
    };
    const handleBlur = (event) => {
        var _a;
        setInFocus(false);
        (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, event);
    };
    const handleClick = (e) => {
        var _a;
        if (e.target.classList.contains(uuiMarkers.clickable)) {
            return e.preventDefault();
        }
        (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, e);
    };
    const handleCancel = () => {
        var _a;
        props.onCancel();
        (_a = inputElement.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const handleWrapperFocus = () => {
        var _a;
        (_a = inputElement.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const getInputProps = () => {
        var _a;
        return ({
            type: props.type || 'text',
            className: cx(uuiElement.input, props.inputCx),
            disabled: props.isDisabled,
            placeholder: props.placeholder,
            value: props.value || '',
            readOnly: props.isReadonly,
            onKeyDown: handleKeyDown,
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            autoFocus: props.autoFocus,
            ref: inputElement,
            autoComplete: props.autoComplete,
            name: props.name,
            maxLength: props.maxLength,
            inputMode: props.inputMode,
            tabIndex: (props.tabIndex || inFocus || props.isReadonly || props.isDisabled) ? -1 : 0,
            id: props.id,
            required: props.isRequired,
            'aria-invalid': props.isInvalid,
            'aria-disabled': props.isDisabled,
            dir: (_a = props === null || props === void 0 ? void 0 : props.rawProps) === null || _a === void 0 ? void 0 : _a.dir, //
        });
    };
    const icon = props.icon && React.createElement(IconContainer, { icon: props.icon, onClick: props.onIconClick });
    const showIconsOnAction = props.value && !props.isReadonly && !props.isDisabled;
    return (React.createElement("div", Object.assign({ onClick: props.onClick && handleClick, ref: ref, className: cx(css$i.container, uuiElement.inputBox, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, props.isInvalid && uuiMod.invalid, !props.isReadonly && !props.isDisabled && uuiMarkers.clickable, !props.isReadonly && inFocus && uuiMod.focus, props.cx), tabIndex: -1, onFocus: handleWrapperFocus }, props.rawProps),
        props.iconPosition !== 'right' && icon,
        props.renderInput ? props.renderInput(getInputProps()) : React.createElement("input", Object.assign({}, getInputProps())),
        props.onAccept && showIconsOnAction && (React.createElement(IconContainer, { cx: cx('uui-icon-accept'), isDisabled: props.isDisabled, icon: props.acceptIcon, onClick: props.onAccept, rawProps: { role: 'button' } })),
        props.onCancel && showIconsOnAction && (React.createElement(IconContainer, { cx: cx('uui-icon-cancel', uuiMarkers.clickable), isDisabled: props.isDisabled, icon: props.cancelIcon, onClick: handleCancel, rawProps: { role: 'button' } })),
        props.iconPosition === 'right' && icon,
        props.isDropdown && (React.createElement(IconContainer, { cx: cx((props.isReadonly || props.isDisabled) && css$i.hidden, css$i.pointer), icon: props.dropdownIcon, flipY: props.isOpen }))));
});

var css$h = {"prefixWrapper":"q7XNRp"};

function InputAddon(props) {
    return (React__default.createElement("div", { className: cx(css$h.prefixWrapper, props.cx, 'uui-input-addon') }, props.content));
}

var css$g = {"avatar":"bld93l"};

function AvatarComponent(props, ref) {
    const [isError, setIsError] = React__default.useState(false);
    function onError() {
        if (!isError) {
            setIsError(true);
        }
    }
    return (React__default.createElement("img", Object.assign({ ref: ref, className: cx(css$g.avatar, props.cx), width: props.size, height: props.size, src: props.isLoading || !props.img || isError
            ? 'https://static.cdn.epam.com/uploads/690afa39a93c88c4dd13758fe1d869d5/EPM-UUI/icons/avatar_placeholder.svg'
            : props.img, alt: props.alt, onError: onError }, props.rawProps)));
}
const Avatar = /* @__PURE__ */React__default.forwardRef(AvatarComponent);

var css$f = {"avatar-right":"dbKG-V","avatar-left":"HsID5q","container":"FnFbDF","avatarRight":"dbKG-V","avatarLeft":"HsID5q"};

const AvatarStack = /* @__PURE__ */React.forwardRef((props, ref) => {
    const { avatarSize, urlArray, direction, avatarsCount, renderItem, } = props;
    const firstElements = avatarsCount && urlArray.length > avatarsCount ? urlArray.slice(0, avatarsCount) : urlArray;
    const styleObj = { '--overlap': `-${+avatarSize / 4}px` };
    return (React.createElement(FlexRow, { cx: props.cx, ref: ref, rawProps: props.rawProps },
        React.createElement(FlexRow, { rawProps: { role: 'group', style: styleObj }, cx: cx$1('avatars', css$f.container, css$f['avatar-' + direction]) }, firstElements.map((avatar, index) => {
            return renderItem ? (React.createElement(React.Fragment, { key: index }, renderItem(avatar))) : (React.createElement(Avatar, { key: index, size: avatarSize, img: avatar, alt: "avatar" }));
        })),
        React.createElement("div", { className: "avatarsCount" }, avatarsCount && urlArray.length > avatarsCount ? '+' + (urlArray.length - avatarsCount) : null)));
});

var css$e = {"container":"_1MdveG"};

const QUANTITY_OF_DOTS = 3;
const uuiSpinner = {
    container: 'uui-spinner-container',
    dot: 'uui-spinner-dot',
    animation: 'uui-spinner-animation',
    dot1: 'uui-spinner-dot-1',
    dot2: 'uui-spinner-dot-2',
    dot3: 'uui-spinner-dot-3',
};
class Spinner extends React.Component {
    render() {
        const dots = [];
        for (let i = 0; i < QUANTITY_OF_DOTS; i += 1) {
            dots.push(React.createElement("div", { key: i, className: cx(uuiSpinner.dot, uuiSpinner['dot' + (i + 1)]) }));
        }
        return (React.createElement("div", Object.assign({ className: cx(css$e.container, uuiSpinner.container, this.props.cx), ref: this.props.forwardedRef }, this.props.rawProps),
            React.createElement("div", { className: uuiSpinner.animation }, dots)));
    }
}

const FIRST_PAGE = 1;
const SIMPLE_PAGINATION_ITEMS = 7;
class Paginator extends React.Component {
    constructor() {
        super(...arguments);
        this.getCurrentPage = () => { var _a; return (_a = this.props.value) !== null && _a !== void 0 ? _a : 1; };
        this.isFirst = () => {
            return this.getCurrentPage() === FIRST_PAGE;
        };
        this.isLast = () => {
            return this.getCurrentPage() === this.props.totalPages;
        };
        this.goToNext = () => {
            var _a;
            this.props.onValueChange(((_a = this.props.value) !== null && _a !== void 0 ? _a : 0) + 1);
        };
        this.goToPrev = () => {
            var _a;
            const currentPage = (_a = this.props.value) !== null && _a !== void 0 ? _a : 0;
            const prevPage = Math.max(currentPage - 1, 0);
            this.props.onValueChange(prevPage);
        };
    }
    getPagesView() {
        const paginatorItems = [];
        const pages = this.props.totalPages;
        const currentPage = this.getCurrentPage();
        const currentValue = this.props.value;
        const onClick = (value) => {
            this.props.onValueChange(value);
            if (this.props.getValueChangeAnalyticsEvent) {
                const event = this.props.getValueChangeAnalyticsEvent(value, currentValue);
                this.context.uuiAnalytics.sendEvent(event);
            }
        };
        function addPage(page) {
            if (page !== currentValue) {
                return paginatorItems.push({ type: 'page', pageNumber: page, onClick: () => onClick(page) });
            }
            return paginatorItems.push({
                type: 'page', pageNumber: page, onClick: () => onClick(page), isActive: true,
            });
        }
        function addSpacer() {
            return paginatorItems.push({ type: 'spacer' });
        }
        // If the number of pages is not more than the maximum number of displayed pages, then we add all pages to the array
        if (pages <= SIMPLE_PAGINATION_ITEMS) {
            range(1, pages + 1).forEach((pageNumber) => {
                addPage(pageNumber);
            });
        }
        // If the number of pages exceeds the maximum number of displayed pages
        if (pages > SIMPLE_PAGINATION_ITEMS) {
            // If the current page is less than the maximum number of pages displayed at the beginning before the spacer,
            // we show the couple pages, spacer and the last page
            if (currentPage < 5) {
                range(1, 6).forEach((pageNumber) => addPage(pageNumber));
                addSpacer();
                addPage(pages);
            }
            // If the current page is greater than the maximum number of pages that are shown at the beginning
            // and less than the maximum number of pages that are shown at the end
            // to show the first page, a spacer, three pages of the current, spacer, and the last page
            if (currentPage > pages - 4) {
                addPage(1);
                addSpacer();
                range(pages - 4, pages + 1).forEach((pageNumber) => addPage(pageNumber));
            }
            // If the current page is greater than the maximum number of pages displayed at the end after the spacer,
            // we show the first page, spacer and last pages
            if (currentPage > 4 && currentPage < pages - 3) {
                addPage(1);
                addSpacer();
                range(currentPage - 1, currentPage + 2).forEach((pageNumber) => addPage(pageNumber));
                addSpacer();
                addPage(pages);
            }
        }
        return paginatorItems;
    }
    render() {
        return this.props.render({
            size: this.props.size,
            pages: this.getPagesView(),
            goToNext: this.goToNext,
            goToPrev: this.goToPrev,
            isFirst: this.isFirst(),
            isLast: this.isLast(),
            rawProps: this.props.rawProps,
        });
    }
}
Paginator.contextType = UuiContext;

var css$d = {"file-input":"_6Rfqe-","fileInput":"_6Rfqe-"};

class UploadFileToggler extends React.Component {
    constructor() {
        super(...arguments);
        this.fileInput = React.createRef();
        this.onClick = () => {
            var _a;
            (_a = this.fileInput.current) === null || _a === void 0 ? void 0 : _a.click();
        };
    }
    render() {
        return (React.createElement("div", Object.assign({ ref: this.props.forwardedRef }, this.props.rawProps),
            React.createElement("input", { className: css$d.fileInput, ref: this.fileInput, onChange: (e) => {
                    this.props.onFilesAdded(Array.prototype.slice.call(e.currentTarget.files, 0));
                    e.currentTarget.value = null;
                }, type: "file", multiple: !this.props.single, accept: this.props.accept }),
            this.props.render({ onClick: this.onClick })));
    }
}

class DropSpot extends React.Component {
    constructor() {
        super(...arguments);
        this.entriesCount = 0;
        this.onDragOverHandler = (e) => {
            e.preventDefault();
        };
        this.onDropHandler = () => {
            this.entriesCount = 0;
            this.setState({ isDragStart: false, isDraggingOver: false });
        };
        this.onDragStart = (e) => {
            var _a;
            e.preventDefault();
            this.entriesCount++;
            this.entriesCount === 1 && ((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.types.includes('Files')) && this.setState({ isDragStart: true });
        };
        this.onDragEnd = (e) => {
            var _a;
            e.preventDefault();
            this.entriesCount--;
            this.entriesCount === 0 && ((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.types.includes('Files')) && this.setState({ isDragStart: false });
        };
        this.onDrop = (e) => {
            e.preventDefault();
            this.entriesCount--;
            this.setState({ isDragStart: false, isDraggingOver: false });
            this.props.onFilesDropped(Array.prototype.slice.call(e.dataTransfer.files, 0));
        };
        this.onDragOver = (e) => {
            e.preventDefault();
            this.setState({ isDraggingOver: true });
        };
        this.onDragEnter = (e) => {
            e.preventDefault();
            this.setState({ isDraggingOver: true });
        };
        this.onDragLeave = (e) => {
            e.preventDefault();
            this.setState({ isDraggingOver: false });
        };
    }
    componentDidMount() {
        window.addEventListener('dragenter', this.onDragStart);
        window.addEventListener('dragleave', this.onDragEnd);
        window.addEventListener('drop', this.onDropHandler);
        window.addEventListener('dragover', this.onDragOverHandler);
    }
    componentWillUnmount() {
        window.removeEventListener('dragenter', this.onDragStart);
        window.removeEventListener('dragleave', this.onDragEnd);
        window.removeEventListener('drop', this.onDropHandler);
        window.removeEventListener('dragover', this.onDragOverHandler);
    }
    render() {
        const eventHandlers = {
            onDragEnter: this.onDragEnter,
            onDragLeave: this.onDragLeave,
            onDragOver: this.onDragOver,
            onDrop: this.onDrop,
        };
        return this.props.render(Object.assign(Object.assign({}, this.state), { eventHandlers }));
    }
}

var css$c = {"container":"IlWOwq","bar":"Tde6Y7","label":"hudsyX"};

const ProgressBar = /* @__PURE__ */React.forwardRef((props, ref) => {
    const { hideLabel = false, progress, label } = props;
    const barLabel = label || `${props.progress || 0}%`;
    return (React.createElement("div", Object.assign({ ref: ref, className: cx$1('uui-progress_bar', props.cx, css$c.container) }, props.rawProps),
        React.createElement("div", { role: "progressbar", className: cx$1(css$c.bar, 'bar'), style: { width: `${props.progress || 0}%` }, "aria-valuenow": progress, "aria-valuemin": 0, "aria-valuemax": 100 }),
        !hideLabel && (React.createElement(React.Fragment, null,
            React.createElement("div", { className: cx$1(css$c.label, 'label') }, barLabel),
            React.createElement("div", { className: cx$1(css$c.label, 'topLabel'), style: { clipPath: `inset(0 0 0 ${props.progress}%)` } }, barLabel)))));
});

const Clickable = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    var _a;
    const context = useUuiContext();
    const isAnchor = Boolean(props.href || props.link || props.type === 'anchor');
    const isButton = Boolean(!isAnchor && (props.onClick || props.type === 'button'));
    const hasClick = Boolean(!props.isDisabled && (props.link || props.onClick));
    const getIsLinkActive = () => {
        var _a;
        if (props.isLinkActive !== undefined) {
            return props.isLinkActive;
        }
        else {
            return props.link ? (_a = context.uuiRouter) === null || _a === void 0 ? void 0 : _a.isActive(props.link) : false;
        }
    };
    const clickHandler = (e) => {
        if (!isEventTargetInsideClickable(e) && !props.isDisabled) {
            if (props.onClick) {
                props.onClick(e);
            }
            if (!!props.link) {
                if (props.target) { // if target _blank we should not invoke redirect
                    return;
                }
                e.preventDefault();
                context.uuiRouter.redirect(props.link);
            }
            context.uuiAnalytics.sendEvent(props.clickAnalyticsEvent);
        }
    };
    const getTabIndex = () => {
        if (!props.tabIndex && (props.isDisabled || (!props.onClick && !props.link && !props.href))) {
            return -1;
        }
        return props.tabIndex || 0;
    };
    const getHref = () => { var _a; return props.link ? (_a = context.uuiRouter) === null || _a === void 0 ? void 0 : _a.createHref(props.link) : props.href; };
    const className = cx({
        [uuiElement.buttonBox]: true,
        [uuiMod.enabled]: !props.isDisabled,
        [uuiMod.disabled]: props.isDisabled,
        [uuiMod.active]: getIsLinkActive(),
        [uuiMarkers.clickable]: isAnchor || hasClick,
        [uuiElement.anchor]: isAnchor,
    }, props.cx);
    const commonProps = {
        className,
        onClick: hasClick ? clickHandler : undefined,
        tabIndex: getTabIndex(),
        'aria-disabled': props.isDisabled,
        // NOTE: do not use disabled attribute for button because it will prevent all events and broke Tooltip at least
        // more info: https://github.com/epam/UUI/issues/1057#issuecomment-1508632942
        // disabled: props.isDisabled,
    };
    if (isAnchor) {
        const { target } = props;
        const relProp = target === '_blank' ? { rel: 'noopener noreferrer' } : {};
        const href = !props.isDisabled ? getHref() : undefined;
        return (React__default.createElement("a", Object.assign({ href: href, target: target, ref: ref }, relProp, commonProps, props.rawProps), props.children));
    }
    if (isButton) {
        return (React__default.createElement("button", Object.assign({ ref: ref, type: ((_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.type) || 'button' }, commonProps, props.rawProps), props.children));
    }
    return (React__default.createElement("span", Object.assign({ ref: ref }, commonProps, props.rawProps), props.children));
});

var css$b = {"container":"hu-Zps"};

const Button = /* @__PURE__ */React.forwardRef((props, ref) => {
    return (React.createElement(Clickable, Object.assign({}, props, { rawProps: Object.assign({ 'aria-haspopup': props.isDropdown, 'aria-expanded': props.isOpen }, props.rawProps), cx: [css$b.container, props.cx], type: "button", ref: ref }),
        props.icon && props.iconPosition !== 'right' && (React.createElement(IconContainer, { icon: props.icon, onClick: !props.isDisabled ? props.onIconClick : undefined })),
        props.caption && (React.createElement("div", { className: uuiElement.caption }, props.caption)),
        props.icon && props.iconPosition === 'right' && (React.createElement(IconContainer, { icon: props.icon, onClick: !props.isDisabled ? props.onIconClick : undefined })),
        props.isDropdown && (React.createElement(IconContainer, { icon: props.dropdownIcon, flipY: props.isOpen })),
        props.onClear && !props.isDisabled && (React.createElement(IconContainer, { cx: uuiMarkers.clickable, icon: props.clearIcon, onClick: props.onClear }))));
});

var css$a = {"container":"g5xIoC"};

const IconButton = /* @__PURE__ */React.forwardRef((props, ref) => {
    return (React.createElement(Clickable, Object.assign({}, props, { type: "button", cx: [css$a.container, props.cx], ref: ref }),
        React.createElement(IconContainer, { icon: props.icon, size: props.size }),
        props.showDropdownIcon && (React.createElement(IconContainer, { icon: props.dropdownIcon, flipY: props.isOpen, size: props.size }))));
});

var css$9 = {"container":"buM1o1"};

const Anchor = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    return (React__default.createElement(Clickable, Object.assign({}, props, { type: "anchor", cx: [css$9.container, props.cx], ref: ref })));
});

var css$8 = {"container":"OmuixF","container-content":"UeItcA","burger-transition-enter":"_0rQQdn","burger-transition-enter-active":"Pn1CQM","burger-transition-exit":"_3a73I1","burger-transition-exit-active":"MRxuH-","containerContent":"UeItcA","burgerTransitionEnter":"_0rQQdn","burgerTransitionEnterActive":"Pn1CQM","burgerTransitionExit":"_3a73I1","burgerTransitionExitActive":"MRxuH-"};

const uuiBurger = {
    menu: 'uui-burger-menu',
    menuOpen: 'uui-burger-menu-open',
    button: 'uui-burger-button',
    logoContainer: 'uui-burger-logo-container',
    logo: 'uui-burger-logo',
    overlay: 'uui-burger-overlay',
    items: 'uui-burger-items',
    overlayVisible: 'uui-burger-overlay-visible',
    itemsVisible: 'uui-burger-items-visible',
};
const uuiBurgerTransitionTimeout = {
    // Keep the timeouts in sync with the corresponding CSS style transitions.
    enter: 200,
    exit: 200,
};
const uuiBurgerTransitionClasses = {
    enter: css$8.burgerTransitionEnter,
    enterActive: css$8.burgerTransitionEnterActive,
    exit: css$8.burgerTransitionExit,
    exitActive: css$8.burgerTransitionExitActive,
};
class Burger extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            isOpen: false,
        };
        this.toggleBurgerMenu = () => {
            const isOpen = !this.state.isOpen;
            this.setState({
                isOpen: isOpen,
            });
            if (isOpen) {
                document.body.style.overflow = 'hidden';
            }
            else {
                document.body.style.overflow = null;
            }
        };
        this.renderContent = (ref) => {
            const handleKeyDown = (e) => {
                if (e.key === 'Escape' && this.state.isOpen) {
                    this.toggleBurgerMenu();
                }
            };
            const handleOnClick = (e) => {
                // check whether it was clicked outside of burger menu list
                if (e.target === e.currentTarget) {
                    this.toggleBurgerMenu();
                }
            };
            return (React.createElement("div", { ref: ref, className: cx$1(this.props.cx, this.props.burgerContentCx, uuiBurger.overlay, uuiBurger.overlayVisible, css$8.containerContent), onClick: handleOnClick },
                React.createElement(FocusLock, { returnFocus: true, className: cx$1(this.props.cx, uuiBurger.items, uuiBurger.itemsVisible), lockProps: { onKeyDown: handleKeyDown } }, this.props.renderBurgerContent ? this.props.renderBurgerContent({ onClose: this.toggleBurgerMenu }) : undefined)));
        };
    }
    componentWillUnmount() {
        if (this.state.isOpen) {
            document.body.style.overflow = null;
        }
    }
    render() {
        return (React.createElement(React.Fragment, null,
            React.createElement("div", Object.assign({ ref: this.props.forwardedRef, className: cx$1(this.props.cx, uuiBurger.menu, css$8.container, this.state.isOpen && uuiBurger.menuOpen) }, this.props.rawProps),
                React.createElement("button", { className: uuiBurger.button, onClick: this.toggleBurgerMenu },
                    React.createElement(IconContainer, { icon: this.state.isOpen ? this.props.crossIcon : this.props.burgerIcon }))),
            React.createElement(PortalWithCssTransition, { timeout: uuiBurgerTransitionTimeout, cssTransitionClasses: uuiBurgerTransitionClasses, isOpen: this.state.isOpen, renderContent: this.renderContent })));
    }
}
/**
 * Renders portal with CSSTransition animation.
 * The portal is mounted only if isOpen=true so that it's compatible with SSR.
 */
function PortalWithCssTransition(props) {
    const { isOpen, timeout, cssTransitionClasses } = props, portalProps = __rest(props, ["isOpen", "timeout", "cssTransitionClasses"]);
    const nodeRef = useRef(null);
    const renderContentLocal = useCallback((ref) => {
        return React.createElement(Portal, Object.assign({}, portalProps), props.renderContent(ref));
    }, [props.renderContent]);
    return (React.createElement(CSSTransition, { nodeRef: nodeRef, in: isOpen, timeout: timeout, mountOnEnter: true, unmountOnExit: true, classNames: cssTransitionClasses }, renderContentLocal(nodeRef)));
}

var css$7 = {"container":"CxmWda","logo":"y1K7zH","arrow":"kQRY5N"};

class MainMenuLogo extends React.Component {
    render() {
        return (React.createElement("div", Object.assign({ onContextMenu: this.props.onContextMenu, onClick: this.props.onClick, ref: this.props.forwardedRef }, this.props.rawProps),
            React.createElement(Anchor, { cx: css$7.container, link: this.props.link, href: this.props.href, target: this.props.target, isDisabled: !this.props.href && !this.props.link },
                React.createElement("img", { className: css$7.logo, alt: "Main Menu Logo", src: this.props.logoUrl ? this.props.logoUrl : undefined, style: { backgroundColor: this.props.logoBgColor } }),
                this.props.showArrow && React.createElement("div", { className: cx(css$7.logo, css$7.arrow), style: { borderLeftColor: this.props.logoBgColor } }))));
    }
}

var css$6 = {"container":"T5f7nd","logo":"T15DZV","itemsContainer":"Iosd2M"};

const uuiMainMenu = {
    container: 'uui-mainmenu-container',
    serverBadge: 'uui-mainmenu-server-badge',
    serverBadgeLabel: 'uui-mainmenu-server-badge-label',
    transparent: 'uui-mainmenu-transparent',
};
class MainMenu extends React__default.Component {
    constructor(props) {
        super(props);
        this.state = {
            isSidebarOpened: false,
        };
    }
    convertReactChildrenToItems(children) {
        const MainMenuDropdown = this.props.MainMenuDropdown;
        let lastItemsIndexWithCollapseToMore;
        let maxCollapseToMorePriority = 0;
        const items = React__default.Children.map(children, (child, index) => {
            if (child) {
                const priority = child.props.priority || index;
                if (child.props.collapseToMore) {
                    lastItemsIndexWithCollapseToMore = index;
                    if (priority > maxCollapseToMorePriority) {
                        maxCollapseToMorePriority = priority;
                    }
                }
                return {
                    id: index,
                    priority: priority,
                    render: (item, hiddenItems) => {
                        if (child.props.collapsedContainer) {
                            return React__default.cloneElement(child, { children: hiddenItems === null || hiddenItems === void 0 ? void 0 : hiddenItems.map((i) => i.render(item, hiddenItems)) });
                        }
                        return child;
                    },
                    collapsedContainer: child.props.collapsedContainer,
                    props: child.props,
                };
            }
        });
        if (lastItemsIndexWithCollapseToMore) {
            items.splice(lastItemsIndexWithCollapseToMore, 0, {
                id: 'moreButton',
                priority: maxCollapseToMorePriority,
                render: (item, hiddenItems) => (React__default.createElement(MainMenuDropdown, { key: "moreDropdown", caption: i18n.mainMenu.moreButtonCaption, children: hiddenItems === null || hiddenItems === void 0 ? void 0 : hiddenItems.filter((i) => i.props.collapseToMore).map((i) => i.render(item, hiddenItems)) })),
                collapsedContainer: true,
            });
        }
        return items;
    }
    renderServerBadge() {
        let serverBadgeColor;
        if (!this.props.serverBadge) {
            return;
        }
        else {
            switch (this.props.serverBadge) {
                case 'Dev':
                    serverBadgeColor = '#39b7ac';
                    break;
                case 'QA':
                    serverBadgeColor = '#a3c644';
                    break;
                case 'UAT':
                    serverBadgeColor = '#937ebd';
                    break;
                default:
                    serverBadgeColor = '#30b6dd';
            }
        }
        return this.props.serverBadge !== 'Prod' && this.props.serverBadge !== 'Public' && this.props.serverBadge !== 'Demo' ? (React__default.createElement("div", { className: cx(uuiMainMenu.serverBadge) },
            React__default.createElement("div", { className: cx(uuiMainMenu.serverBadgeLabel), style: { background: serverBadgeColor } }, this.props.serverBadge))) : null;
    }
    getMenuItems() {
        const Burger = this.props.Burger;
        const items = this.convertReactChildrenToItems(this.props.children) || [];
        if (this.props.appLogoUrl) {
            items.unshift({
                id: 'appLogo',
                priority: 100500,
                render: () => (React__default.createElement(MainMenuLogo, { key: "logo", logoUrl: this.props.appLogoUrl, link: this.props.logoLink, href: this.props.logoHref, onClick: this.props.onLogoClick })),
            });
        }
        if (this.props.customerLogoUrl) {
            items.unshift({
                id: 'customerLogo',
                priority: 100499,
                render: () => (React__default.createElement(MainMenuLogo, { key: "customerLogo", logoUrl: this.props.customerLogoUrl, logoBgColor: this.props.customerLogoBgColor, link: this.props.customerLogoLink || this.props.logoLink, href: this.props.customerLogoHref || this.props.logoHref, showArrow: true })),
            });
        }
        items.unshift({
            id: 'Burger',
            priority: 100501,
            collapsedContainer: !this.props.alwaysShowBurger,
            render: () => (React__default.createElement(Burger, { key: "burger", width: 300, renderBurgerContent: this.props.renderBurger, logoUrl: this.props.customerLogoUrl || this.props.appLogoUrl, bg: this.props.customerLogoBgColor || undefined })),
        });
        return items;
    }
    render() {
        return (React__default.createElement("nav", Object.assign({ key: "uuiMainMenu", className: cx(this.props.cx, uuiMainMenu.container, css$6.container, this.props.isTransparent && uuiMainMenu.transparent) }, this.props.rawProps),
            React__default.createElement(AdaptivePanel, { items: this.props.items || this.getMenuItems(), cx: css$6.itemsContainer }),
            this.renderServerBadge()));
    }
}

class MainMenuCustomElement extends React.Component {
    render() {
        return this.props.children;
    }
}

function useScrollSpy(props) {
    const ref = useRef();
    const [observedNodes, setObservedNodes] = useState([]);
    const [currentActive, setCurrentActive] = useState(props.initialActive || (Array.isArray(props.elements) && props.elements.length > 0 && props.elements[0]));
    const setRef = useCallback((selectedRef) => (ref.current = selectedRef), [ref]);
    const getElement = useCallback((id) => {
        var _a;
        return (_a = ref.current) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-spy=${id}]`);
    }, [ref]);
    const scrollToElement = useCallback((item) => {
        var _a;
        const selected = props.elements && item && props.elements.includes(item) ? props.elements.find((element) => element === item) : null;
        const element = selected ? getElement(selected) : null;
        if (element)
            element.scrollIntoView({ block: 'start', behavior: 'smooth' });
        else
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'start', behavior: 'smooth' });
    }, [ref]);
    useEffect(() => {
        if (!ref || !props.elements || !Array.isArray(props.elements) || props.elements.length === 0)
            return;
        setObservedNodes(props.elements.map(getElement));
    }, [ref]);
    useEffect(() => {
        var _a;
        if (observedNodes.length === 0)
            return;
        const observer = new IntersectionObserver((entries) => {
            var _a, _b, _c, _d, _e;
            if (entries.length === 1) {
                const currentElementName = (_c = (_b = (_a = entries[0]) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.dataset) === null || _c === void 0 ? void 0 : _c.spy;
                const isCurrentElementIntersecting = entries[0].isIntersecting;
                setCurrentActive((prevElementName) => {
                    if (isCurrentElementIntersecting)
                        return currentElementName;
                    // if previous 'currentActive' is not the one which exited the screen - don't change 'currentActive'
                    if (prevElementName !== currentElementName)
                        return prevElementName;
                    return '';
                });
            }
            else {
                const intersectingElement = entries.find((entry) => entry.isIntersecting);
                setCurrentActive((_e = (_d = intersectingElement === null || intersectingElement === void 0 ? void 0 : intersectingElement.target) === null || _d === void 0 ? void 0 : _d.dataset) === null || _e === void 0 ? void 0 : _e.spy);
            }
        }, Object.assign(Object.assign({}, props.options), { root: ((_a = props === null || props === void 0 ? void 0 : props.options) === null || _a === void 0 ? void 0 : _a.root) || document.querySelector('body') }));
        observedNodes.forEach((element) => (element ? observer.observe(element) : null));
        return () => observer.disconnect();
    }, [observedNodes]);
    return {
        scrollToElement,
        currentActive,
        setRef,
    };
}
function ScrollSpy({ elements, children }) {
    const { currentActive, scrollToElement, setRef } = useScrollSpy({ elements });
    return children({ scrollToElement, currentActive, setRef });
}

var css$5 = {"container":"x0wQE2","section":"s2m70b","scrolling-section":"xZaB8i","fixed-columns-section-left":"kDKeK9","fixed-columns-section-right":"yupNu3","scrollingSection":"xZaB8i","fixedColumnsSectionLeft":"kDKeK9","fixedColumnsSectionRight":"yupNu3"};

const uuiDataTableRowCssMarkers = {
    uuiTableRowContainer: 'uui-table-row-container',
    uuiTableFixedSection: 'uui-table-fixed-section',
    uuiTableScrollingSection: 'uui-table-scrolling-section',
    uuiTableFixedSectionLeft: 'uui-table-fixed-section-left',
    uuiTableFixedSectionRight: 'uui-table-fixed-section-right',
    uuiScrollShadowLeft: 'uui-scroll-shadow-left',
    uuiScrollShadowRight: 'uui-scroll-shadow-right',
};
const CELL_BORDER_WIDTH = 1;
// Scrolling/Fixed sections wrappers, as well as the whole row itself, has to have matching flex-item parameters.
// This is required to have the same width, as the sum of column's width, and grow in the same proportion, as columns inside.
// E.g. for 2 columns: { width: 100, grow: 0 }, { width: 200, grow: 1 } we compute { width: 300, grow: 1 }
// For scrollingSection and for the whole table, we put at least grow=1 - to make the table occupy full width, even if there's no columns with grow > 0.
function getSectionStyle(columns, minGrow = 0) {
    let grow = 0;
    let width = 0;
    columns.forEach((column) => {
        const columnWidth = typeof column.width === 'number' ? (column.fix ? column.width : column.width - CELL_BORDER_WIDTH) : column.minWidth || 0; // (column.width - CELL_BORDER_WIDTH) do not forget the negative margin of the scrolling columns in the calculation of the width
        width += columnWidth;
        grow += typeof column.grow === 'number' ? column.grow : 0;
    });
    grow = Math.max(grow, minGrow);
    return {
        flex: `${grow} 0 ${width}px`,
        minWidth: `${width}px`,
        '--uui-dt-cell-border-width': `${CELL_BORDER_WIDTH}px`,
    };
}
const DataTableRowContainer = /* @__PURE__ */React__default.forwardRef((props, ref) => {
    var _a;
    const _b = (_a = props.rawProps) !== null && _a !== void 0 ? _a : {}, { onPointerDown, onTouchStart } = _b, restRawProps = __rest(_b, ["onPointerDown", "onTouchStart"]);
    function renderCells(columns) {
        return columns.reduce((cells, column) => {
            var _a;
            const idx = ((_a = props.columns) === null || _a === void 0 ? void 0 : _a.indexOf(column)) || 0;
            cells.push(props.renderCell(column, idx, { onPointerDown, onTouchStart }));
            return cells;
        }, []);
    }
    function wrapFixedSection(columns, direction, hasScrollingSection) {
        return (React__default.createElement("div", { style: getSectionStyle(columns), className: cx({
                [css$5.section]: true,
                [uuiDataTableRowCssMarkers.uuiTableFixedSection]: true,
                [css$5.fixedColumnsSectionLeft]: direction === 'left',
                [uuiDataTableRowCssMarkers.uuiTableFixedSectionLeft]: direction === 'left',
                [css$5.fixedColumnsSectionRight]: direction === 'right',
                [uuiDataTableRowCssMarkers.uuiTableFixedSectionRight]: direction === 'right',
            }) },
            renderCells(columns),
            hasScrollingSection && direction === 'right' && React__default.createElement("div", { className: uuiDataTableRowCssMarkers.uuiScrollShadowLeft }),
            hasScrollingSection && direction === 'left' && React__default.createElement("div", { className: uuiDataTableRowCssMarkers.uuiScrollShadowRight }),
            direction === 'right' && props.renderConfigButton && props.renderConfigButton()));
    }
    function wrapScrollingSection(columns) {
        return (React__default.createElement("div", { className: cx(css$5.section, css$5.scrollingSection, uuiDataTableRowCssMarkers.uuiTableScrollingSection), style: getSectionStyle(columns, 1) }, renderCells(columns)));
    }
    function getRowContent() {
        const fixedLeftColumns = [];
        const fixedRightColumns = [];
        const scrollingColumns = [];
        for (const column of props.columns) {
            if (column.fix === 'left')
                fixedLeftColumns.push(column);
            else if (column.fix === 'right')
                fixedRightColumns.push(column);
            else
                scrollingColumns.push(column);
        }
        const hasScrollingSection = scrollingColumns.length > 0;
        return (React__default.createElement(React__default.Fragment, null,
            fixedLeftColumns.length > 0 && wrapFixedSection(fixedLeftColumns, 'left', hasScrollingSection),
            wrapScrollingSection(scrollingColumns),
            fixedRightColumns.length > 0 && wrapFixedSection(fixedRightColumns, 'right', hasScrollingSection),
            props.overlays));
    }
    // We use only total minWidth here, grow is not needed (rows are placed in block or vertical flex contexts)
    const minWidth = getSectionStyle(props.columns, 1).minWidth;
    const rawProps = Object.assign(Object.assign({}, restRawProps), { style: Object.assign(Object.assign({}, restRawProps === null || restRawProps === void 0 ? void 0 : restRawProps.style), { minWidth }) });
    return props.link ? (React__default.createElement(Anchor, { link: props.link, cx: [
            css$5.container, uuiDataTableRowCssMarkers.uuiTableRowContainer, props.onClick && uuiMarkers.clickable, props.cx,
        ], rawProps: rawProps }, getRowContent())) : (React__default.createElement(FlexRow, { onClick: props.onClick, cx: [
            css$5.container, uuiDataTableRowCssMarkers.uuiTableRowContainer, props.onClick && uuiMarkers.clickable, props.cx,
        ], rawProps: rawProps, ref: ref }, getRowContent()));
});

const uuiDataTableRow = {
    uuiTableRow: 'uui-table-row',
};
function compareProps(props, nextProps) {
    const isDeepEqual = isEqual(props, nextProps);
    // Debug code to find props differences. Please don't remove, and keep commented out
    // //
    // const shallowDiffKeys = [];
    // const compareDeep = (left: any, right: any, prefix = "") => {
    //     if (prefix.length > 1000) {
    //         return; // cyclic references?
    //     } else if (left && right) {
    //         const keys = Object.keys({ ...left, ...right });
    //         keys.forEach(key => {
    //             if (left[key] !== right[key]) {
    //                 shallowDiffKeys.push({ path: prefix + key, left: left[key], right: right[key] });
    //                 compareDeep(left[key], right[key], prefix + key + '.');
    //             }
    //         });
    //     } else {
    //         shallowDiffKeys.push({ path: prefix, left: left, right: right });
    //     }
    // }
    // compareDeep(this.props, nextProps);
    return isDeepEqual;
}
const DataTableRowImpl = /* @__PURE__ */React__default.forwardRef(function DataTableRow(props, ref) {
    const rowLens = Lens.onEditable(props);
    const renderCell = (column, idx, eventHandlers) => {
        const renderCellCallback = column.renderCell || props.renderCell;
        const isFirstColumn = idx === 0;
        const isLastColumn = !props.columns || idx === props.columns.length - 1;
        return renderCellCallback === null || renderCellCallback === void 0 ? void 0 : renderCellCallback({
            key: column.key,
            column,
            rowProps: props,
            index: idx,
            isFirstColumn,
            isLastColumn,
            rowLens,
            eventHandlers,
        });
    };
    const renderRow = (params, clickHandler, overlays) => {
        return (React__default.createElement(DataTableRowContainer, { columns: props.columns, ref: params.ref || ref, renderCell: renderCell, onClick: clickHandler && (() => clickHandler(props)), rawProps: Object.assign(Object.assign(Object.assign(Object.assign({}, props.rawProps), params.eventHandlers), { role: 'row', 'aria-expanded': (props.isFolded === undefined || props.isFolded === null) ? undefined : !props.isFolded }), (props.isSelectable && { 'aria-selected': props.isSelected })), cx: [
                params.classNames,
                props.isSelected && uuiMod.selected,
                params.isDraggable && uuiMarkers.draggable,
                props.isInvalid && uuiMod.invalid,
                uuiDataTableRow.uuiTableRow,
                props.cx,
                props.isFocused && uuiMod.focus,
            ], overlays: overlays, link: props.link }));
    };
    const clickHandler = props.onClick || props.onSelect || props.onFold || props.onCheck;
    if (props.dnd && (props.dnd.srcData || props.dnd.canAcceptDrop)) {
        return React__default.createElement(DndActor, Object.assign({}, props.dnd, { render: (params) => { var _a; return renderRow(params, clickHandler, (_a = props.renderDropMarkers) === null || _a === void 0 ? void 0 : _a.call(props, params)); } }));
    }
    else {
        return renderRow({}, clickHandler);
    }
});
const DataTableRow = /* @__PURE__ */React__default.memo(DataTableRowImpl, compareProps);

var css$4 = {"root":"-kMr8l"};

const uuiDataTableHeaderRow = {
    uuiTableHeaderRow: 'uui-table-header-row',
};
class DataTableHeaderRow extends React__default.Component {
    constructor() {
        super(...arguments);
        this.lens = Lens.onEditableComponent(this);
        this.sortLens = this.lens.prop('sorting');
        this.filterLens = this.lens.prop('filter');
        this.onCellDrop = (params, index) => {
            const columnsConfig = this.props.value.columnsConfig;
            const dstColumnConfig = columnsConfig[params.dstData.key];
            const srcColumnConfig = columnsConfig[params.srcData.key];
            const prevColumnOrder = this.props.columns[index - 1] ? columnsConfig[this.props.columns[index - 1].key].order : null;
            const nextColumnOrder = this.props.columns[index + 1] ? columnsConfig[this.props.columns[index + 1].key].order : null;
            if (params.position === 'left') {
                const newOrder = getOrderBetween(prevColumnOrder, dstColumnConfig.order);
                columnsConfig[params.srcData.key] = Object.assign(Object.assign({}, srcColumnConfig), { order: newOrder });
            }
            else if (params.position === 'right') {
                const newOrder = getOrderBetween(dstColumnConfig.order, nextColumnOrder);
                columnsConfig[params.srcData.key] = Object.assign(Object.assign({}, srcColumnConfig), { order: newOrder });
            }
            this.props.onValueChange(Object.assign(Object.assign({}, this.props.value), { columnsConfig }));
        };
        this.areAllFolded = (state) => {
            var _a;
            const areAllCollapsed = (state === null || state === void 0 ? void 0 : state.foldAll) === undefined || (state === null || state === void 0 ? void 0 : state.foldAll);
            const unfoldedNodes = Object.values((_a = state === null || state === void 0 ? void 0 : state.folded) !== null && _a !== void 0 ? _a : {}).filter((folded) => !folded);
            const areAllNodesFolded = !(state === null || state === void 0 ? void 0 : state.folded) || !unfoldedNodes.length;
            return areAllCollapsed && areAllNodesFolded;
        };
        this.onFoldAll = () => {
            this.props.onValueChange(Object.assign(Object.assign({}, this.props.value), { folded: {}, foldAll: !this.areAllFolded(this.props.value) }));
        };
        this.renderCell = (column, idx) => {
            var _a, _b;
            const { field, direction } = this.sortLens.index(0).default({ field: null, direction: 'asc' }).get();
            const isFirstColumn = idx === 0;
            const isFoldAllEnabled = isFirstColumn && this.props.showFoldAll;
            return this.props.renderCell({
                key: column.key,
                column,
                value: this.props.value,
                onValueChange: this.props.onValueChange,
                selectAll: this.props.selectAll,
                showFoldAll: this.props.showFoldAll,
                onFoldAll: isFoldAllEnabled ? this.onFoldAll : undefined,
                areAllFolded: isFoldAllEnabled ? (_a = this.areAllFolded) === null || _a === void 0 ? void 0 : _a.call(this, this.props.value) : undefined,
                isFirstColumn,
                isLastColumn: idx === this.props.columns.length - 1,
                isFilterActive: (_b = column.isFilterActive) === null || _b === void 0 ? void 0 : _b.call(column, this.filterLens.default({}).get(), column),
                sortDirection: field === column.key ? direction : null,
                allowColumnsReordering: this.props.allowColumnsReordering,
                allowColumnsResizing: this.props.allowColumnsResizing,
                onSort: (dir) => this.props.onValueChange(Object.assign(Object.assign({}, this.props.value), { sorting: dir ? [{ field: column.key, direction: dir }] : undefined })),
                onDrop: (params) => this.onCellDrop(params, idx),
                renderFilter: (dropdownProps) => column.renderFilter(this.filterLens, dropdownProps),
                isDropdown: !!column.renderFilter,
            });
        };
    }
    render() {
        return (React__default.createElement(DataTableRowContainer, { cx: [
                css$4.root, this.props.cx, uuiDataTableHeaderRow.uuiTableHeaderRow,
            ], columns: this.props.columns, renderCell: this.renderCell, rawProps: { role: 'row' }, renderConfigButton: this.props.onConfigButtonClick && this.props.renderConfigButton }));
    }
}

function isColumnAlwaysPinned(column) {
    return Boolean(column === null || column === void 0 ? void 0 : column.isAlwaysVisible);
}
function canAcceptDrop(props, nextColumn, prevColumn) {
    const { dstData } = props;
    if (isColumnAlwaysPinned(dstData.column)) {
        if (dstData.column.fix === 'left' && !isColumnAlwaysPinned(nextColumn)) { // If user try to drop column at the last isAlwaysVisible column. Allow to drop only to the end of the fixed list.
            return { bottom: true };
        }
        if (dstData.column.fix === 'right' && !isColumnAlwaysPinned(prevColumn)) { // If user try to drop column at the first isAlwaysVisible. Allow to drop only to the start of the fixed list
            return { top: true };
        }
        return {}; // Shouldn't drop between 2 isAlwaysVisible columns
    }
    return { top: true, bottom: true };
}
function getNewColumnOrder(props) {
    const { position, targetOrder, targetPrevOrder, targetNextOrder, } = props;
    return position === 'bottom' ? getOrderBetween(targetOrder, targetNextOrder || null) : getOrderBetween(targetPrevOrder || null, targetOrder);
}
function isEmptyCaption(s) {
    if (typeof s === 'string') {
        return isEmptyString(s);
    }
    return !s;
}
function isEmptyString(s) {
    return !s || s.trim() === '';
}
function isSubstring(s, sub) {
    if (typeof s === 'string') {
        return s.trim().toLowerCase().includes(sub.trim().toLowerCase());
    }
    return false;
}
function isColumnAlwaysHiddenInTheConfigurationModal(column) {
    const caption = column.caption;
    return isEmptyCaption(caption);
}
function isColumnFilteredOut(column, searchFields, filter) {
    const hasFilter = !isEmptyString(filter);
    const isNotSearchValue = hasFilter && !searchFields.some((searchField) => isSubstring(searchField, filter));
    if (isColumnAlwaysHiddenInTheConfigurationModal(column)) {
        return true;
    }
    return isNotSearchValue;
}
function groupAndFilterSortedColumns(props) {
    const accUnsorted = {
        displayedPinnedLeft: [],
        displayedUnpinned: [],
        hidden: [],
        displayedPinnedRight: [],
    };
    return props.sortedColumns.reduce((acc, cur) => {
        if (!isColumnFilteredOut(cur, props.getSearchFields(cur), props.searchValue)) {
            acc[cur.groupKey].push(cur);
        }
        return acc;
    }, accUnsorted);
}
function findFirstByGroupKey(arr, groupKey) {
    const { found: column, prev, next } = findFirstOrLastByCriteria(arr, (i) => i.groupKey === groupKey, true);
    return { column, prev, next };
}
function findLastByGroupKey(arr, groupKey) {
    const { found: column, prev, next } = findFirstOrLastByCriteria(arr, (i) => i.groupKey === groupKey, false);
    return { column, prev, next };
}
function sortColumnsAndAddGroupKey(props) {
    const { prevConfig, columns } = props;
    const sorted = orderBy(columns, (i) => prevConfig[i.key].order);
    return sorted.map((c) => {
        const groupKey = getGroupKey(prevConfig[c.key]);
        return Object.assign(Object.assign({}, c), { groupKey });
    });
}
function getGroupKey(columnConfig) {
    const { isVisible, fix } = columnConfig;
    if (isVisible) {
        if (fix === 'left') {
            return 'displayedPinnedLeft';
        }
        if (fix === 'right') {
            return 'displayedPinnedRight';
        }
        return 'displayedUnpinned';
    }
    return 'hidden';
}
function findFirstOrLastByCriteria(arr, criteria, isFirst) {
    let found;
    let resultIndex;
    for (let j = 0; j < arr.length; j++) {
        const item = arr[j];
        if (criteria(item)) {
            found = item;
            resultIndex = j;
            if (isFirst) {
                break;
            }
        }
    }
    if (found) {
        const prev = arr[resultIndex - 1];
        const next = arr[resultIndex + 1];
        return { found, prev, next };
    }
    return {};
}

function toggleAllColumnsVisibility(props) {
    const { prevConfig, columns, value } = props;
    return Object.keys(prevConfig).reduce((acc, key) => {
        const prevCfg = prevConfig[key];
        const c = columns.find((column) => column.key === key);
        const isAlreadyToggled = value ? prevCfg.isVisible : !prevCfg.isVisible;
        const tryingToHideAlwaysVisible = !value && c.isAlwaysVisible;
        const noChangeRequired = isAlreadyToggled || tryingToHideAlwaysVisible || isEmptyCaption(c.caption);
        if (noChangeRequired) {
            acc[key] = prevCfg;
        }
        else {
            const prevCfgNoFix = __rest(prevCfg, ["fix"]);
            acc[key] = Object.assign(Object.assign({}, prevCfgNoFix), { isVisible: value });
        }
        return acc;
    }, {});
}
function moveColumnRelativeToAnotherColumn(props) {
    const { columnConfig, position, targetColumn, targetPrevColumn, targetNextColumn, } = props;
    const targetOrder = targetColumn === null || targetColumn === void 0 ? void 0 : targetColumn.order;
    const targetNextOrder = targetNextColumn === null || targetNextColumn === void 0 ? void 0 : targetNextColumn.order;
    const targetPrevOrder = targetPrevColumn === null || targetPrevColumn === void 0 ? void 0 : targetPrevColumn.order;
    const order = getNewColumnOrder({
        targetOrder, targetNextOrder, targetPrevOrder, position,
    });
    return Object.assign(Object.assign({}, columnConfig), { order, isVisible: targetColumn.isVisible, fix: targetColumn.fix });
}
function toggleSingleColumnPin(props) {
    var _a, _b, _c, _d, _e, _f;
    const { prevConfig, columnKey, columnsSorted, fix } = props;
    const prevColumn = prevConfig[columnKey];
    if (fix === prevColumn.fix) {
        return prevConfig;
    }
    let order = prevConfig[columnKey].order;
    const isPinOrUnpinLeft = fix === 'left' || (!fix && prevColumn.fix === 'left');
    const isPinOrUnpinRight = fix === 'right' || (!fix && prevColumn.fix === 'right');
    if (isPinOrUnpinLeft) {
        /**
         * on pin LEFT or unpin from LEFT: move before first item of unpinned list
         */
        const { column, prev, next } = findFirstByGroupKey(columnsSorted, 'displayedUnpinned');
        if (column) {
            const targetOrder = (_a = prevConfig[column.key]) === null || _a === void 0 ? void 0 : _a.order;
            const targetPrevOrder = (_b = prevConfig[prev === null || prev === void 0 ? void 0 : prev.key]) === null || _b === void 0 ? void 0 : _b.order;
            const targetNextOrder = (_c = prevConfig[next === null || next === void 0 ? void 0 : next.key]) === null || _c === void 0 ? void 0 : _c.order;
            order = getNewColumnOrder({
                targetOrder, targetPrevOrder, targetNextOrder, position: 'top',
            });
        }
    }
    else if (isPinOrUnpinRight) {
        /**
         * on pin RIGHT or unpin from RIGHT: move after last item of unpinned list
         */
        const { column, prev, next } = findLastByGroupKey(columnsSorted, 'displayedUnpinned');
        if (column) {
            const targetOrder = (_d = prevConfig[column.key]) === null || _d === void 0 ? void 0 : _d.order;
            const targetPrevOrder = (_e = prevConfig[prev === null || prev === void 0 ? void 0 : prev.key]) === null || _e === void 0 ? void 0 : _e.order;
            const targetNextOrder = (_f = prevConfig[next === null || next === void 0 ? void 0 : next.key]) === null || _f === void 0 ? void 0 : _f.order;
            order = getNewColumnOrder({
                targetOrder, targetPrevOrder, targetNextOrder, position: 'bottom',
            });
        }
    }
    else {
        // If 'fix' is not changed, prev config is returned
        return prevConfig;
    }
    return Object.assign(Object.assign({}, prevConfig), { [columnKey]: Object.assign(Object.assign({}, prevColumn), { order,
            fix, isVisible: true }) });
}
function toggleSingleColumnVisibility(props) {
    var _a, _b, _c, _d, _e, _f;
    const { columnsSorted, columnKey, prevConfig } = props;
    const prevIsVisible = prevConfig[columnKey].isVisible;
    let order = prevConfig[columnKey].order;
    if (prevIsVisible) {
        // move to "hidden" group and put it before first item
        const { column, prev, next } = findFirstByGroupKey(columnsSorted, 'hidden');
        if (column) {
            const targetOrder = (_a = prevConfig[column.key]) === null || _a === void 0 ? void 0 : _a.order;
            const targetPrevOrder = (_b = prevConfig[prev === null || prev === void 0 ? void 0 : prev.key]) === null || _b === void 0 ? void 0 : _b.order;
            const targetNextOrder = (_c = prevConfig[next === null || next === void 0 ? void 0 : next.key]) === null || _c === void 0 ? void 0 : _c.order;
            order = getNewColumnOrder({
                targetOrder, targetPrevOrder, targetNextOrder, position: 'top',
            });
        }
    }
    else {
        // going to move to "displayedUnpinned" group and put it after last item
        const { column, prev, next } = findLastByGroupKey(columnsSorted, 'displayedUnpinned');
        if (column) {
            const targetOrder = (_d = prevConfig[column.key]) === null || _d === void 0 ? void 0 : _d.order;
            const targetPrevOrder = (_e = prevConfig[prev === null || prev === void 0 ? void 0 : prev.key]) === null || _e === void 0 ? void 0 : _e.order;
            const targetNextOrder = (_f = prevConfig[next === null || next === void 0 ? void 0 : next.key]) === null || _f === void 0 ? void 0 : _f.order;
            order = getNewColumnOrder({
                targetOrder, targetPrevOrder, targetNextOrder, position: 'bottom',
            });
        }
    }
    const _g = prevConfig[columnKey], restProps = __rest(_g, ["fix", "isVisible"]);
    return Object.assign(Object.assign({}, prevConfig), { [columnKey]: Object.assign(Object.assign({}, restProps), { isVisible: !prevIsVisible, order }) });
}

function useColumnsConfiguration(props) {
    const { initialColumnsConfig, defaultConfig, columns } = props;
    const [searchValue, setSearchValue] = useState();
    const isDndAllowed = !searchValue;
    const [columnsConfig, setColumnsConfig] = useState(() => initialColumnsConfig || defaultConfig);
    const columnsSorted = useMemo(() => sortColumnsAndAddGroupKey({ columns, prevConfig: columnsConfig }), [columns, columnsConfig]);
    const toggleVisibility = useCallback((columnKey) => setColumnsConfig((prevConfig) => toggleSingleColumnVisibility({ prevConfig, columnsSorted, columnKey })), [columnsSorted]);
    const togglePin = useCallback((columnKey, fix) => setColumnsConfig((prevConfig) => toggleSingleColumnPin({ prevConfig, columnsSorted, columnKey, fix })), [columnsSorted]);
    const reset = useCallback(() => {
        setColumnsConfig(defaultConfig);
        setSearchValue('');
    }, [defaultConfig]);
    const checkAll = useCallback(() => setColumnsConfig((prevConfig) => toggleAllColumnsVisibility({ prevConfig, columns: columnsSorted, value: true })), [columnsSorted]);
    const uncheckAll = useCallback(() => setColumnsConfig((prevConfig) => toggleAllColumnsVisibility({ prevConfig, columns: columnsSorted, value: false })), [columnsSorted]);
    const sortedColumnsExtended = useMemo(() => columnsSorted.map((column, index) => {
        const columnConfig = columnsConfig[column.key];
        const nextColumn = columnsSorted[index + 1];
        const prevColumn = columnsSorted[index - 1];
        const prevColumnConfig = columnsConfig[prevColumn === null || prevColumn === void 0 ? void 0 : prevColumn.key];
        const nextColumnConfig = columnsConfig[nextColumn === null || nextColumn === void 0 ? void 0 : nextColumn.key];
        const handleDrop = (params) => {
            const { srcData, position } = params;
            // NOTE: srcData - is the column which we are dropping.
            setColumnsConfig((prevConfig) => {
                const columnNew = moveColumnRelativeToAnotherColumn({
                    columnConfig: srcData.columnConfig,
                    targetColumn: columnConfig,
                    targetNextColumn: nextColumnConfig,
                    targetPrevColumn: prevColumnConfig,
                    position,
                });
                return Object.assign(Object.assign({}, prevConfig), { [srcData.column.key]: columnNew });
            });
        };
        const isPinnedAlways = isColumnAlwaysPinned(column);
        const fix = columnConfig.fix || (isPinnedAlways ? 'left' : undefined);
        return Object.assign(Object.assign({}, column), { columnConfig, isDndAllowed: isDndAllowed && !isPinnedAlways, isPinnedAlways,
            fix, togglePin: (_fix) => togglePin(column.key, _fix), toggleVisibility: () => toggleVisibility(column.key), onCanAcceptDrop: (props) => canAcceptDrop(props, nextColumn, prevColumn), onDrop: handleDrop });
    }), [
        columnsSorted, columnsConfig, isDndAllowed, togglePin, toggleVisibility,
    ]);
    const groupedColumns = useMemo(() => groupAndFilterSortedColumns({
        sortedColumns: sortedColumnsExtended,
        searchValue,
        getSearchFields: (column) => props.getSearchFields ? props.getSearchFields(column) : [column.caption],
    }), [sortedColumnsExtended, searchValue, props.getSearchFields]);
    const hasAnySelectedColumns = useMemo(() => !!columnsSorted.filter((c) => {
        if (c.groupKey !== 'hidden') {
            return !isColumnAlwaysHiddenInTheConfigurationModal(c);
        }
        return false;
    }).length, [columnsSorted]);
    return {
        // props
        groupedColumns,
        searchValue,
        columnsConfig,
        hasAnySelectedColumns,
        // methods
        reset,
        checkAll,
        uncheckAll,
        setSearchValue,
    };
}

class DataTableHeaderCell extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isResizing: false,
        };
        this.cellRef = React.createRef();
        this.toggleSort = (e) => {
            if (isEventTargetInsideClickable(e) || !this.props.column.isSortable)
                return;
            let dir;
            if (!this.props.sortDirection)
                dir = 'asc';
            else if (this.props.sortDirection === 'asc')
                dir = 'desc';
            else if (this.props.sortDirection === 'desc')
                dir = undefined;
            this.props.onSort(dir);
        };
        this.onResizeStart = (e) => {
            this.setState({ isResizing: true, resizeStartX: e.clientX, originalWidth: this.props.column.width });
            document.addEventListener('mousemove', this.onResize);
            document.addEventListener('click', this.onResizeEnd);
            e.preventDefault();
            e.stopPropagation(); // to prevent column sorting/dnd/ect. handlers while resizing
        };
        this.onResizeEnd = (e) => {
            this.setState({ isResizing: false });
            document.removeEventListener('mousemove', this.onResize);
            document.removeEventListener('click', this.onResizeEnd);
            e.preventDefault();
            e.stopPropagation(); // to prevent column sorting/dnd/ect. handlers while resizing
        };
        this.onResize = (e) => {
            if (this.state.isResizing) {
                const columnsConfig = Object.assign({}, (this.props.value.columnsConfig || {}));
                // How much mouse was moved after resize is started
                let widthDelta = e.clientX - this.state.resizeStartX;
                // Right-pinned columns have resize handle at the left, instead of right.
                // So moving left should increase column width, instead of decreasing as usual, and vice versa.
                widthDelta = this.props.column.fix === 'right' ? -widthDelta : widthDelta;
                const newWidth = this.state.originalWidth + widthDelta;
                const defaultMinWidth = this.props.isFirstColumn ? 78 : 54;
                if (newWidth >= (this.props.column.minWidth || defaultMinWidth)) {
                    columnsConfig[this.props.column.key] = Object.assign(Object.assign({}, columnsConfig[this.props.column.key]), { width: newWidth });
                    this.props.onValueChange(Object.assign(Object.assign({}, this.props.value), { columnsConfig }));
                }
                e.preventDefault();
            }
        };
        this.renderCellContent = (dndProps) => {
            return this.props.renderCellContent(Object.assign(Object.assign({ onResize: this.onResize, onResizeEnd: this.onResizeEnd, onResizeStart: this.onResizeStart, toggleSort: this.toggleSort, isResizing: this.state.isResizing }, dndProps), { ref: (node) => {
                    this.cellRef.current = node;
                    if (!(dndProps === null || dndProps === void 0 ? void 0 : dndProps.ref))
                        return;
                    dndProps.ref.current = node;
                } }));
        };
    }
    canAcceptDrop(params) {
        if (!params.dstData.fix) {
            return {
                left: true,
                right: true,
            };
        }
    }
    render() {
        var _a, _b;
        if (this.props.allowColumnsReordering) {
            return (React.createElement(DndActor, { key: this.props.column.key + (((_b = (_a = this.props.value.columnsConfig) === null || _a === void 0 ? void 0 : _a[this.props.column.key]) === null || _b === void 0 ? void 0 : _b.order) || ''), dstData: this.props.column, srcData: this.props.column.fix ? null : this.props.column, canAcceptDrop: this.canAcceptDrop, onDrop: this.props.onDrop, render: this.renderCellContent }));
        }
        else
            return this.renderCellContent();
    }
}

var css$3 = {"cell":"_4pHjsi","content-wrapper":"F-xmoz","editor-wrapper":"LckBM8","contentWrapper":"F-xmoz","editorWrapper":"LckBM8"};

var css$2 = {"root":"s8eU33","copying-marker":"_08-HWi","overlay":"AsyAuw","copyingMarker":"_08-HWi"};

const DataTableSelectionContext = /* @__PURE__ */createContext({
    selectionRange: null,
    setSelectionRange: null,
    getCellSelectionInfo: null,
});

const getCell = (rowIndex, columnIndex, rows, columns) => {
    const row = rows[rowIndex];
    const column = columns[columnIndex];
    if (!row || !column) {
        return null;
    }
    return { column, row };
};
const getStartCell = (selectionRange, rows, columns) => {
    if (selectionRange === null) {
        return null;
    }
    const { startRowIndex, startColumnIndex } = selectionRange;
    return getCell(startRowIndex, startColumnIndex, rows, columns);
};
const getNormalizedLimits = (startIndex, endIndex) => (startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex]);
const getCellPosition = (row, column, selectionRange) => {
    const { startColumnIndex, startRowIndex, endColumnIndex, endRowIndex, } = selectionRange || {};
    const [leftColumn, rightColumn] = getNormalizedLimits(startColumnIndex, endColumnIndex);
    const [topRow, bottomRow] = getNormalizedLimits(startRowIndex, endRowIndex);
    const isSelected = column >= leftColumn && column <= rightColumn && row >= topRow && row <= bottomRow;
    const isStartCell = row === startRowIndex && column === startColumnIndex;
    return {
        isLeft: column === leftColumn,
        isRight: column === rightColumn,
        isTop: row === topRow,
        isBottom: row === bottomRow,
        isSelected,
        isStartCell,
    };
};

const useSelectionManager = ({ rows, columns }) => {
    const [selectionRange, setSelectionRange] = useState(null);
    const startCell = useMemo(() => getStartCell(selectionRange, rows, columns), [
        selectionRange === null || selectionRange === void 0 ? void 0 : selectionRange.startColumnIndex,
        selectionRange === null || selectionRange === void 0 ? void 0 : selectionRange.startRowIndex,
        rows, columns,
    ]);
    const canBeSelected = useCallback((rowIndex, columnIndex, { copyFrom, copyTo }) => {
        var _a, _b, _c, _d;
        const cell = getCell(rowIndex, columnIndex, rows, columns);
        if (!startCell && copyTo)
            return false;
        if (copyFrom)
            return !!((_b = (_a = cell.column).canCopy) === null || _b === void 0 ? void 0 : _b.call(_a, cell));
        return !!((_d = (_c = cell.column).canAcceptCopy) === null || _d === void 0 ? void 0 : _d.call(_c, startCell, cell));
    }, [
        startCell, columns, rows,
    ]);
    const shouldSelectCell = useCallback((rowIndex, columnIndex) => {
        if (selectionRange.startRowIndex === rowIndex && selectionRange.startColumnIndex === columnIndex) {
            return canBeSelected(rowIndex, columnIndex, { copyFrom: true });
        }
        return canBeSelected(rowIndex, columnIndex, { copyTo: true });
    }, [canBeSelected, selectionRange]);
    const getSelectedCells = useCallback(() => {
        if (!selectionRange)
            return [];
        const { startRowIndex, startColumnIndex, endRowIndex, endColumnIndex, } = selectionRange;
        const [startRow, endRow] = getNormalizedLimits(startRowIndex, endRowIndex);
        const [startColumn, endColumn] = getNormalizedLimits(startColumnIndex, endColumnIndex);
        const selectedCells = [];
        for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
            for (let columnIndex = startColumn; columnIndex <= endColumn; columnIndex++) {
                if (shouldSelectCell(rowIndex, columnIndex)) {
                    const cell = getCell(rowIndex, columnIndex, rows, columns);
                    selectedCells.push(cell);
                }
            }
        }
        return selectedCells;
    }, [
        selectionRange, columns, shouldSelectCell, rows,
    ]);
    const getCellSelectionInfo = useCallback((rowIndex, columnIndex) => {
        const { isCopying } = selectionRange || {};
        const { isTop, isBottom, isLeft, isRight, isSelected, isStartCell, } = getCellPosition(rowIndex, columnIndex, selectionRange);
        const canCopyFrom = canBeSelected === null || canBeSelected === void 0 ? void 0 : canBeSelected(rowIndex, columnIndex, { copyFrom: true });
        const canAcceptCopy = canBeSelected === null || canBeSelected === void 0 ? void 0 : canBeSelected(rowIndex, columnIndex, { copyTo: true });
        const showBorder = (isBorderPosition, neighborRow, neighborColumn) => {
            if (isStartCell)
                return true;
            if (!isSelected)
                return false;
            if (!isCopying) {
                return isBorderPosition;
            }
            return canAcceptCopy && (isBorderPosition || !(canBeSelected === null || canBeSelected === void 0 ? void 0 : canBeSelected(neighborRow, neighborColumn, { copyTo: true })));
        };
        const showTopBorder = showBorder(isTop, rowIndex - 1, columnIndex);
        const showRightBorder = showBorder(isRight, rowIndex, columnIndex + 1);
        const showBottomBorder = showBorder(isBottom, rowIndex + 1, columnIndex);
        const showLeftBorder = showBorder(isLeft, rowIndex, columnIndex - 1);
        return {
            isSelected,
            canCopyFrom,
            canAcceptCopy,
            isStartCell,
            showTopBorder,
            showRightBorder,
            showBottomBorder,
            showLeftBorder,
        };
    }, [selectionRange, canBeSelected]);
    return {
        selectionRange, setSelectionRange, getSelectedCells, startCell, getCellSelectionInfo,
    };
};

function DataTableSelectionProvider({ onCopy, rows, columns, children, }) {
    const { selectionRange, setSelectionRange, getSelectedCells, startCell, getCellSelectionInfo, } = useSelectionManager({ rows, columns });
    useEffect(() => {
        if (!selectionRange || !onCopy)
            return;
        const handlePointerUp = () => {
            if (!selectionRange)
                return;
            onCopy === null || onCopy === void 0 ? void 0 : onCopy(startCell, getSelectedCells());
            setSelectionRange(null);
        };
        document.addEventListener('pointerup', handlePointerUp);
        return () => document.removeEventListener('pointerup', handlePointerUp);
    }, [
        selectionRange, startCell, getSelectedCells,
    ]);
    if (!onCopy) {
        return React__default.createElement(React__default.Fragment, null, children);
    }
    const value = useMemo(() => ({ selectionRange, setSelectionRange, getCellSelectionInfo }), [selectionRange, getCellSelectionInfo]);
    return React__default.createElement(DataTableSelectionContext.Provider, { value: value }, children);
}

const uuiDataTableCellOverlayMarkers = {
    uuiTableCellOverlay: 'uui-table-cell-overlay',
    uuiTableCellSelectionInProgress: 'uui-table-cell-selection-in-progress',
    uuiTableCellSelected: 'uui-table-cell-selected',
    uuiTableCellSelectedTop: 'uui-table-cell-selected-top',
    uuiTableCellSelectedRight: 'uui-table-cell-selected-right',
    uuiTableCellSelectedBottom: 'uui-table-cell-selected-bottom',
    uuiTableCellSelectedLeft: 'uui-table-cell-selected-left',
    uuiCopyingMarker: 'uui-copying-marker',
    uuiCopyingMarkerHover: 'uui-copying-marker-hover',
};
function DataTableCellOverlay(props) {
    var _a;
    const { columnIndex, rowIndex } = props;
    const { selectionRange, setSelectionRange, getCellSelectionInfo } = useContext(DataTableSelectionContext);
    const { isSelected, showBottomBorder, showLeftBorder, showRightBorder, showTopBorder, canCopyFrom, isStartCell, } = (_a = getCellSelectionInfo === null || getCellSelectionInfo === void 0 ? void 0 : getCellSelectionInfo(rowIndex, columnIndex)) !== null && _a !== void 0 ? _a : {};
    const { isCopying } = selectionRange !== null && selectionRange !== void 0 ? selectionRange : {};
    const handleCopyingMarkerPointerDown = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        blurFocusedElement();
        setSelectionRange({
            startColumnIndex: columnIndex, startRowIndex: rowIndex, endColumnIndex: columnIndex, endRowIndex: rowIndex, isCopying: true,
        });
    }, [
        setSelectionRange, columnIndex, rowIndex,
    ]);
    const handlePointerEnter = useCallback(() => {
        if (!selectionRange)
            return;
        setSelectionRange((prevState) => (Object.assign(Object.assign({}, prevState), { endRowIndex: rowIndex, endColumnIndex: columnIndex })));
    }, [
        selectionRange, rowIndex, columnIndex,
    ]);
    const borderClassNames = isSelected
        && cx(uuiDataTableCellOverlayMarkers.uuiTableCellSelected, showTopBorder && uuiDataTableCellOverlayMarkers.uuiTableCellSelectedTop, showRightBorder && uuiDataTableCellOverlayMarkers.uuiTableCellSelectedRight, showBottomBorder && uuiDataTableCellOverlayMarkers.uuiTableCellSelectedBottom, showLeftBorder && uuiDataTableCellOverlayMarkers.uuiTableCellSelectedLeft);
    const showMarkerHover = !isCopying && canCopyFrom && !props.inFocus;
    const showMarker = (isCopying && isStartCell) || (props.inFocus && canCopyFrom) || showMarkerHover;
    const overlay = (React__default.createElement("div", { onPointerEnter: handlePointerEnter, className: cx(uuiDataTableCellOverlayMarkers.uuiTableCellOverlay, selectionRange && uuiDataTableCellOverlayMarkers.uuiTableCellSelectionInProgress, props.cx, css$2.root, css$2.overlay, borderClassNames, props.inFocus && uuiMod.focus, props.isInvalid && uuiMod.invalid, props.isReadonly && uuiMod.readonly) }, showMarker && (React__default.createElement("div", { className: cx(css$2.copyingMarker, showMarkerHover ? uuiDataTableCellOverlayMarkers.uuiCopyingMarkerHover : uuiDataTableCellOverlayMarkers.uuiCopyingMarker), onPointerDown: handleCopyingMarkerPointerDown, onClick: (e) => e.stopPropagation() }))));
    // Wrap to add validation tooltip
    if (props.inFocus) {
        return props.renderTooltip({
            placement: 'top',
            value: props.isInvalid,
            content: props.validationMessage,
            children: overlay,
        });
    }
    else {
        return overlay;
    }
}

const DataTableFocusContext = /* @__PURE__ */createContext({
    dataTableFocusManager: null,
});

function DataTableFocusProvider({ dataTableFocusManager, children }) {
    const value = useMemo(() => ({ dataTableFocusManager }), [dataTableFocusManager]);
    if (!value.dataTableFocusManager) {
        // eslint-disable-next-line react/jsx-no-useless-fragment
        return (React__default.createElement(React__default.Fragment, null, children));
    }
    return (React__default.createElement(DataTableFocusContext.Provider, { value: value }, children));
}

class DataTableFocusManager {
    constructor() {
        this.rowsRegistry = null;
        this.rowsIndexToIds = null;
        this.getKeyById = (id) => {
            if (id != null && typeof id === 'object') {
                return JSON.stringify(id);
            }
            return id;
        };
        this.isFocusableRow = (id) => {
            const rowKey = this.getKeyById(id);
            const row = this.rowsRegistry.get(rowKey);
            return row.some((cell) => this.isFocusableCell(cell));
        };
        this.isFocusableCell = (cellProps) => cellProps && !cellProps.isDisabled && !cellProps.isReadonly;
        this.rowsRegistry = new Map();
        this.rowsIndexToIds = new Map();
    }
    focusRow(id) {
        const rowKey = this.getKeyById(id);
        if (!this.rowsRegistry.has(rowKey)) {
            this.setPendingFocusRow(id);
            return;
        }
        const row = this.rowsRegistry.get(rowKey);
        if (this.focusedCell !== undefined && this.isFocusableCell(row[this.focusedCell])) {
            const cell = row[this.focusedCell];
            cell.focus();
            this.setNewFocusCoordinates(id, cell.index);
            this.unsetPendingFocusRow();
            return;
        }
        this.focusNextFocusableCell(id);
    }
    focusNextFocusableCell(id) {
        const rowKey = this.getKeyById(id);
        const row = this.rowsRegistry.get(rowKey);
        const firstFocusableCell = row.find((cell) => this.isFocusableCell(cell));
        if (firstFocusableCell) {
            firstFocusableCell.focus();
            this.setNewFocusCoordinates(id, firstFocusableCell.index);
            this.unsetPendingFocusRow();
        }
    }
    setNewFocusCoordinates(focusedRow, focusedCell) {
        this.focusedRow = focusedRow;
        this.focusedCell = focusedCell;
    }
    focusNextRow() {
        const currentFocusedRowIndex = this.currentFocusedRowIndex();
        if (currentFocusedRowIndex === undefined || currentFocusedRowIndex === -1) {
            this.moveToNextFocusableRow(0);
            return;
        }
        const nextRowIndex = currentFocusedRowIndex + 1;
        this.moveToNextFocusableRow(nextRowIndex);
    }
    focusPrevRow() {
        const currentFocusedRowIndex = this.currentFocusedRowIndex();
        if (this.focusedRow === undefined || currentFocusedRowIndex === -1) {
            this.moveToPrevFocusableRow(0);
            return;
        }
        const prevRowIndex = currentFocusedRowIndex - 1;
        this.moveToPrevFocusableRow(prevRowIndex);
    }
    moveToNextFocusableRow(startingFromIndex) {
        if (this.hasRowWithIndex(startingFromIndex) && this.isFocusableRow(this.getRowIdByIndex(startingFromIndex))) {
            this.focusRow(this.getRowIdByIndex(startingFromIndex));
            return;
        }
        const indexes = [...this.rowsIndexToIds.keys()];
        const nextIndexes = indexes.slice(startingFromIndex, indexes.length);
        const focused = this.focusToNextFocusableRow(nextIndexes);
        if (!focused) {
            const prevIndexes = indexes.slice(0, startingFromIndex);
            this.focusToNextFocusableRow(prevIndexes);
        }
    }
    moveToPrevFocusableRow(startingFromIndex) {
        if (this.hasRowWithIndex(startingFromIndex) && this.isFocusableRow(this.getRowIdByIndex(startingFromIndex))) {
            this.focusRow(this.getRowIdByIndex(startingFromIndex));
            return;
        }
        const indexes = [...this.rowsIndexToIds.keys()];
        const fromIndex = startingFromIndex === -1 ? undefined : startingFromIndex;
        const prevIndexes = indexes.slice(0, fromIndex).reverse();
        const focused = this.focusToNextFocusableRow(prevIndexes);
        if (!focused) {
            const nextIndexes = indexes.slice(startingFromIndex, indexes.length).reverse();
            this.focusToNextFocusableRow(nextIndexes);
        }
    }
    registerCell(rowInfo, cellProps) {
        const rowKey = this.getKeyById(rowInfo.id);
        this.setRowIdByIndex(rowInfo.index, rowInfo.id);
        if (!this.rowsRegistry.has(rowKey)) {
            this.rowsRegistry.set(rowKey, []);
        }
        if (this.lastRowIndex === undefined || this.lastRowIndex < rowInfo.index) {
            this.lastRowIndex = rowInfo.index;
        }
        const row = this.rowsRegistry.get(rowKey);
        row[cellProps.index] = cellProps;
        if (this.pendingRowToBeFocused === rowInfo.id && this.isFocusableCell(cellProps)) {
            this.focusRow(rowInfo.id);
        }
    }
    unregisterCell(id, index) {
        if (index === undefined || id === undefined)
            return;
        const rowKey = this.getKeyById(id);
        const rowIndex = this.findRowIndexById(id);
        if (rowIndex !== -1) {
            this.deleteRowIdByIndex(rowIndex);
        }
        if (!this.rowsRegistry.has(rowKey))
            return;
        const row = this.rowsRegistry.get(rowKey);
        delete row[index];
    }
    focusToNextFocusableRow(indexes) {
        const nextFocusableRowIndex = indexes.find((nextIndex) => this.isFocusableRow(this.getRowIdByIndex(nextIndex)));
        if (nextFocusableRowIndex !== undefined) {
            this.focusRow(this.getRowIdByIndex(nextFocusableRowIndex));
            return true;
        }
        return false;
    }
    setPendingFocusRow(id) {
        this.pendingRowToBeFocused = id;
    }
    unsetPendingFocusRow() {
        this.pendingRowToBeFocused = null;
    }
    findRowIndexById(id) {
        for (const [index, rowId] of this.rowsIndexToIds.entries()) {
            if (this.getKeyById(rowId) === this.getKeyById(id)) {
                return index;
            }
        }
        return -1;
    }
    hasRowWithIndex(index) {
        return this.rowsIndexToIds.has(index);
    }
    getRowIdByIndex(index) {
        return this.rowsIndexToIds.get(index);
    }
    setRowIdByIndex(index, id) {
        return this.rowsIndexToIds.set(index, id);
    }
    deleteRowIdByIndex(index) {
        return this.rowsIndexToIds.delete(index);
    }
    currentFocusedRowIndex() {
        return this.focusedRow !== undefined
            ? this.findRowIndexById(this.focusedRow)
            : undefined;
    }
}

class ShortcutsManager {
    registerShortcut(isMatchingShortcut, action) {
        const keydownHandler = (event) => {
            if (!isMatchingShortcut(event))
                return;
            action(event);
        };
        document.addEventListener('keydown', keydownHandler);
        return () => document.removeEventListener('keydown', keydownHandler);
    }
    registerShortcuts(shortcuts) {
        const unsubs = shortcuts.map(({ isMatchingShortcut, action }) => this.registerShortcut(isMatchingShortcut, action));
        return () => unsubs.forEach((removeShortcut) => removeShortcut());
    }
}

function useShortcuts({ enableShortcuts = true, shortcuts }, deps) {
    const shortcutsManager = useMemo(() => {
        if (!enableShortcuts)
            return null;
        return new ShortcutsManager();
    }, [...deps, enableShortcuts]);
    useEffect(() => {
        const removeShortcuts = shortcutsManager === null || shortcutsManager === void 0 ? void 0 : shortcutsManager.registerShortcuts(shortcuts);
        return () => removeShortcuts();
    }, [shortcutsManager]);
}

const isFocusNextRowShortcut = (event) => event.altKey && event.key === 'ArrowDown';
const isFocusPrevRowShortcut = (event) => event.altKey && event.key === 'ArrowUp';
function useMovementShortcuts({ enableMovementShortcuts = true, dataTableFocusManager, }) {
    const focusNextRow = useCallback((e) => {
        e.preventDefault();
        dataTableFocusManager === null || dataTableFocusManager === void 0 ? void 0 : dataTableFocusManager.focusNextRow();
    }, [dataTableFocusManager]);
    const focusPreviousRow = useCallback((e) => {
        e.preventDefault();
        dataTableFocusManager === null || dataTableFocusManager === void 0 ? void 0 : dataTableFocusManager.focusPrevRow();
    }, [dataTableFocusManager]);
    useShortcuts({
        enableShortcuts: enableMovementShortcuts,
        shortcuts: [
            { isMatchingShortcut: isFocusNextRowShortcut, action: focusNextRow },
            { isMatchingShortcut: isFocusPrevRowShortcut, action: focusPreviousRow },
        ],
    }, [dataTableFocusManager]);
}

function useDataTableFocusManager({ enableMovementShortcuts = true } = {}, deps) {
    const focusManager = useMemo(() => new DataTableFocusManager(), [...deps, enableMovementShortcuts]);
    useMovementShortcuts({
        enableMovementShortcuts,
        dataTableFocusManager: focusManager,
    });
    return focusManager;
}

var css$1 = {"cell":"jp-UHp"};

const DataTableCellContainer = /* @__PURE__ */React.forwardRef((props, ref) => {
    return (React.createElement(FlexCell, Object.assign({}, props.column, { minWidth: props.column.width, rawProps: props.rawProps, cx: ['uui-dt-vars', css$1.cell, props.column.cx, props.cx], onClick: props.onClick, textAlign: props.textAlign, alignSelf: props.alignSelf, shrink: props.shrink, ref: ref, style: props.style }), props.children));
});

const uuiDataTableCellMarkers = {
    uuiTableCell: 'uui-table-cell',
};
function DataTableCell(props) {
    var _a, _b, _c, _d, _e, _f, _g;
    const [state, setState] = React__default.useState({ inFocus: false });
    const row = props.rowProps;
    const ref = React__default.useRef();
    const editorRef = React__default.useRef();
    const isEditable = !!props.onValueChange;
    const isReadonly = (_a = props.isReadonly) !== null && _a !== void 0 ? _a : props.rowProps.isReadonly;
    const tableFocusContext = useContext(DataTableFocusContext);
    useEffect(() => {
        var _a;
        if (isEditable) {
            (_a = tableFocusContext === null || tableFocusContext === void 0 ? void 0 : tableFocusContext.dataTableFocusManager) === null || _a === void 0 ? void 0 : _a.registerCell({ id: row.id, index: row.index }, {
                index: props.index,
                isDisabled: props.isDisabled,
                isReadonly: props.isReadonly,
                key: props.key,
                focus: () => { var _a; return (_a = editorRef.current) === null || _a === void 0 ? void 0 : _a.focus(); },
            });
        }
        return () => {
            var _a;
            if (isEditable) {
                (_a = tableFocusContext === null || tableFocusContext === void 0 ? void 0 : tableFocusContext.dataTableFocusManager) === null || _a === void 0 ? void 0 : _a.unregisterCell(row.id, props.index);
            }
        };
    }, [
        tableFocusContext === null || tableFocusContext === void 0 ? void 0 : tableFocusContext.dataTableFocusManager,
        row.index,
        props.index,
        props.isDisabled,
        props.isReadonly,
        isEditable,
    ]);
    let content;
    const handleEditableCellClick = React__default.useCallback((e) => {
        var _a;
        if (!props.isReadonly && !props.isDisabled
            && (editorRef.current === e.target || editorRef.current.parentNode === e.target)) {
            (_a = editorRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, []);
    if (props.rowProps.isLoading) {
        content = props.renderPlaceholder(props);
    }
    else if (props.rowProps.isUnknown) {
        content = props.renderUnknown(props);
    }
    else if (isEditable) {
        const onFocus = () => {
            var _a, _b, _c;
            if (isReadonly)
                return;
            (_b = (_a = props.rowProps).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a, props.rowProps);
            setState((currentState) => (Object.assign(Object.assign({}, currentState), { inFocus: true })));
            (_c = tableFocusContext === null || tableFocusContext === void 0 ? void 0 : tableFocusContext.dataTableFocusManager) === null || _c === void 0 ? void 0 : _c.setNewFocusCoordinates(row.id, props.index);
        };
        // Copy all attributes explicitly, to avoid bypassing unnecessary DataTableCell props
        // We don't use any helpers and/or deconstruction syntax, as this is performance-sensitive part of code
        const editorProps = {
            value: props.value,
            onValueChange: props.onValueChange,
            isDisabled: (_b = props.isDisabled) !== null && _b !== void 0 ? _b : props.rowProps.isDisabled,
            isInvalid: (_c = props.isInvalid) !== null && _c !== void 0 ? _c : props.rowProps.isInvalid,
            isReadonly: isReadonly,
            isRequired: (_d = props.isRequired) !== null && _d !== void 0 ? _d : props.rowProps.isRequired,
            validationMessage: (_e = props.validationMessage) !== null && _e !== void 0 ? _e : props.rowProps.validationMessage,
            onFocus,
            onBlur: () => setState(Object.assign(Object.assign({}, state), { inFocus: false })),
            rowProps: props.rowProps,
            mode: 'cell',
            ref: editorRef,
        };
        content = (React__default.createElement("div", { className: css$3.editorWrapper, onClick: handleEditableCellClick },
            props.renderEditor(editorProps),
            React__default.createElement(DataTableCellOverlay, { renderTooltip: props.renderTooltip, inFocus: state.inFocus, rowIndex: row.index, columnIndex: props.index, isInvalid: (_f = props.isInvalid) !== null && _f !== void 0 ? _f : props.rowProps.isInvalid, isReadonly: isReadonly, validationMessage: (_g = props.validationMessage) !== null && _g !== void 0 ? _g : props.rowProps.validationMessage })));
    }
    else {
        content = props.column.render(props.rowProps.value, props.rowProps);
    }
    let justifyContent = props.column.justifyContent;
    if (!justifyContent && props.column.textAlign) {
        justifyContent = props.column.textAlign;
    }
    const { textAlign, alignSelf } = props.column;
    const styles = {
        textAlign,
        alignSelf: alignSelf !== null && alignSelf !== void 0 ? alignSelf : (isEditable ? 'stretch' : undefined),
        justifyContent,
    };
    const getWrappedContent = () => (React__default.createElement("div", { style: styles, className: css$3.contentWrapper }, content));
    return (React__default.createElement(DataTableCellContainer, { ref: ref, column: props.column, textAlign: props.isFirstColumn ? undefined : props.column.textAlign, alignSelf: props.isFirstColumn ? undefined : props.column.alignSelf, rawProps: { role: 'cell' }, cx: [
            uuiDataTableCellMarkers.uuiTableCell, css$3.cell, props.cx, props.isInvalid && uuiMod.invalid, state.inFocus && uuiMod.focus,
        ], style: !props.isFirstColumn && { justifyContent: justifyContent } },
        props.addons,
        props.isFirstColumn ? getWrappedContent() : content));
}

class ArrayBindingHelper {
    constructor() {
        this.emptyValueArray = [];
    }
    dataSourceStateToValue(dsState, props, dataSource) {
        if (dsState && Array.isArray(dsState.checked) && dsState.checked && dsState.checked.length > 0) {
            if (props.valueType === 'entity') {
                return dsState.checked.map((id) => dataSource && dataSource.getById(id));
            }
            return dsState.checked;
        }
        else {
            return props.emptyValue;
        }
    }
    applyValueToDataSourceState(dsState, value, props, dataSource) {
        let checked = (Array.isArray(value) && value) || this.emptyValueArray;
        if (props.valueType === 'entity') {
            checked = value === null || value === void 0 ? void 0 : value.map((entity) => {
                dataSource && dataSource.setItem(entity);
                return dataSource && dataSource.getId(entity);
            });
        }
        return Object.assign(Object.assign({}, dsState), { checked: checked, filter: props.filter || dsState.filter, sorting: props.sorting ? [props.sorting] : dsState.sorting });
    }
}
class ScalarBindingHelper {
    dataSourceStateToValue(dsState, props, dataSource) {
        if (dsState.selectedId != null && props.valueType === 'entity') {
            return dataSource && dataSource.getById(dsState.selectedId);
        }
        return dsState.selectedId;
    }
    applyValueToDataSourceState(dsState, value, props, dataSource) {
        let selectedId = value;
        if (value && props.valueType === 'entity' && dataSource) {
            dataSource.setItem(value);
            selectedId = dataSource.getId(value);
        }
        return Object.assign(Object.assign({}, dsState), { selectedId: selectedId, filter: props.filter || dsState.filter, sorting: props.sorting ? [props.sorting] : dsState.sorting });
    }
}
const lookup = {
    multi: new ArrayBindingHelper(),
    single: new ScalarBindingHelper(),
};
function dataSourceStateToValue(props, dsState, dataSource) {
    return lookup[props.selectionMode].dataSourceStateToValue(dsState, props, dataSource);
}
function applyValueToDataSourceState(props, dsState, value, dataSource) {
    return lookup[props.selectionMode].applyValueToDataSourceState(dsState, value, props, dataSource);
}

class PickerBodyBase extends React.Component {
    constructor() {
        super(...arguments);
        this.needFocusSearch = this.showSearch();
        this.searchRef = React.createRef();
        this.searchKeyDown = (e) => {
            var _a, _b;
            (_b = (_a = this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            if (e.shiftKey && e.key === 'Tab')
                e.preventDefault();
        };
    }
    componentDidUpdate(prevProps) {
        var _a, _b, _c;
        // Focusing of searchInput is done via ref.focus(), but not via autoFocus on SearchInput,
        // because otherwise, after body close, focus on PickerToggler is lost and on  press Tab, it is moved to document.body.
        if (this.needFocusSearch && !isMobile()) {
            (_a = this.searchRef.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            this.needFocusSearch = false;
        }
        if (prevProps.rows.length !== this.props.rows.length || (!isEqual(prevProps.value.checked, this.props.value.checked) && !this.props.fixedBodyPosition)) {
            (_c = (_b = this.props).scheduleUpdate) === null || _c === void 0 ? void 0 : _c.call(_b);
        }
    }
    showSearch() {
        return this.props.showSearch === 'auto' ? this.props.totalCount > 10 : Boolean(this.props.showSearch);
    }
}

const handleDataSourceKeyboard = (params, e) => {
    const value = params.value;
    const search = value.search;
    let focusedIndex = value.focusedIndex || 0;
    const maxVisibleIndex = value.topIndex + params.rows.length - 1;
    switch (e.key) {
        case 'Backspace': {
            if (params.searchPosition === 'input' && !value.search && value.checked && value.checked.length > 0) {
                const lastSelectionId = value.checked[value.checked.length - 1];
                const lastSelection = params.listView.getById(lastSelectionId, null);
                lastSelection.onCheck(lastSelection);
            }
            break;
        }
        case 'Enter': {
            if (value.topIndex <= focusedIndex && focusedIndex <= maxVisibleIndex) {
                const focusedRow = params.rows[value.focusedIndex - value.topIndex];
                const clickHandler = focusedRow.onFold || focusedRow.onSelect || focusedRow.onCheck;
                clickHandler && clickHandler(focusedRow);
            }
            break;
        }
        case 'ArrowUp': {
            e.preventDefault();
            if (focusedIndex > maxVisibleIndex) {
                focusedIndex = maxVisibleIndex;
            }
            else if (focusedIndex > 0) {
                focusedIndex--;
            }
            break;
        }
        case 'ArrowDown': {
            e.preventDefault();
            if (focusedIndex < value.topIndex) {
                focusedIndex = value.topIndex;
            }
            else if (focusedIndex < maxVisibleIndex) {
                focusedIndex++;
            }
            break;
        }
        default:
            return;
    }
    if (value.focusedIndex !== focusedIndex || value.search !== search) {
        params.onValueChange(Object.assign(Object.assign({}, value), { focusedIndex, scrollTo: { index: focusedIndex, behavior: 'smooth', align: 'nearest' }, search }));
    }
};

const MAX_ITEMS = 100;
const getMaxItems = (maxItems) => maxItems || maxItems === 0 ? maxItems : MAX_ITEMS;

var css = {"container":"_3tReCd","single-input":"tgS2a-","cursor-text":"DUWb9I","body":"ooXW3F","toggler":"PlAoFu","singleInput":"tgS2a-","cursorText":"DUWb9I"};

function PickerTogglerComponent(props, ref) {
    const [inFocus, setInFocus] = React.useState(false);
    const toggleContainer = React.useRef();
    const inputContainer = React.useRef();
    React.useImperativeHandle(ref, () => toggleContainer.current, [toggleContainer.current]);
    const handleClick = React.useCallback((event) => {
        if (props.isInteractedOutside(event) && inFocus) {
            blur();
        }
    }, [inFocus]);
    React.useEffect(() => {
        var _a;
        // We need to subscribe on any document clicks, when toggler is in focus to be able to make blur on toggler in case of click outside.
        inFocus && window.document.addEventListener('click', handleClick);
        if (props.autoFocus && !props.disableSearch) {
            (_a = inputContainer.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        return () => window.document.removeEventListener('click', handleClick);
    }, [inFocus, handleClick]);
    const isActivePlaceholder = () => {
        if (props.isReadonly)
            return false;
        else if (props.isOpen && props.searchPosition === 'input')
            return false;
        else if (props.minCharsToSearch && inFocus)
            return false;
        else if (props.pickerMode === 'single' && props.selection && props.selection.length > 0)
            return true;
        else
            return false;
    };
    const blur = (e) => {
        var _a, _b;
        setInFocus(false);
        (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
        props.closePickerBody();
        (_b = inputContainer.current) === null || _b === void 0 ? void 0 : _b.blur();
    };
    const handleFocus = (e) => {
        var _a, _b;
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
        setInFocus(true);
        props.searchPosition === 'input' && ((_b = inputContainer.current) === null || _b === void 0 ? void 0 : _b.focus());
    };
    const handleBlur = (e) => {
        var _a;
        if (props.isOpen) {
            // If picker opened and search inside input, we lock focus on toggler.
            // In case, when search inside body, we need to highlight toggler like in focus state, even when focus was moved to the body. So we do nothing in this case.
            if (props.searchPosition === 'input') {
                (_a = inputContainer.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
        }
        else {
            // If picker closed, we perform blur event as usual.
            blur(e);
        }
    };
    const handleCrossIconClick = () => {
        var _a;
        if (props.onClear) {
            props.onClear();
            props.onValueChange('');
        }
        // When we click on the cross it disappears from the DOM and focus is passed to the Body. So in this case we have to return focus on the toggleContainer by hand.
        (_a = toggleContainer.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const renderItems = () => {
        var _a, _b;
        const maxItems = getMaxItems(props.maxItems);
        const isPickerDisabled = props.isDisabled || props.isReadonly;
        let areAllDisabled = isPickerDisabled;
        const displayedRows = props.selectedRowsCount > maxItems ? props.selection.slice(0, maxItems) : props.selection;
        const collapsedRows = (_a = props.selection) === null || _a === void 0 ? void 0 : _a.slice(maxItems);
        const tags = displayedRows === null || displayedRows === void 0 ? void 0 : displayedRows.map((row) => {
            var _a;
            if (!isPickerDisabled && !row.isDisabled) {
                areAllDisabled = false;
            }
            const tagProps = {
                key: row === null || row === void 0 ? void 0 : row.id,
                rowProps: row,
                caption: row.isLoading ? null : props.getName(row.value),
                isCollapsed: false,
                isDisabled: isPickerDisabled || row.isDisabled,
                onClear: () => {
                    var _a, _b;
                    (_a = row.onCheck) === null || _a === void 0 ? void 0 : _a.call(row, row);
                    // When we delete item it disappears from the DOM and focus is passed to the Body. So in this case we have to return focus on the toggleContainer by hand.
                    (_b = toggleContainer.current) === null || _b === void 0 ? void 0 : _b.focus();
                },
            };
            return (_a = props.renderItem) === null || _a === void 0 ? void 0 : _a.call(props, tagProps);
        });
        if (props.selectedRowsCount > maxItems) {
            const collapsedTagProps = (_b = props.renderItem) === null || _b === void 0 ? void 0 : _b.call(props, {
                key: 'collapsed',
                caption: i18n.pickerToggler.createItemValue(props.selectedRowsCount - maxItems, ''),
                isCollapsed: true,
                isDisabled: areAllDisabled,
                onClear: null,
                collapsedRows,
            });
            tags.push(collapsedTagProps);
        }
        return tags;
    };
    const renderInput = () => {
        var _a;
        const isSinglePickerSelected = props.pickerMode === 'single' && props.selection && !!props.selection[0];
        let placeholder;
        if (!isSinglePickerSelected) {
            placeholder = props.placeholder;
        }
        if (isSinglePickerSelected) {
            placeholder = props.selection[0].isLoading ? undefined : props.getName((_a = props.selection[0]) === null || _a === void 0 ? void 0 : _a.value);
        }
        const value = props.disableSearch ? null : props.value;
        if (props.searchPosition !== 'input' && props.pickerMode === 'multi' && props.selectedRowsCount > 0) {
            return null;
        }
        return (React.createElement("input", { id: props === null || props === void 0 ? void 0 : props.id, type: "text", tabIndex: -1, ref: inputContainer, "aria-haspopup": true, autoComplete: "no", "aria-required": props.isRequired, "aria-disabled": props.isDisabled, "aria-readonly": props.isReadonly, className: cx(uuiElement.input, props.pickerMode === 'single' && css.singleInput, props.searchPosition === 'input' && css.cursorText, isActivePlaceholder() && uuiElement.placeholder), disabled: props.isDisabled, placeholder: placeholder, value: value || '', readOnly: props.isReadonly || props.disableSearch, onChange: (e) => { var _a; return (_a = props.onValueChange) === null || _a === void 0 ? void 0 : _a.call(props, e.target.value); }, dir: "auto" }));
    };
    const shouldToggleBody = (e) => {
        const isInteractionDisabled = (props.isDisabled || props.isReadonly || isEventTargetInsideClickable(e));
        const shouldOpenWithMinCharsToSearch = (inFocus && props.value && props.minCharsToSearch);
        const isPickerOpenWithSearchInInput = (props.isOpen && props.searchPosition === 'input' && e.target.tagName === 'INPUT');
        return !(isInteractionDisabled || shouldOpenWithMinCharsToSearch || isPickerOpenWithSearchInInput);
    };
    const togglerPickerOpened = (e) => {
        var _a;
        e.preventDefault();
        if (!shouldToggleBody(e))
            return;
        toggleContainer.current.focus();
        (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props);
    };
    const icon = props.icon && (React.createElement(IconContainer, { icon: props.icon, onClick: props.onIconClick }));
    return (React.createElement("div", Object.assign({ onClick: togglerPickerOpened, ref: toggleContainer, className: cx(css.container, uuiElement.inputBox, props.isDisabled && uuiMod.disabled, props.isReadonly && uuiMod.readonly, props.isInvalid && uuiMod.invalid, !props.isReadonly && !props.isDisabled && props.onClick && uuiMarkers.clickable, !props.isReadonly && !props.isDisabled && inFocus && uuiMod.focus, props.cx), tabIndex: inFocus || props.isReadonly || props.isDisabled ? -1 : 0, onFocus: handleFocus, onBlur: handleBlur, onKeyDown: props.onKeyDown }, props.rawProps),
        React.createElement("div", { className: cx(css.body, !props.isSingleLine && props.pickerMode !== 'single' && 'uui-picker_toggler-multiline') },
            props.iconPosition !== 'right' && icon,
            props.pickerMode !== 'single' && renderItems(),
            renderInput(),
            props.iconPosition === 'right' && icon),
        !props.isDisabled && !props.isReadonly && (React.createElement("div", { className: "uui-picker_toggler-actions" },
            !props.disableClear && (props.value || props.selectedRowsCount > 0) && (React.createElement(IconContainer, { cx: cx('uui-icon-cancel', uuiMarkers.clickable), isDisabled: props.isDisabled, icon: props.cancelIcon, tabIndex: -1, onClick: handleCrossIconClick, rawProps: { role: 'button', 'aria-label': 'Clear' } })),
            props.isDropdown && !(props === null || props === void 0 ? void 0 : props.minCharsToSearch) && React.createElement(IconContainer, { icon: props.dropdownIcon, flipY: props.isOpen, cx: "uui-icon-dropdown" })))));
}
const PickerToggler = /* @__PURE__ */React.forwardRef(PickerTogglerComponent);

class DataPickerRow extends React.Component {
    constructor() {
        super(...arguments);
        this.rowNode = React.createRef();
        this.handleMouseEnter = () => {
            this.props.onFocus && this.props.onFocus(this.props.index);
        };
    }
    componentDidMount() {
        var _a;
        if (this.props.onFocus) {
            (_a = this.rowNode.current) === null || _a === void 0 ? void 0 : _a.addEventListener('mouseenter', this.handleMouseEnter);
        }
    }
    componentWillUnmount() {
        var _a;
        (_a = this.rowNode.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('mouseenter', this.handleMouseEnter);
    }
    render() {
        var _a;
        const clickHandler = this.props.onClick || this.props.onSelect || this.props.onFold || this.props.onCheck;
        return (React.createElement(FlexRow, { onClick: clickHandler && (() => clickHandler(this.props)), rawProps: Object.assign(Object.assign(Object.assign({ role: 'option', 'aria-busy': this.props.isLoading, 'aria-posinset': this.props.index + 1 }, (((_a = this.props.checkbox) === null || _a === void 0 ? void 0 : _a.isVisible) && { 'aria-checked': this.props.isChecked })), (this.props.isSelectable && { 'aria-selected': this.props.isSelected })), this.props.rawProps), ref: this.rowNode, cx: [clickHandler && this.props.isFocused && uuiMod.focus, this.props.cx] }, this.props.renderContent()));
    }
}

function usePicker(props, pickerState) {
    const context = useContext(UuiContext);
    const { showSelected, setShowSelected, dataSourceState, setDataSourceState } = pickerState;
    const prevDataSourceState = usePrevious(dataSourceState);
    const { dataSource, emptyValue, value, onValueChange, getValueChangeAnalyticsEvent, entityName, entityPluralName, selectionMode, getSearchFields, isFoldedByDefault, sortBy, cascadeSelection, showSelectedOnly, } = props;
    const handleSelectionValueChange = useCallback((newValue) => {
        onValueChange(newValue);
        if (getValueChangeAnalyticsEvent) {
            const event = getValueChangeAnalyticsEvent(newValue, value);
            context.uuiAnalytics.sendEvent(event);
        }
    }, [onValueChange, getValueChangeAnalyticsEvent]);
    const handleDataSourceValueChange = useCallback((newDataSourceState) => {
        setDataSourceState((st) => {
            let newDsState;
            if (typeof newDataSourceState === 'function') {
                newDsState = newDataSourceState(st);
            }
            else {
                newDsState = newDataSourceState;
            }
            if ((newDsState.search || st.search) && newDsState.search !== st.search) {
                newDsState.focusedIndex = 0;
            }
            return newDsState;
        });
    }, [setDataSourceState]);
    useLayoutEffect(() => {
        var _a, _b;
        if (showSelected && (!((_a = dataSourceState.checked) === null || _a === void 0 ? void 0 : _a.length) || dataSourceState.search)) {
            setShowSelected(false);
        }
        if ((!prevDataSourceState && (((_b = dataSourceState.checked) === null || _b === void 0 ? void 0 : _b.length) || dataSourceState.selectedId != null))
            || (prevDataSourceState && (!isEqual(prevDataSourceState.checked, dataSourceState.checked)
                || (!(dataSourceState.selectedId == null && prevDataSourceState.selectedId == null)
                    && dataSourceState.selectedId !== prevDataSourceState.selectedId)))) {
            const newValue = dataSourceStateToValue(props, dataSourceState, dataSource);
            if (!isEqual(value, newValue)) {
                handleSelectionValueChange(newValue);
            }
        }
    }, [dataSourceState]);
    const getName = (i) => {
        const unknownStr = 'Unknown';
        if (props.getName) {
            try {
                return props.getName(i);
            }
            catch (e) {
                return unknownStr;
            }
        }
        return i ? i.name : unknownStr;
    };
    const getPluralName = () => {
        if (!entityName)
            return;
        if (entityName.endsWith('s'))
            return entityName.concat('es');
        if (entityName.endsWith('y'))
            return entityName.concat('(s)');
        return entityName.concat('s');
    };
    const getEntityName = (countSelected) => {
        if ((!entityName && !entityPluralName) || (!entityName && countSelected === 1))
            return '';
        if ((countSelected <= 1 && entityName) || selectionMode === 'single')
            return entityName;
        return entityPluralName || getPluralName();
    };
    const isSingleSelect = () => selectionMode === 'single';
    const getSelectedIdsArray = (selected) => {
        if (selected) {
            if (isSingleSelect()) {
                return [selected];
            }
            else {
                return selected;
            }
        }
        return [];
    };
    const getDataSourceState = () => applyValueToDataSourceState(props, dataSourceState, props.value, props.dataSource);
    const getRowOptions = () => {
        if (isSingleSelect()) {
            return { isSelectable: true };
        }
        return { checkbox: { isVisible: true } };
    };
    const clearSelection = () => {
        if (selectionMode === 'single') {
            handleDataSourceValueChange((dsState) => (Object.assign(Object.assign({}, dsState), { selectedId: emptyValue })));
        }
        else {
            view.clearAllChecked();
        }
    };
    const hasSelection = () => {
        if (Array.isArray(value)) {
            return value.length !== 0;
        }
        else {
            return value !== undefined && value !== null;
        }
    };
    const view = dataSource.useView(getDataSourceState(), handleDataSourceValueChange, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ rowOptions: getRowOptions(), getSearchFields: getSearchFields || ((item) => [getName(item)]) }, (isFoldedByDefault ? { isFoldedByDefault } : {})), (sortBy ? { sortBy } : {})), (cascadeSelection ? { cascadeSelection } : {})), (props.getRowOptions ? { getRowOptions: props.getRowOptions } : {})), { backgroundReload: true, showSelectedOnly }), [dataSource]);
    const getListProps = () => {
        const listProps = view.getListProps();
        if (showSelected) {
            const checked = getDataSourceState().checked;
            const checkedCount = checked ? checked.length : 0;
            return Object.assign(Object.assign({}, listProps), { rowsCount: checkedCount, knownRowsCount: checkedCount, exactRowsCount: checkedCount });
        }
        else {
            return listProps;
        }
    };
    const toggleShowOnlySelected = (val) => {
        setShowSelected(val);
    };
    const getFooterProps = () => ({
        view,
        showSelected: {
            value: showSelected,
            onValueChange: toggleShowOnlySelected,
        },
        clearSelection,
        selectionMode,
        selection: dataSourceStateToValue(props, dataSourceState, dataSource),
        search: pickerState.dataSourceState.search,
    });
    const getSelectedRows = (itemsToTake) => {
        var _a;
        const dsState = getDataSourceState();
        let checked = [];
        if (props.selectionMode === 'single') {
            checked = dsState.selectedId !== null && dsState.selectedId !== undefined ? [dsState.selectedId] : [];
        }
        else {
            checked = (_a = dsState.checked) !== null && _a !== void 0 ? _a : [];
        }
        return checked
            .slice(0, itemsToTake)
            .map((id, index) => view.getById(id, index));
    };
    return {
        context,
        dataSourceState,
        getName,
        getPluralName,
        getEntityName,
        isSingleSelect,
        getSelectedIdsArray,
        getSelectedRows,
        getDataSourceState,
        getRowOptions,
        clearSelection,
        hasSelection,
        view,
        getListProps,
        getFooterProps,
        handleDataSourceValueChange,
        handleSelectionValueChange,
    };
}

function usePickerState(props) {
    const [dataSourceState, setDataSourceState] = useState(Object.assign({ focusedIndex: 0, topIndex: 0, visibleCount: 20 }, props.dataSourceState));
    const [showSelected, setShowSelected] = useState(false);
    return {
        dataSourceState,
        setDataSourceState,
        showSelected,
        setShowSelected,
    };
}

function usePickerInputState(props) {
    const pickerState = usePickerState(props);
    const [opened, setOpened] = useState(false);
    const [isSearchChanged, setIsSearchChanged] = useState(false);
    return Object.assign(Object.assign({}, pickerState), { opened,
        setOpened,
        isSearchChanged,
        setIsSearchChanged });
}

const initialRowsVisible = 20; /* estimated, with some reserve to allow start scrolling without fetching more data */
function usePickerInput(props) {
    const popperModifiers = useMemo(() => [
        {
            name: 'offset',
            options: { offset: [0, 6] },
        }, mobilePopperModifier,
    ], []);
    const pickerInputState = usePickerInputState({
        dataSourceState: { visibleCount: initialRowsVisible, checked: [] },
    });
    const { opened, setOpened, isSearchChanged, setIsSearchChanged, setShowSelected, dataSourceState, setDataSourceState, } = pickerInputState;
    const defaultShouldShowBody = () => {
        const searchPosition = props.searchPosition || 'input';
        const isOpened = opened && !props.isDisabled;
        if (props.minCharsToSearch && props.editMode !== 'modal' && searchPosition === 'input') {
            const isEnoughSearchLength = dataSourceState.search
                ? dataSourceState.search.length >= props.minCharsToSearch
                : false;
            return isEnoughSearchLength && isOpened;
        }
        return isOpened;
    };
    const shouldShowBody = () => { var _a; return ((_a = props.shouldShowBody) !== null && _a !== void 0 ? _a : defaultShouldShowBody)(); };
    const showSelectedOnly = !shouldShowBody() || pickerInputState.showSelected;
    const picker = usePicker(Object.assign(Object.assign({}, props), { showSelectedOnly }), pickerInputState);
    const { context, view, handleDataSourceValueChange, getEntityName, clearSelection, getDataSourceState, isSingleSelect, getListProps, getName, handleSelectionValueChange, getSelectedRows, } = picker;
    const lens = useMemo(() => Lens.onEditable({ value: dataSourceState, onValueChange: handleDataSourceValueChange }), [dataSourceState]);
    useEffect(() => {
        const prevValue = dataSourceStateToValue(props, dataSourceState, props.dataSource);
        if (prevValue !== props.value) {
            setDataSourceState((state) => applyValueToDataSourceState(props, state, props.value, props.dataSource));
        }
    }, [props.value]);
    useEffect(() => {
        const prevValue = dataSourceStateToValue(props, dataSourceState, props.dataSource);
        if (props.value === prevValue && props.isDisabled && opened) {
            setOpened(false);
        }
    }, [props.isDisabled, opened, props.value]);
    const toggleDropdownOpening = (newOpened) => {
        if (isMobile()) {
            const modals = context.uuiModals.getOperations();
            document.body.style.overflow = !newOpened && modals.length === 0 ? '' : 'hidden';
        }
        handleDataSourceValueChange(Object.assign(Object.assign({}, dataSourceState), { topIndex: 0, visibleCount: initialRowsVisible, focusedIndex: 0, search: '' }));
        setIsSearchChanged(false);
        setOpened(newOpened);
        setShowSelected(false);
    };
    const toggleBodyOpening = (newOpened) => {
        var _a, _b, _c;
        if (opened === newOpened
            || (props.minCharsToSearch && ((_b = (_a = dataSourceState.search) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) < props.minCharsToSearch)) {
            return;
        }
        if (props.editMode === 'modal') {
            (_c = props.toggleModalOpening) === null || _c === void 0 ? void 0 : _c.call(props, newOpened);
        }
        else {
            toggleDropdownOpening(newOpened);
        }
    };
    const onSelect = (row) => {
        toggleDropdownOpening(false);
        handleDataSourceValueChange((currentState) => (Object.assign(Object.assign({}, currentState), { search: '', selectedId: row.id })));
    };
    const getSearchPosition = () => {
        if (isMobile() && props.searchPosition !== 'none')
            return 'body';
        if (props.editMode === 'modal' && props.searchPosition !== 'none')
            return 'body';
        if (!props.searchPosition) {
            return props.selectionMode === 'multi' ? 'body' : 'input';
        }
        else {
            return props.searchPosition;
        }
    };
    const getPlaceholder = () => { var _a; return (_a = props.placeholder) !== null && _a !== void 0 ? _a : i18n.pickerInput.defaultPlaceholder(getEntityName()); };
    const handleClearSelection = () => {
        toggleDropdownOpening(false);
        clearSelection();
    };
    const handlePickerInputKeyboard = (rows, e, actualSearch) => {
        if (props.isDisabled || props.isReadonly)
            return;
        if (e.key === 'Enter' && !opened) {
            return toggleBodyOpening(true);
        }
        if (e.key === 'Escape' && opened) {
            e.preventDefault();
            toggleDropdownOpening(false);
        }
        const value = getDataSourceState();
        handleDataSourceKeyboard({
            value: actualSearch !== undefined ? Object.assign(Object.assign({}, value), { search: actualSearch }) : value,
            onValueChange: handleDataSourceValueChange,
            listView: view,
            searchPosition: getSearchPosition(),
            rows,
        }, e);
    };
    const getPickerBodyProps = (rows) => {
        var _a;
        return {
            value: getDataSourceState(),
            onValueChange: handleDataSourceValueChange,
            search: lens.prop('search').toProps(),
            showSearch: getSearchPosition() === 'body',
            rawProps: Object.assign({ 'aria-multiselectable': props.selectionMode === 'multi' ? true : null, 'aria-orientation': 'vertical' }, (_a = props.rawProps) === null || _a === void 0 ? void 0 : _a.body),
            renderNotFound: props.renderNotFound
                && (() => props.renderNotFound({
                    search: dataSourceState.search,
                    onClose: () => toggleBodyOpening(false),
                })),
            onKeyDown: (e) => handlePickerInputKeyboard(rows, e),
            fixedBodyPosition: props.fixedBodyPosition,
            searchDebounceDelay: props.searchDebounceDelay,
        };
    };
    const handleTogglerSearchChange = useCallback((value) => {
        let isOpen = !opened && value.length > 0 ? true : opened;
        if (props.minCharsToSearch) {
            isOpen = value.length >= props.minCharsToSearch;
        }
        handleDataSourceValueChange((dsState) => (Object.assign(Object.assign({}, dsState), { focusedIndex: 0, search: value })));
        setOpened(isOpen);
        setIsSearchChanged(true);
    }, [opened, props.minCharsToSearch, dataSourceState, handleDataSourceValueChange, setOpened, setIsSearchChanged]);
    const closePickerBody = useCallback(() => {
        handleDataSourceValueChange((dsState) => (Object.assign(Object.assign({}, dsState), { search: '' })));
        setOpened(false);
        setIsSearchChanged(false);
    }, [handleDataSourceValueChange, setOpened, setIsSearchChanged]);
    const getRows = () => {
        if (!shouldShowBody())
            return [];
        const preparedRows = view.getVisibleRows();
        return preparedRows.map((rowProps) => {
            const newRowProps = Object.assign({}, rowProps);
            if (rowProps.isSelectable && isSingleSelect() && props.editMode !== 'modal') {
                newRowProps.onSelect = onSelect;
            }
            return newRowProps;
        });
    };
    const handleCloseBody = () => {
        toggleBodyOpening(false);
    };
    const openPickerBody = () => toggleBodyOpening(true);
    const getFooterProps = () => {
        const footerProps = picker.getFooterProps();
        return Object.assign(Object.assign({}, footerProps), { onClose: handleCloseBody, selectionMode: props.selectionMode, disableClear: props.disableClear });
    };
    const getSearchValue = () => {
        // only for selectionMode = 'single': we're getting current value and put it into search, and when search changed we turn value to dataSourceState.search
        if (props.selectionMode === 'single' && !isSearchChanged && (props.value !== undefined && props.value !== null)) {
            if (props.valueType === 'id') {
                return getName(props === null || props === void 0 ? void 0 : props.dataSource.getById(props.value));
            }
            if (props.valueType === 'entity') {
                return getName(props.value);
            }
        }
        return dataSourceState.search;
    };
    const selectedRows = useMemo(() => getSelectedRows(view.getSelectedRowsCount()), [view, dataSourceState.checked]);
    const getTogglerProps = () => {
        var _a, _b;
        const selectedRowsCount = view.getSelectedRowsCount();
        const { isDisabled, autoFocus, isInvalid, isReadonly, isSingleLine, maxItems, minCharsToSearch, inputCx, disableClear: propDisableClear, icon, iconPosition, onIconClick, id, } = props;
        const searchPosition = getSearchPosition();
        const forcedDisabledClear = Boolean(searchPosition === 'body' && !selectedRowsCount);
        const disableClear = forcedDisabledClear || propDisableClear;
        let searchValue = getSearchValue();
        if (isSingleSelect() && ((_a = selectedRows[0]) === null || _a === void 0 ? void 0 : _a.isLoading)) {
            searchValue = undefined;
        }
        return {
            isSingleLine,
            maxItems,
            minCharsToSearch,
            isInvalid,
            isReadonly,
            isDisabled,
            autoFocus,
            icon,
            iconPosition,
            onIconClick,
            onFocus: props.onFocus,
            onClear: handleClearSelection,
            onBlur: props.onBlur,
            selection: selectedRows,
            selectedRowsCount,
            placeholder: getPlaceholder(),
            getName: (i) => getName(i),
            entityName: getEntityName(selectedRowsCount),
            pickerMode: isSingleSelect() ? 'single' : 'multi',
            searchPosition,
            disableSearch: searchPosition !== 'input',
            disableClear: disableClear,
            toggleDropdownOpening,
            closePickerBody,
            rawProps: (_b = props.rawProps) === null || _b === void 0 ? void 0 : _b.input,
            value: searchValue,
            cx: inputCx,
            id,
        };
    };
    return {
        view,
        context,
        dataSourceState,
        getPlaceholder,
        getName,
        getRows,
        getTogglerProps,
        getFooterProps,
        shouldShowBody,
        toggleBodyOpening,
        isSingleSelect,
        popperModifiers,
        getPickerBodyProps,
        getListProps,
        handleTogglerSearchChange,
        handleDataSourceValueChange,
        handleSelectionValueChange,
        getSearchPosition,
        closePickerBody,
        openPickerBody,
        handlePickerInputKeyboard,
    };
}

function usePickerListState(props) {
    var _a;
    const pickerState = usePickerState(props);
    const prevProps = useRef(props);
    const [visibleIds, setVisibleIds] = useState((_a = props.visibleIds) !== null && _a !== void 0 ? _a : []);
    useEffect(() => {
        var _a, _b;
        if (((_a = prevProps.current) === null || _a === void 0 ? void 0 : _a.dataSourceState.visibleCount) !== props.dataSourceState.visibleCount
            && props.dataSourceState.visibleCount !== pickerState.dataSourceState.visibleCount) {
            pickerState.setDataSourceState(Object.assign(Object.assign({}, pickerState.dataSourceState), { visibleCount: props.dataSourceState.visibleCount }));
        }
        if (!isEqual((_b = prevProps.current) === null || _b === void 0 ? void 0 : _b.visibleIds, props.visibleIds) && !isEqual(props.visibleIds, visibleIds)) {
            setVisibleIds(props.visibleIds);
        }
    }, [props.visibleIds, props.visibleIds]);
    useEffect(() => {
        prevProps.current = props;
    }, [props]);
    return Object.assign(Object.assign({}, pickerState), { visibleIds,
        setVisibleIds });
}

function usePickerList(props) {
    const context = useContext(UuiContext);
    const sessionStartTime = useMemo(() => new Date().getTime(), []);
    const getMaxTotalItems = () => props.maxTotalItems || 50;
    const getMaxDefaultItems = () => Math.min(props.maxDefaultItems || 10, getMaxTotalItems());
    const getSettingsKey = () => 'loveship/PickerList/lastSelectedIds/v2/' + props.settingsKey;
    const getSelectedIdsArray = (selected) => {
        if (selected) {
            if (props.selectionMode === 'single') {
                return [selected];
            }
            else {
                return selected;
            }
        }
        return [];
    };
    const addDistinct = (to, add, maxItems) => {
        const added = {};
        to.forEach((id) => {
            added[JSON.stringify(id)] = true;
        });
        const result = [...to];
        for (let n = 0; n < add.length && result.length < maxItems; n++) {
            const id = add[n];
            const key = JSON.stringify(id);
            if (!added[key]) {
                result.push(id);
                added[key] = true;
            }
        }
        return result;
    };
    const maxDefaultItems = getMaxDefaultItems();
    const getVisibleIds = () => {
        let lastUsedUds = [];
        if (props.settingsKey) {
            const settings = context.uuiUserSettings.get(getSettingsKey(), []);
            lastUsedUds = settings.map((r) => r.id);
        }
        let visibleIds = getSelectedIdsArray(props.value).slice(0, getMaxTotalItems());
        visibleIds = addDistinct(visibleIds, [...lastUsedUds, ...(props.defaultIds || [])], maxDefaultItems);
        return visibleIds;
    };
    const pickerListState = usePickerListState({
        dataSourceState: { visibleCount: maxDefaultItems },
        visibleIds: getVisibleIds(),
    });
    const { dataSourceState, setDataSourceState, visibleIds } = pickerListState;
    const pickerProps = Object.assign(Object.assign({}, props), { showSelectedOnly: pickerListState.showSelected });
    const picker = usePicker(pickerProps, pickerListState);
    const { view, getEntityName, getPluralName, getDataSourceState, isSingleSelect, getName, getSelectedRows, handleDataSourceValueChange, getRowOptions, } = picker;
    useEffect(() => {
        const prevValue = dataSourceStateToValue(props, dataSourceState, props.dataSource);
        if (prevValue !== props.value) {
            setDataSourceState((state) => applyValueToDataSourceState(props, state, props.value, props.dataSource));
        }
    }, [props.value]);
    const onlySelectedView = props.dataSource.useView(getDataSourceState(), handleDataSourceValueChange, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ rowOptions: getRowOptions(), getSearchFields: props.getSearchFields || ((item) => [getName(item)]) }, (props.isFoldedByDefault ? { isFoldedByDefault: props.isFoldedByDefault } : {})), (props.sortBy ? { sortBy: props.sortBy } : {})), (props.cascadeSelection ? { cascadeSelection: props.cascadeSelection } : {})), (props.getRowOptions ? { getRowOptions: props.getRowOptions } : {})), { backgroundReload: true, showSelectedOnly: true }), [props.dataSource]);
    const getEntityNameForToggler = () => props.entityPluralName || getPluralName();
    const getModalTogglerCaption = (totalCount, rowsCount) => {
        let togglerCaption = i18n.pickerList.showAll;
        if (totalCount != null) {
            togglerCaption += ' ' + totalCount;
        }
        if (getEntityNameForToggler()) {
            togglerCaption += ' ' + getEntityNameForToggler().toUpperCase();
        }
        if (!isSingleSelect() && rowsCount > 0) {
            togglerCaption += i18n.pickerList.rowsSelected(rowsCount);
        }
        return togglerCaption;
    };
    const appendLastSelected = (ids) => {
        if (props.settingsKey) {
            let lastUsedIds = context.uuiUserSettings.get(getSettingsKey(), []);
            const selectionTime = new Date().getTime();
            lastUsedIds = [...ids.map((id) => ({ id, selectionTime, sessionStartTime: sessionStartTime })).reverse(), ...lastUsedIds].slice(0, 100);
            context.uuiUserSettings.set(getSettingsKey(), lastUsedIds);
        }
    };
    const sortRows = (rows) => {
        var _a;
        const dsState = getDataSourceState();
        const sorting = (_a = dsState.sorting) === null || _a === void 0 ? void 0 : _a[0];
        if (!sorting || (!props.sortBy && !sorting.field)) {
            return rows;
        }
        const sortBy = props.sortBy || ((i) => i[sorting.field]);
        const sign = sorting.direction === 'desc' ? -1 : 1;
        const stringComparer = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;
        const comparer = (a, b) => {
            const aIsLoading = (a.isLoading || a.isUnknown);
            const bIsLoading = (b.isLoading || b.isUnknown);
            const loadingComparison = (bIsLoading ? 0 : 1) - (aIsLoading ? 0 : 1);
            if ((loadingComparison && loadingComparison !== 0) || (aIsLoading && bIsLoading)) {
                return loadingComparison;
            }
            else {
                return sign * stringComparer(sortBy(a.value, sorting), sortBy(b.value, sorting));
            }
        };
        return [...rows].sort(comparer);
    };
    const buildRowsList = () => {
        const maxTotalItems = getMaxTotalItems();
        const result = [];
        const added = {};
        const addRows = (rows, maxItems) => {
            for (let n = 0; n < rows.length && (!maxItems || result.length < maxItems); n++) {
                const row = rows[n];
                if (!added[row.rowKey]) {
                    result.push(row);
                    added[row.rowKey] = true;
                }
            }
        };
        addRows(getSelectedRows(maxTotalItems), maxTotalItems);
        if ((visibleIds === null || visibleIds === void 0 ? void 0 : visibleIds.length) && result.length < maxTotalItems) {
            const rows = visibleIds.map((id, n) => view.getById(id, n));
            addRows(rows, maxTotalItems);
        }
        if (!props.defaultIds && result.length < maxDefaultItems) {
            const rows = view.getVisibleRows();
            addRows(rows, maxDefaultItems);
        }
        return sortRows(result);
    };
    return {
        context,
        dataSourceState,
        getName,
        getEntityName,
        appendLastSelected,
        getSelectedIdsArray,
        view,
        onlySelectedView,
        buildRowsList,
        getMaxDefaultItems,
        getModalTogglerCaption,
    };
}

function usePickerModalState(props) {
    const pickerState = usePickerState(props);
    const { selectionMode } = props;
    const [selection, setSelection] = useState(props.selection);
    useEffect(() => {
        if (props.selection !== selection) {
            setSelection(props.selection);
        }
    }, [props.selection]);
    useEffect(() => {
        if (selection === undefined && selectionMode !== 'single') {
            setSelection([]);
        }
    }, [selection]);
    return Object.assign(Object.assign({}, pickerState), { setSelection,
        selection });
}

const initialStateValues = {
    topIndex: 0,
    visibleCount: 30,
    focusedIndex: -1, // we don't want to focus the 1st item from the start, as it confuses and people would rarely use keyboard in modals
};
function usePickerModal(props) {
    const pickerListState = usePickerModalState({
        dataSourceState: Object.assign({}, initialStateValues),
        selection: props.initialValue,
        selectionMode: props.selectionMode,
    });
    const { dataSourceState, selection, setSelection } = pickerListState;
    const pickerProps = Object.assign(Object.assign({}, props), { showSelectedOnly: pickerListState.showSelected, value: selection, onValueChange: setSelection });
    const picker = usePicker(pickerProps, pickerListState);
    const { context, view, getEntityName, getName, getListProps, getDataSourceState, clearSelection, isSingleSelect, handleDataSourceValueChange, } = picker;
    const dataSourceStateLens = useMemo(() => Lens
        .onEditable({ value: dataSourceState, onValueChange: handleDataSourceValueChange })
        .onChange((_, newVal) => (Object.assign(Object.assign({}, newVal), initialStateValues))), [dataSourceState, handleDataSourceValueChange]);
    useEffect(() => {
        const prevValue = dataSourceStateToValue(props, dataSourceState, props.dataSource);
        if (prevValue !== props.initialValue) {
            handleDataSourceValueChange(applyValueToDataSourceState(props, dataSourceState, props.initialValue, props.dataSource));
        }
    }, [props.initialValue]);
    const getRows = () => view.getVisibleRows();
    const getFooterProps = () => {
        const footerProps = picker.getFooterProps();
        return Object.assign(Object.assign({}, footerProps), { success: () => props.success(selection), abort: props.abort });
    };
    return {
        context,
        selection,
        dataSourceState,
        dataSourceStateLens,
        getName,
        getEntityName,
        getListProps,
        view,
        getRows,
        getFooterProps,
        getDataSourceState,
        clearSelection,
        isSingleSelect,
        handleDataSourceValueChange,
    };
}

class ErrorCatch extends React__default.Component {
    constructor(props) {
        super(props);
    }
    componentDidCatch(error) {
        this.context.uuiErrors.reportError(error);
    }
    render() {
        return this.props.children;
    }
}
ErrorCatch.contextType = UuiContext;

export { Accordion, AdaptivePanel, Anchor, Avatar, AvatarStack, BaseRating, Blocker, Burger, Button, Calendar, CalendarPresets, Checkbox, Clickable, ControlGroup, DataPickerRow, DataTableCell, DataTableCellContainer, DataTableFocusContext, DataTableFocusProvider, DataTableHeaderCell, DataTableHeaderRow, DataTableRow, DataTableSelectionContext, DataTableSelectionProvider, Day, DragHandle, DropSpot, Dropdown, DropdownContainer, ErrorCatch, FlexCell, FlexRow, FlexSpacer, IconButton, IconContainer, InputAddon, LabeledInput, MainMenu, MainMenuCustomElement, MainMenuLogo, ModalBlocker, ModalWindow, Modals, MonthSelection, NumericInput, Paginator, PickerBodyBase, PickerToggler, Portal, PortalRoot, ProgressBar, RadioInput, RangeSlider, Rating, RichTextView, ScrollBars, ScrollSpy, Slider, Snackbar, Spinner, Svg, Switch, Text, TextArea, TextInput, Tooltip, Tree, UploadFileToggler, VPanel, YearSelection, applyValueToDataSourceState, dataSourceStateToValue, handleDataSourceKeyboard, i18n, useColumnsConfiguration, useDataTableFocusManager, useDocumentDir, usePicker, usePickerInput, usePickerList, usePickerModal, useScrollSpy, uuiBurger, uuiDaySelection, uuiMainMenu, uuiMonthSelection, uuiNumericInput, uuiPresets, uuiYearSelection };
//# sourceMappingURL=index.esm.js.map
