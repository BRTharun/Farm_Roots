import { IMap } from '../../../../../types';
import { ITreeNodeInfo, ITreeParams, IItemsAccessor } from './types';
import { NOT_FOUND_RECORD } from '../constants';
import { ItemsMap } from '../ItemsMap';
import { ITree, ITreeItemsInfo } from '../ITree';
export declare class TreeStructure<TItem, TId> implements ITree<TItem, TId> {
    private _params;
    private readonly _itemsAccessor;
    protected readonly _byParentId: IMap<TId, TId[]>;
    protected readonly _nodeInfoById: IMap<TId, ITreeNodeInfo>;
    constructor(_params: ITreeParams<TItem, TId>, _itemsAccessor: IItemsAccessor<TItem, TId>, _byParentId?: IMap<TId, TId[]>, _nodeInfoById?: IMap<TId, ITreeNodeInfo>);
    get itemsAccessor(): IItemsAccessor<TItem, TId>;
    getParams(): ITreeParams<TItem, TId>;
    get byParentId(): IMap<TId, TId[]>;
    get nodeInfoById(): IMap<TId, ITreeNodeInfo>;
    getRootItems(): TItem[];
    getById(id: TId): typeof NOT_FOUND_RECORD | TItem;
    getItems(parentId?: TId): ITreeItemsInfo<TId>;
    getChildren(parentId: TId): TItem[];
    getTotalCount(): number;
    computeSubtotals<TSubtotals>(get: (item: TItem, hasChildren: boolean) => TSubtotals, add: (a: TSubtotals, b: TSubtotals) => TSubtotals): import("../helpers/map").CompositeKeysMap<TId, TSubtotals> | Map<TId, TSubtotals>;
    static create<TItem, TId>(params: ITreeParams<TItem, TId>, itemsAccessor: IItemsAccessor<TItem, TId>, byParentId?: IMap<TId, TId[]>, nodeInfoById?: IMap<TId, ITreeNodeInfo>): TreeStructure<TItem, TId>;
    static withNewItemsAccessor<TItem, TId>(itemsAccessor: IItemsAccessor<TItem, TId>, treeStructure: TreeStructure<TItem, TId>): TreeStructure<TItem, TId>;
    static createFromItems<TItem, TId>({ params, items, itemsAccessor, }: {
        params: ITreeParams<TItem, TId>;
        items: TItem[] | ItemsMap<TId, TItem>;
        itemsAccessor: IItemsAccessor<TItem, TId>;
    }): TreeStructure<TItem, TId>;
}
//# sourceMappingURL=TreeStructure.d.ts.map