import { DataSourceState, LazyDataSourceApi } from '../../../../../../../types';
import { TreeState } from '../../../treeState';
import { LazyTreeProps } from './types';
import { CommonTreeConfig } from '../types';
import { LoadAllConfig, TreeStructureId } from '../../../treeState/types';
export interface UseLoadDataProps<TItem, TId, TFilter = any> extends Pick<LazyTreeProps<TItem, TId, TFilter>, 'getChildCount'>, Pick<CommonTreeConfig<TItem, TId, TFilter>, 'dataSourceState' | 'cascadeSelection'> {
    api: LazyDataSourceApi<TItem, TId, TFilter>;
    filter?: TFilter;
    isFolded: (item: TItem) => boolean;
    fetchStrategy?: 'sequential' | 'parallel';
    flattenSearchResults?: boolean;
    getChildCount?(item: TItem): number;
}
export interface LoadResult<TItem, TId> {
    isUpdated: boolean;
    isOutdated: boolean;
    tree: TreeState<TItem, TId>;
}
interface LoadMissingOptions<TItem, TId, TFilter> {
    using?: TreeStructureId;
    tree: TreeState<TItem, TId>;
    abortInProgress?: boolean;
    loadAllChildren?(id: TId): LoadAllConfig;
    isLoadStrict?: boolean;
    dataSourceState?: DataSourceState<TFilter, TId>;
}
export declare function useLoadData<TItem, TId, TFilter = any>(props: UseLoadDataProps<TItem, TId, TFilter>): {
    loadMissing: ({ tree, using, abortInProgress, loadAllChildren, isLoadStrict, dataSourceState, }: LoadMissingOptions<TItem, TId, TFilter>) => Promise<LoadResult<TItem, TId>>;
    loadMissingOnCheck: (currentTree: TreeState<TItem, TId>, id: TId, isChecked: boolean, isRoot: boolean) => Promise<TreeState<TItem, TId>>;
};
export {};
//# sourceMappingURL=useLoadData.d.ts.map