import { CascadeSelection, DataRowPathItem, DataSourceState, IMap, LazyDataSourceApi } from '../../../../types';
import { ITree } from './ITree';
import { NOT_FOUND_RECORD } from './constants';
import { ITreeNodeInfo, ITreeParams } from './treeStructure/types';
import { TreeStructure } from './treeStructure';
export interface LoadOptions<TItem, TId, TFilter = any> {
    tree: ITree<TItem, TId>;
    api: LazyDataSourceApi<TItem, TId, TFilter>;
    getChildCount?(item: TItem): number;
    isFolded?: (item: TItem) => boolean;
    dataSourceState: DataSourceState<TFilter, TId>;
    filter?: TFilter;
}
export interface LoadMissingOnCheckOptions<TItem, TId, TFilter = any> extends Omit<LoadOptions<TItem, TId, TFilter>, 'withNestedChildren'> {
    cascadeSelection?: CascadeSelection;
    checkedId?: TId;
    isRoot: boolean;
    isChecked: boolean;
}
/**
 * Structured result of tree records loading.
 */
export interface ITreeLoadResult<TItem, TId> {
    /**
     * Loaded records.
     */
    loadedItems: TItem[];
    /**
     * Loaded records, structured by parents IDs.
     */
    byParentId: IMap<TId, TId[]>;
    /**
     * Loading node info, like count/assumedCount/totalCount, by IDs.
     */
    nodeInfoById: IMap<TId, ITreeNodeInfo>;
}
export declare class Tree {
    static createFromItems<TItem, TId>({ params, items }: {
        params: ITreeParams<TItem, TId>;
        items: TItem[];
    }): TreeStructure<TItem, TId>;
    static getParents<TItem, TId>(id: TId, tree: ITree<TItem, TId>): TId[];
    static getPathById<TItem, TId>(id: TId, tree: ITree<TItem, TId>): DataRowPathItem<TId, TItem>[];
    static getPathItem<TItem, TId>(item: TItem, tree: ITree<TItem, TId>): DataRowPathItem<TId, TItem>;
    static forEach<TItem, TId>(tree: ITree<TItem, TId>, action: (item: TItem, id: TId, parentId: TId, stop: () => void) => void, options?: {
        direction?: 'bottom-up' | 'top-down';
        parentId?: TId;
        includeParent?: boolean;
    }): void;
    static forEachChildren<TItem, TId>(tree: ITree<TItem, TId>, action: (id: TId) => void, isSelectable: (id: TId, item: TItem | typeof NOT_FOUND_RECORD) => boolean, parentId?: TId, includeParent?: boolean): void;
    static load<TItem, TId, TFilter = any>({ tree, dataSourceState, api, getChildCount, isFolded, filter, }: LoadOptions<TItem, TId, TFilter>): Promise<ITreeLoadResult<TItem, TId>>;
    static loadMissingOnCheck<TItem, TId, TFilter = any>({ tree, dataSourceState, api, getChildCount, isFolded, filter, cascadeSelection, isRoot, isChecked, checkedId, }: LoadMissingOnCheckOptions<TItem, TId, TFilter>): Promise<ITree<TItem, TId> | ITreeLoadResult<TItem, TId>>;
    static computeSubtotals<TItem, TId, TSubtotals>(tree: ITree<TItem, TId>, get: (item: TItem, hasChildren: boolean) => TSubtotals, add: (a: TSubtotals, b: TSubtotals) => TSubtotals): IMap<TId, TSubtotals>;
}
//# sourceMappingURL=Tree.d.ts.map