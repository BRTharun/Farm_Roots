import { ItemsStorage } from '../ItemsStorage';
import { ExtendedPatchOptions, FilterOptions, LoadAllOptions, LoadOptions, SearchOptions, SortOptions } from './types';
import { TreeStructure } from '../treeStructure';
import { ItemsMap } from '../ItemsMap';
import { NOT_FOUND_RECORD } from '../constants';
import { ITreeParams } from '../treeStructure/types';
export declare class TreeState<TItem, TId> {
    private _fullTree;
    private _visibleTree;
    private _selectedOnlyTree;
    protected _itemsMap: ItemsMap<TId, TItem>;
    protected _setItems: ItemsStorage<TItem, TId>['setItems'];
    protected constructor(_fullTree: TreeStructure<TItem, TId> | null, _visibleTree: TreeStructure<TItem, TId> | null, _selectedOnlyTree: TreeStructure<TItem, TId> | null, _itemsMap: ItemsMap<TId, TItem>, _setItems: ItemsStorage<TItem, TId>['setItems']);
    get itemsMap(): ItemsMap<TId, TItem>;
    get setItems(): (items: TItem[], options?: import("../ItemsStorage").ModificationOptions) => ItemsMap<TId, TItem>;
    get visible(): TreeStructure<TItem, TId>;
    get selectedOnly(): TreeStructure<TItem, TId>;
    get full(): TreeStructure<TItem, TId>;
    getById(id: TId): typeof NOT_FOUND_RECORD | TItem;
    load<TFilter>({ using, options, dataSourceState, }: LoadOptions<TItem, TId, TFilter>): Promise<TreeState<TItem, TId>>;
    loadAll<TFilter>({ using, options, dataSourceState, }: LoadAllOptions<TItem, TId, TFilter>): Promise<TreeState<TItem, TId>>;
    filter<TFilter>({ filter, getFilter, }: FilterOptions<TItem, TId, TFilter>): TreeState<TItem, TId>;
    sort<TFilter>({ getId, sorting, sortBy, }: SortOptions<TItem, TId, TFilter>): TreeState<TItem, TId>;
    search<TFilter>({ search, getSearchFields, sortSearchByRelevance, }: SearchOptions<TItem, TId, TFilter>): TreeState<TItem, TId>;
    private patchTreeStructure;
    patch({ sortedPatch, patchAtLastSort, getItemTemporaryOrder, isDeleted, sorting, sortBy }: ExtendedPatchOptions<TItem, TId>): TreeState<TItem, TId>;
    /**
     * TODO: Add later `selectedOnlyMode: 'tree' | 'flat'.
     */
    private buildSelectedOnlyTree;
    buildSelectedOnly(checkedIds: TId[]): TreeState<TItem, TId>;
    updateItemsMap(itemsMap: ItemsMap<TId, TItem>): TreeState<TItem, TId>;
    private getTreeStructure;
    clearStructure(): TreeState<TItem, TId>;
    reset(): TreeState<TItem, TId>;
    private withNewTreeStructures;
    static create<TItem, TId>(fullTree: TreeStructure<TItem, TId>, visibleTree: TreeStructure<TItem, TId>, selectedOnlyTree: TreeStructure<TItem, TId>, itemsMap: ItemsMap<TId, TItem>, setItems: ItemsStorage<TItem, TId>['setItems']): TreeState<TItem, TId>;
    static createFromItems<TItem, TId>(items: TItem[] | undefined, itemsMap: ItemsMap<TId, TItem> | undefined, params: ITreeParams<TItem, TId>, setItems: ItemsStorage<TItem, TId>['setItems']): TreeState<TItem, TId>;
    static createFromItemsMap<TItem, TId>(itemsMap: ItemsMap<TId, TItem> | undefined, setItems: ItemsStorage<TItem, TId>['setItems'], params: ITreeParams<TItem, TId>): TreeState<TItem, TId>;
    static blank<TItem, TId>(params: ITreeParams<TItem, TId>, itemsMap: ItemsMap<TId, TItem>, setItems: ItemsStorage<TItem, TId>['setItems']): TreeState<TItem, TId>;
}
//# sourceMappingURL=TreeState.d.ts.map