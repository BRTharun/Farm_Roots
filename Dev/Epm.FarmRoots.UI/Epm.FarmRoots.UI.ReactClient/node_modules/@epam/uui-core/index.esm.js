import * as React from 'react';
import React__default, { createContext, useState, useEffect, useContext, useRef, useMemo, useCallback, useLayoutEffect } from 'react';
import classNames from 'classnames';
import debounce from 'lodash.debounce';
import ReactDOM, { flushSync } from 'react-dom';
import * as PropTypes from 'prop-types';
import dayjs from 'dayjs';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isEqual from 'react-fast-compare';

const uuiElement = {
    widget: 'uui-widget',
    buttonBox: 'uui-button-box',
    anchor: 'uui-anchor',
    inputBox: 'uui-input-box',
    input: 'uui-input',
    placeholder: 'uui-placeholder',
    valueInPlaceholder: 'uui-value-in-placeholder',
    checkbox: 'uui-checkbox',
    checkboxContainer: 'uui-checkbox-container',
    foldingArrow: 'uui-folding-arrow',
    radioInput: 'uui-radioinput',
    icon: 'uui-icon',
    iconPrimary: 'uui-icon-primary',
    count: 'uui-count',
    caption: 'uui-caption',
    label: 'uui-label',
    labeledContainer: 'uui-labeled-container',
    inputLabel: 'uui-input-label',
    invalidMessage: 'uui-invalid-message',
    dropdownBody: 'uui-dropdown-body',
    switchBody: 'uui-switch-body',
    switchToggler: 'uui-switch-toggler',
    ratingStar: 'uui-rating-star',
    tooltipContainer: 'uui-tooltip-container',
    tooltipBody: 'uui-tooltip-body',
    tooltipArrow: 'uui-tooltip-arrow',
    modalBlocker: 'uui-modal-blocker',
    modalWindow: 'uui-modal-window',
    textareaCounter: 'uui-textarea-counter',
};
const uuiMod = {
    enabled: 'uui-enabled',
    disabled: 'uui-disabled',
    readonly: 'uui-readonly',
    focus: 'uui-focus',
    active: 'uui-active',
    invalid: 'uui-invalid',
    checked: 'uui-checked',
    selected: 'uui-selected',
    opened: 'uui-opened',
    loading: 'uui-loading',
    error: 'uui-error',
};
const labelMod = {
    left: 'uui-label-left',
    top: 'uui-label-top',
};
const directionMode = {
    vertical: 'uui-vertical-direction',
    horizontal: 'uui-horizontal-direction',
};
const uuiMarkers = {
    lockFocus: '-lock-focus',
    clickable: '-clickable',
    draggable: '-draggable',
    scrolledLeft: '-scrolled-left',
    scrolledRight: '-scrolled-right',
    scrolledTop: '-scrolled-top',
    scrolledBottom: '-scrolled-bottom',
};
const uuiDndState = {
    draggedOut: 'uui-dragged-out',
    dropAccepted: 'uui-drop-accepted',
    dragGhost: 'uui-drag-ghost',
};
const uuiDataTableHeaderCell = {
    uuiTableHeaderCell: 'uui-table-header-cell',
    uuiTableHeaderCaption: 'uui-table-header-caption',
    uuiTableHeaderCaptionWrapper: 'uui-table-header-caption-wrapper',
    uuiTableHeaderCheckbox: 'uui-table-header-checkbox',
    uuiTableHeaderSortIcon: 'uui-table-header-sort-icon',
    uuiTableHeaderFilterIcon: 'uui-table-header-filter-icon',
    uuiTableHeaderDropdownIcon: 'uui-table-header-dropdown-icon',
    uuiTableHeaderFoldAllIcon: 'uui-table-header-fold-all-icon',
};
const uuiScrollShadows = {
    top: 'uui-scroll-shadow-top',
    topVisible: 'uui-scroll-shadow-top-visible',
    bottom: 'uui-scroll-shadow-bottom',
    bottomVisible: 'uui-scroll-shadow-bottom-visible',
};

/**
 * React forward-ref function, with a patched type, allowed generic types to pass-thru
 * More here: https://fettblog.eu/typescript-react-generic-forward-refs/
 * We go with re-export this way, instead of patching React typings, to not break typings in dependent projects.
 */
const forwardRef = React__default.forwardRef;

function withMods(Component, getCx, getProps) {
    const isClassComponent = Component.prototype instanceof React.Component;
    // Class components needs to be wrapped in any case,
    // as they might rely on withMods to add forwardedRef.
    if (!isClassComponent && !getProps && !getCx) {
        return Component;
    }
    function applyMods(props) {
        // Most components are wrapped in withMods component.
        // Please keep this method simple and performant.
        // Don't clone objects/arrays if not needed.
        const modProps = getProps === null || getProps === void 0 ? void 0 : getProps(props);
        const result = Object.assign({}, props, modProps);
        const cx = getCx === null || getCx === void 0 ? void 0 : getCx(props);
        if (cx) {
            result.cx = [cx, props.cx];
        }
        return result;
    }
    let wrappedComponent;
    if (!Component) {
        // Happens in tests, probably due to circular dependencies.
        return null;
    }
    else if (isClassComponent) {
        // Class component. Wrap with forwardRef, and pass ref in the forwardedRef prop
        wrappedComponent = /* @__PURE__ */forwardRef((props, ref) => {
            const allProps = applyMods(props);
            allProps.forwardedRef = ref;
            return React.createElement(Component, allProps);
        });
    }
    else if (Component.render) {
        // React.forwardRef component.
        // Basically its object like { $$type: Symbol(FORWARD_REF), render: (props, ref) => ... }
        // However, $$type is not exposed, so there's no good way to detect this.
        // We re-wrap it in another forward ref, to avoid unnecessary stacking two forwardRefs
        wrappedComponent = /* @__PURE__ */forwardRef((props, ref) => Component.render(applyMods(props), ref));
    }
    else if (Component instanceof Function) {
        // Plain functional component. Just wrap with function, and apply mods to props
        wrappedComponent = (props) => Component(applyMods(props));
    }
    else {
        // Any other type of component. E.g. React.memo.
        // Wrap it in another functional component
        wrappedComponent = (props) => React.createElement(Component, applyMods(props));
    }
    wrappedComponent.displayName = `${(Component === null || Component === void 0 ? void 0 : Component.displayName) || (Component === null || Component === void 0 ? void 0 : Component.name) || 'unknown'} (withMods)`;
    return wrappedComponent;
}

function isEventTargetInsideClickable(e) {
    return isAnyParentHasClass(_getEventTarget(e), e.currentTarget, [uuiMarkers.clickable]);
}
/**
 * This method receives blur event. So, relatedTarget is the element receiving focus.
 * @param e - blur event
 */
function isFocusReceiverInsideFocusLock(e) {
    return isAnyParentHasClass(e.relatedTarget, _getEventTarget(e), [uuiMarkers.lockFocus]);
}
function isEventTargetInsideDraggable(e, toElement) {
    return isAnyParentHasClass(_getEventTarget(e), toElement, [uuiMarkers.draggable]);
}
function isEventTargetInsideInput(e, toElement) {
    return isAnyParentHasClass(_getEventTarget(e), toElement, [uuiElement.input]);
}
function releasePointerCaptureOnEventTarget(e) {
    _getEventTarget(e).releasePointerCapture(e.pointerId);
}
/**
 * Iterates parent elements starting from "fromElement" and goes through its parents until "toElement" is found.
 * It returns true if any element along this path contains one of the class names specified in the "classNames" array.
 *
 * @param fromElement
 * @param toElement
 * @param classNames
 */
function isAnyParentHasClass(fromElement, toElement, classNames) {
    let el = fromElement;
    while (el && toElement !== el) {
        if (el.classList && classNames.some((className) => el.classList.contains(className))) {
            return true;
        }
        el = _getParentElement(el);
    }
    return false;
}
function blurFocusedElement() {
    const elem = _getActiveElement();
    elem === null || elem === void 0 ? void 0 : elem.blur();
}
function preventDefaultIfTargetFocused(e) {
    if (_getActiveElement() === e.target) {
        e.preventDefault();
    }
}
/**
 * Works exactly like native "closest" method, with next enhancements:
 * - supports HTMLElement as a selector
 * - takes Event as an input and performs search for the "event target" or "event related target" for focus/blur events.
 *
 * @param event
 * @param condition
 */
function closestTargetParentByCondition(e, condition) {
    const element = _getInteractionTarget(e);
    if (!element || !condition) {
        return null;
    }
    const conditionCallback = (elem) => {
        if (typeof condition === 'string') {
            return elem.matches(condition);
        }
        return condition === elem;
    };
    if (conditionCallback(element)) {
        return element;
    }
    let parent = _getParentElement(element);
    while (parent) {
        if (conditionCallback(parent)) {
            return parent;
        }
        parent = _getParentElement(parent);
    }
    return null;
}
function getScrollParentOfEventTarget(event, dimension) {
    const node = _getEventTarget(event);
    return _getScrollParent(node, dimension);
}
/**
 * ↓ PRIVATE methods below this comment ↓
 */
/**
 * Works as normal "element.parentElement" with next enhancement:
 * - If direct parent element is a shadow root, then it returns the shadow host element instead of null.
 * @param element
 */
function _getParentElement(element) {
    let parentElem = element.parentElement;
    const parentNode = element.parentNode;
    if (!parentElem && parentNode instanceof ShadowRoot) {
        parentElem = parentNode.host;
    }
    return parentElem;
}
/**
 * Works as normal "document.activeElement" with next enhancement:
 * - if focused element is located inside shadow DOM, then it returns actual focused element instead of the shadow DOM host.
 */
function _getActiveElement() {
    const activeEl = document.activeElement || null;
    if (activeEl && activeEl.shadowRoot) {
        return activeEl.shadowRoot.activeElement;
    }
    return activeEl;
}
function _getScrollParent(node, dimension) {
    if (node == null) {
        return null;
    }
    const isElement = node instanceof HTMLElement;
    const style = isElement && window.getComputedStyle(node);
    let overflow;
    let scrollSize;
    let clientSize;
    if (dimension === 'x') {
        overflow = style && style.overflowX;
        scrollSize = node.scrollWidth;
        clientSize = node.clientWidth;
    }
    else {
        overflow = style && style.overflowY;
        scrollSize = node.scrollHeight;
        clientSize = node.clientHeight;
    }
    const isScrollable = overflow !== 'visible' && overflow !== 'hidden';
    if (isScrollable && scrollSize > clientSize) {
        return node;
    }
    else {
        return _getScrollParent(_getParentElement(node), dimension);
    }
}
/**
 * 1. For native Event - works as normal "event.target" with next enhancement:
 *    - If event occurs inside shadow DOM and caught outside the shadow dom then the real target is returned instead of the shadow DOM host.
 * 2. For React synthetic event - just returns "event.target" because it already points to the actual target.
 *
 * @param event
 */
function _getEventTarget(event) {
    if (event instanceof Event) {
        let target;
        if (['focus', 'blur', 'focusin', 'focusout'].includes(event.type)) {
            target = event.relatedTarget;
        }
        else {
            target = event.target;
        }
        if (target instanceof Element && target.shadowRoot) {
            /**
             * If event occurs inside shadow DOM and caught outside the shadow dom,
             * then "event.target" points to the shadow dom host, instead of the real target
             */
            return event.composedPath()[0];
        }
        return target;
    }
    // event target is always correct in synthetic events.
    return event.target;
}
const _isFocusEvent = (e) => ['focus', 'blur', 'focusin', 'focusout'].includes(e.type);
function _getInteractionTarget(e) {
    if (_isFocusEvent(e)) {
        return e.relatedTarget;
    }
    return _getEventTarget(e);
}

function arrayToMatrix(array, divider) {
    const matrix = [];
    for (let i = 0; i < array.length / divider; i += 1) {
        matrix.push(array.slice(i * divider, (i + 1) * divider));
    }
    return matrix;
}

const cx = (...args) => {
    return classNames(...args);
};

const isClientSide = typeof window !== 'undefined';

function getOffset(element) {
    const box = element.getBoundingClientRect();
    return {
        top: box.top + window.pageYOffset - document.documentElement.clientTop,
        left: box.left + window.pageXOffset - document.documentElement.clientLeft,
    };
}

class BaseContext {
    constructor() {
        this.handlers = [];
    }
    init() {
    }
    subscribe(handler) {
        this.handlers.push(handler);
    }
    unsubscribe(handler) {
        this.handlers = this.handlers.filter((h) => h !== handler);
    }
    update(state) {
        ReactDOM.unstable_batchedUpdates(() => {
            this.handlers.forEach((h) => h && h(state));
        });
    }
    destroyContext() {
        this.handlers = [];
    }
}

const maxScrollSpeed = 2000; // px/second
class DndContext extends BaseContext {
    constructor() {
        super(...arguments);
        this.isDragging = false;
        this.scrollZoneSize = 85;
        this.ghostOffsetX = 0;
        this.ghostOffsetY = 0;
        this.ghostWidth = 300;
        this.renderGhostCallback = null;
        this.lastScrollTime = new Date().getTime();
        this.mouseCoordsService = new MouseCoordsService();
        this.getMouseCoords = () => {
            return this.mouseCoordsService.getCoords();
        };
        this.xScrollNode = null;
        this.yScrollNode = null;
        this.windowPointerMoveHandler = (e) => {
            if (this.isDragging) {
                this.xScrollNode = getScrollParentOfEventTarget(e, 'x');
                this.yScrollNode = getScrollParentOfEventTarget(e, 'y');
            }
        };
        this.windowPointerUpHandler = () => {
            this.endDrag();
        };
    }
    init() {
        super.init();
        if (isClientSide) {
            this.mouseCoordsService.init();
            window.addEventListener('pointermove', this.windowPointerMoveHandler);
            window.addEventListener('pointerup', this.windowPointerUpHandler);
        }
    }
    destroyContext() {
        super.destroyContext();
        if (isClientSide) {
            window.removeEventListener('pointermove', this.windowPointerMoveHandler);
            window.removeEventListener('pointerup', this.windowPointerUpHandler);
            this.mouseCoordsService.destroy();
        }
    }
    startDrag(node, data, renderGhost) {
        const offset = getOffset(node);
        const mouseCoords = this.mouseCoordsService.getCoords();
        this.ghostOffsetX = offset.left - mouseCoords.mouseDownPageX - parseInt(getComputedStyle(node, null).marginLeft, 10);
        this.ghostOffsetY = offset.top - mouseCoords.mouseDownPageY - parseInt(getComputedStyle(node, null).marginTop, 10);
        this.ghostWidth = node.offsetWidth + parseInt(getComputedStyle(node, null).marginLeft, 10) + parseInt(getComputedStyle(node, null).marginRight, 10);
        this.dragData = data;
        this.renderGhostCallback = renderGhost;
        // prepare scroll
        this.lastScrollTime = new Date().getTime();
        isClientSide && window.requestAnimationFrame(() => this.scrollWindow());
        this.update({
            isDragging: true,
            ghostOffsetX: this.ghostOffsetX,
            ghostOffsetY: this.ghostOffsetY,
            ghostWidth: this.ghostWidth,
            renderGhost: this.renderGhostCallback,
        });
        this.isDragging = true;
        // To close dropdowns
        const ev = document.createEvent('Events');
        ev.initEvent('dragstart', true, false);
        document.body.dispatchEvent(ev);
    }
    endDrag() {
        if (!this.isDragging) {
            return;
        }
        new Promise((res) => {
            this.update({ isDragging: false });
            res();
        }).then(() => {
            this.renderGhostCallback = null;
            this.dragData = null;
            this.isDragging = false;
        });
    }
    getScrollStep(nodeSize, nodeOffset, nodeScroll, mousePageCoord, mouseDelta) {
        const now = new Date().getTime();
        const startToMouse = mousePageCoord - nodeOffset;
        const endToMouse = nodeOffset + nodeSize - mousePageCoord;
        const scrollZoneSize = Math.min(this.scrollZoneSize, nodeSize / 4);
        let scrollDir = 0;
        // left/up
        if (mouseDelta < 0.5) {
            scrollDir = -Math.max(0, (scrollZoneSize - startToMouse) / scrollZoneSize);
        }
        // right/down
        if (mouseDelta > 0.5) {
            scrollDir = Math.max(0, (scrollZoneSize - endToMouse) / scrollZoneSize);
        }
        if (scrollDir !== 0) {
            const step = ((now - this.lastScrollTime) / 1000) * maxScrollSpeed * scrollDir;
            return nodeScroll + step;
        }
    }
    scrollWindow() {
        const now = new Date().getTime();
        const mouseCoords = this.mouseCoordsService.getCoords();
        if (this.xScrollNode) {
            const scrollX = this.getScrollStep(this.xScrollNode.offsetWidth, getOffset(this.xScrollNode).left, this.xScrollNode.scrollLeft, mouseCoords.mousePageX, mouseCoords.mouseDxSmooth);
            if (scrollX !== undefined && scrollX !== 0) {
                this.xScrollNode.scrollLeft = scrollX;
            }
        }
        if (this.yScrollNode) {
            const scrollY = this.getScrollStep(this.yScrollNode.offsetHeight, getOffset(this.yScrollNode).top, this.yScrollNode.scrollTop, mouseCoords.mousePageY, mouseCoords.mouseDySmooth);
            if (scrollY !== undefined && scrollY !== 0) {
                this.yScrollNode.scrollTop = scrollY;
            }
        }
        this.lastScrollTime = now;
        if (this.isDragging) {
            window.requestAnimationFrame(() => this.scrollWindow());
        }
    }
}
class MouseCoordsService {
    constructor() {
        this.init = () => {
            this._prevMouseCoords = {
                mousePageX: 0,
                mousePageY: 0,
                mouseDx: 0,
                mouseDy: 0,
                mouseDxSmooth: 0,
                mouseDySmooth: 0,
                mouseDownPageX: 0,
                mouseDownPageY: 0,
                buttons: 0,
            };
            if (isClientSide) {
                document.addEventListener('pointermove', this.handleMouseCoordsChange);
            }
        };
        this.handleMouseCoordsChange = (e) => {
            this._prevMouseCoords = getMouseCoordsFromPointerEvent(e, this._prevMouseCoords);
        };
        this.getCoords = () => {
            return this._prevMouseCoords;
        };
    }
    destroy() {
        if (isClientSide) {
            document.removeEventListener('pointermove', this.handleMouseCoordsChange);
        }
    }
}
function getMouseCoordsFromPointerEvent(e, prevCoords) {
    const mouseDx = e.pageX - prevCoords.mousePageX;
    const mouseDy = e.pageY - prevCoords.mousePageY;
    const mouseDxSmooth = prevCoords.mouseDxSmooth * 0.8 + mouseDx * 0.2;
    const mouseDySmooth = prevCoords.mouseDySmooth * 0.8 + mouseDy * 0.2;
    const mousePageX = e.pageX;
    const mousePageY = e.pageY;
    const result = {
        mouseDx,
        mouseDy,
        mouseDxSmooth,
        mouseDySmooth,
        mousePageX,
        mousePageY,
        buttons: e.buttons,
        mouseDownPageX: prevCoords.mouseDownPageX || 0,
        mouseDownPageY: prevCoords.mouseDownPageY || 0,
    };
    if ((prevCoords.buttons === 0 && e.buttons > 0) || e.pointerType === 'touch') {
        result.mouseDownPageX = mousePageX;
        result.mouseDownPageY = mousePageY;
    }
    return result;
}

const UuiContext = /* @__PURE__ */createContext({});

class DragGhost extends React.Component {
    constructor() {
        super(...arguments);
        this.layer = null;
        this.state = {
            isDragging: false,
        };
        this.onPointerMove = (e) => {
            if (this.state.isDragging) {
                this.setState((state) => (Object.assign(Object.assign({}, state), { pointerX: e.clientX, pointerY: e.clientY })));
            }
        };
        this.contextUpdateHandler = (state) => {
            var _a;
            if (state.isDragging && !this.layer) {
                this.layer = (_a = this.context.uuiLayout) === null || _a === void 0 ? void 0 : _a.getLayer();
            }
            else if (!state.isDragging && this.layer) {
                this.context.uuiLayout.releaseLayer(this.layer);
                this.layer = null;
            }
            const mouseCoords = this.context.uuiDnD.getMouseCoords();
            this.setState(Object.assign(Object.assign({}, state), { pointerX: mouseCoords.mousePageX, pointerY: mouseCoords.mousePageY }));
        };
    }
    componentDidMount() {
        if (!this.context)
            return;
        this.context.uuiDnD.subscribe(this.contextUpdateHandler);
        window.addEventListener('pointermove', this.onPointerMove);
    }
    componentWillUnmount() {
        this.layer && this.context.uuiLayout.releaseLayer(this.layer);
        window.removeEventListener('pointermove', this.onPointerMove);
        this.context.uuiDnD.unsubscribe(this.contextUpdateHandler);
    }
    getGhostCoords(pointerX, pointerY) {
        return {
            left: pointerX + this.state.ghostOffsetX,
            top: pointerY + this.state.ghostOffsetY,
        };
    }
    render() {
        if (!this.state.isDragging || !this.state.renderGhost) {
            return null;
        }
        return (React.createElement("div", { style: {
                position: 'fixed',
                width: this.state.ghostWidth,
                left: this.state.pointerX + this.state.ghostOffsetX,
                top: this.state.pointerY + this.state.ghostOffsetY,
                pointerEvents: 'none',
                zIndex: this.layer.zIndex,
            } }, this.state.renderGhost()));
    }
}
DragGhost.contextType = UuiContext;

function getSector(x, y) {
    const rads = Math.atan2(y, x); // (-PI, PI)
    const rotatedRads = rads + Math.PI * 2 + Math.PI / 2; // rotate to make positive and align with clock convention (top is the 0)
    const sector = Math.floor((rotatedRads / (Math.PI * 2)) * 8) % 8;
    return sector;
}

const DND_START_THRESHOLD = 5;
const initialState = {
    pointerX: 0,
    pointerY: 0,
    isMouseDown: false,
    isDragging: false,
    isMouseOver: false,
    position: null,
    dndContextState: {
        isDragging: false,
    },
};
/**
 * This workaround is needed to make it tree-shakable, but it does not look good.
 * It's better to rewrite it to functional component instead.
 * The key point here is to get rid of any static props (like sectorPositionPriorities, contextType).
 */
const DndActor = /* @__PURE__ */TREE_SHAKEABLE_INIT$1();
function TREE_SHAKEABLE_INIT$1() {
    var _a;
    return _a = class DndActorComponent extends React.Component {
            constructor() {
                super(...arguments);
                this.state = initialState;
                this.dndRef = React.createRef();
                this.contextUpdateHandler = (dndContextState) => {
                    this.setState({ dndContextState });
                };
                this.windowPointerUpHandler = () => {
                    if (this.state.isDragging || this.state.isMouseDown) {
                        this.setState(() => initialState);
                        this.context.uuiDnD.endDrag();
                    }
                };
                this.windowPointerMoveHandler = (e) => {
                    if (!this.state.isMouseDown
                        || e.buttons === 0 // can happen if native drag-n-drop occurs
                        || this.state.isDragging)
                        return;
                    if (isEventTargetInsideInput(e, this.dndRef.current)) {
                        return;
                    }
                    const mouseCoords = this.context.uuiDnD.getMouseCoords();
                    const dist = Math.sqrt(Math.pow(this.state.pointerX - mouseCoords.mousePageX, 2) + Math.pow(this.state.pointerY - mouseCoords.mousePageY, 2));
                    if (dist > DND_START_THRESHOLD) {
                        this.context.uuiDnD.startDrag(this.dndRef.current, this.props.srcData, () => this.props.render({
                            isDragGhost: true,
                            isDraggedOver: false,
                            isDraggable: false,
                            isDraggedOut: false,
                            isDropAccepted: false,
                            isDndInProgress: true,
                            eventHandlers: {},
                            classNames: [uuiDndState.dragGhost],
                        }));
                        this.setState((s) => (Object.assign(Object.assign({}, s), { isDragging: true, isDropAccepted: false /* TBD: fix state when DnD is just started, and drop is accepted by underlying element */ })));
                    }
                };
            }
            componentDidMount() {
                var _b, _c, _d;
                (_d = (_c = (_b = this.context) === null || _b === void 0 ? void 0 : _b.uuiDnD) === null || _c === void 0 ? void 0 : _c.subscribe) === null || _d === void 0 ? void 0 : _d.call(_c, this.contextUpdateHandler);
                window.addEventListener('pointerup', this.windowPointerUpHandler);
                window.addEventListener('pointermove', this.windowPointerMoveHandler);
            }
            componentWillUnmount() {
                window.removeEventListener('pointerup', this.windowPointerUpHandler);
                window.removeEventListener('pointermove', this.windowPointerMoveHandler);
                this.context.uuiDnD.unsubscribe(this.contextUpdateHandler);
            }
            getDropParams(e) {
                const { left, top, width, height, } = e.currentTarget.getBoundingClientRect();
                return {
                    srcData: this.context.uuiDnD.dragData,
                    dstData: this.props.dstData,
                    offsetLeft: e.clientX - left,
                    offsetTop: e.clientY - top,
                    targetWidth: width,
                    targetHeight: height,
                };
            }
            getPosition(params, options) {
                if (options == null)
                    return null;
                // Compute x/y offsets relative to the center, normalized by element dimensions:
                // -------------------------------
                // |(-1, -1)   (0,-1)     (1, -1)|
                // |                             |
                // |(-1,  0)   (0, 0)     (1,  0)|
                // |                             |
                // |(-1,  1)   (0, 1)     (1,  1)|
                // -------------------------------
                const x = (params.offsetLeft / params.targetWidth - 0.5) * 2;
                const y = (params.offsetTop / params.targetHeight - 0.5) * 2;
                if (options.inside) {
                    const insideBoxLeft = options.left ? -0.5 : -1;
                    const insideBoxRight = options.right ? 0.5 : 1;
                    const insideBoxTop = options.top ? -0.5 : -1;
                    const insideBoxBottom = options.bottom ? 0.5 : 1;
                    if (insideBoxLeft < x && x < insideBoxRight && insideBoxTop < y && y < insideBoxBottom) {
                        return 'inside';
                    }
                }
                // Compute the sector#. Basically it's clock-wise angle of mouse pointer normalized to [0,7) range
                //    7 | 0
                // 6    |    1
                // -----|------
                // 5    |    2
                //    4 | 3
                const sector = getSector(x, y);
                // Get possible positions, ordered by priority, from the lookup table
                const optionsByPriority = DndActor.sectorPositionPriorities[sector + ''].filter((o) => options[o]);
                if (optionsByPriority.length > 0) {
                    return optionsByPriority[0];
                }
                else {
                    return null;
                }
            }
            render() {
                var _b;
                const params = {
                    isDraggable: !!this.props.srcData,
                    isDraggedOut: this.state.isDragging,
                    isDraggedOver: ((_b = this.context.uuiDnD) === null || _b === void 0 ? void 0 : _b.isDragging) && this.state.isMouseOver,
                    isDropAccepted: this.state.isMouseOver && !!this.state.position,
                    isDragGhost: false,
                    isDndInProgress: this.state.dndContextState.isDragging,
                    dragData: this.state.isMouseOver ? this.context.uuiDnD.dragData : null,
                    eventHandlers: {},
                    position: this.state.isMouseOver ? this.state.position : null,
                    classNames: null,
                    ref: this.dndRef,
                };
                params.classNames = [
                    params.isDropAccepted && uuiDndState.dropAccepted, params.isDraggedOut && uuiDndState.draggedOut, params.isDraggable && uuiMarkers.draggable,
                ].filter(Boolean);
                if (!!this.props.srcData) {
                    params.eventHandlers.onPointerDown = (e) => {
                        if (isEventTargetInsideDraggable(e, e.currentTarget)) {
                            return;
                        }
                        e.persist();
                        if (e.button === 0) {
                            this.setState(() => {
                                const mouseCoords = this.context.uuiDnD.getMouseCoords();
                                return Object.assign(Object.assign({}, initialState), { isMouseDown: true, pointerX: mouseCoords.mousePageX, pointerY: mouseCoords.mousePageY });
                            });
                            if (!isEventTargetInsideInput(e, e.currentTarget)) {
                                // This prevents text selection start
                                // dnd don't work without it in ff
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        }
                    };
                }
                if (this.props.canAcceptDrop) {
                    const pointerLeaveHandler = () => {
                        if (this.context.uuiDnD.isDragging) {
                            this.setState((s) => (Object.assign(Object.assign({}, s), { isMouseOver: false, position: null })));
                        }
                    };
                    const pointerMoveHandler = (e) => {
                        if (this.context.uuiDnD.isDragging) {
                            if (isEventTargetInsideDraggable(e, e.currentTarget)) {
                                return pointerLeaveHandler();
                            }
                            releasePointerCaptureOnEventTarget(e); // allows you to trigger pointer events on other nodes
                            const dropParams = this.getDropParams(e);
                            const positionOptions = this.props.canAcceptDrop(dropParams);
                            const position = this.getPosition(dropParams, positionOptions);
                            this.setState((s) => (Object.assign(Object.assign({}, s), { isMouseOver: true, position })));
                        }
                    };
                    params.eventHandlers.onTouchStart = (e) => e.preventDefault(); // prevent defaults on ios
                    params.eventHandlers.onPointerEnter = pointerMoveHandler;
                    params.eventHandlers.onPointerMove = pointerMoveHandler;
                    params.eventHandlers.onPointerLeave = pointerLeaveHandler;
                }
                params.eventHandlers.onPointerUp = (e) => {
                    if (this.context.uuiDnD.isDragging) {
                        if (isEventTargetInsideDraggable(e, e.currentTarget)) {
                            return;
                        }
                        e.preventDefault();
                        if (!!this.state.position) {
                            this.props.onDrop && this.props.onDrop(Object.assign(Object.assign({}, this.getDropParams(e)), { position: this.state.position }));
                        }
                        this.context.uuiDnD.endDrag();
                        this.setState(() => initialState);
                    }
                };
                return this.props.render(params);
            }
        },
        _a.contextType = UuiContext,
        _a.sectorPositionPriorities = {
            0: [
                'top', 'right', 'inside',
            ],
            1: [
                'right', 'top', 'inside',
            ],
            2: [
                'right', 'bottom', 'inside',
            ],
            3: [
                'bottom', 'right', 'inside',
            ],
            4: [
                'bottom', 'left', 'inside',
            ],
            5: [
                'left', 'bottom', 'inside',
            ],
            6: [
                'left', 'top', 'inside',
            ],
            7: [
                'top', 'left', 'inside',
            ],
        },
        _a;
}

function genUniqueId() {
    return [Math.random(), Math.random()].reduce((acc, n) => (acc + n.toString(36).substring(2)), '');
}
function getPortalRootById(id) {
    var _a;
    let root = document.getElementById(id);
    if (!root) {
        /*
         * document.getElementById doesn't find elements by ID if they are located in shadow DOM.
         * so, as a fallback, we try to find shadow host by attribute name like this: [data-<id>]
         * and after that - try to find by id in the shadow root.
         */
        const shadow = document.querySelector(`[data-shadow-host-id="${id}"]`);
        root = (_a = shadow === null || shadow === void 0 ? void 0 : shadow.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById(id);
    }
    return root;
}
function maxBy(arr, getMax) {
    let maxItem;
    arr.forEach((value) => {
        if (maxItem === undefined) {
            maxItem = value;
        }
        if (getMax(value) > getMax(maxItem)) {
            maxItem = value;
        }
    });
    return maxItem;
}
class LayoutContext extends BaseContext {
    constructor() {
        super(...arguments);
        this.layerIdCounter = 0;
        this.layers = [];
        this.portalRootId = genUniqueId();
    }
    getPortalRoot() {
        /**
         * TODO: we should remove this part: document.getElementById('main') || document.getElementById('root')
         */
        if (isClientSide) {
            return getPortalRootById(this.portalRootId) || document.getElementById('main') || document.getElementById('root') || document.body;
        }
    }
    getPortalRootId() {
        return this.portalRootId;
    }
    getLayer() {
        const topLayer = maxBy(this.layers, (l) => l.depth);
        const depth = topLayer ? topLayer.depth + 1 : 0;
        const layer = {
            id: this.layerIdCounter++,
            depth,
            zIndex: depth * 100 + 2000,
        };
        this.layers.push(layer);
        return layer;
    }
    releaseLayer(layer) {
        let id;
        if (typeof layer === 'number') {
            id = layer;
        }
        else {
            id = layer.id;
        }
        this.layers = this.layers.filter((l) => l.id !== id);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

class StubAdaptedRouter {
    constructor() {
        this.warningMessage = 'Warning: [RouterContext] there is not Router Adapter provided. StubAdapter is used';
    }
    throwError() {
        if (process.env.NODE_ENV !== 'test') {
            console.error(this.warningMessage);
        }
    }
    getCurrentLink() {
        this.throwError();
        if (process.env.NODE_ENV === 'test') {
            return { pathname: '', query: {} };
        }
        return null;
    }
    redirect() {
        this.throwError();
    }
    transfer() {
        this.throwError();
    }
    isActive() {
        this.throwError();
        return false;
    }
    createHref() {
        this.throwError();
        return '';
    }
    listen() {
        this.throwError();
        return () => { };
    }
    block() {
        this.throwError();
        return () => { };
    }
}

const queryToSearch = (query) => {
    if (!query)
        return '';
    const params = new URLSearchParams();
    Object.keys(query).forEach((key) => {
        if (query[key] === undefined)
            return;
        if (typeof query[key] === 'object') {
            params.set(key, JSON.stringify(query[key]));
        }
        else {
            params.set(key, query[key]);
        }
    });
    return params.toString();
};

const searchToQuery = (search) => {
    const query = {};
    new URLSearchParams(search).forEach((value, key) => {
        if (!value)
            return;
        try {
            query[key] = JSON.parse(decodeURIComponent(value));
        }
        catch (e) {
            query[key] = value;
        }
    });
    return query;
};

class HistoryAdaptedRouter {
    constructor(history) {
        this.history = history;
    }
    getCurrentLink() {
        return HistoryAdaptedRouter.searchToQuery(this.history.location);
    }
    redirect(link) {
        this.history.push(HistoryAdaptedRouter.queryToSearch(link));
    }
    transfer(link) {
        this.history.replace(HistoryAdaptedRouter.queryToSearch(link));
    }
    isActive(link) {
        const current = this.getCurrentLink();
        return current.pathname === link.pathname;
    }
    createHref(link) {
        return this.history.createHref(HistoryAdaptedRouter.queryToSearch(link));
    }
    listen(listener) {
        return this.history.listen(listener);
    }
    block(listener) {
        return this.history.block((location) => {
            listener(location);
            return false;
        });
    }
    static searchToQuery(link) {
        if (link.query !== undefined)
            return link;
        return Object.assign(Object.assign({}, link), { query: searchToQuery(link.search) });
    }
    static queryToSearch(link) {
        if (!link.query)
            return link;
        return Object.assign(Object.assign({}, link), { search: queryToSearch(link.query) });
    }
}

const createHref$1 = (location, basePath) => {
    const { pathname, query } = location;
    const search = new URLSearchParams(query).toString();
    return `${basePath}${pathname}${search ? '?' + search : ''}`;
};
const parseQuery$1 = (link) => {
    const query = {};
    Object.keys(link.query).forEach((key) => {
        const value = link.query[key];
        if (!value)
            return;
        try {
            query[key] = JSON.parse(decodeURIComponent(value));
        }
        catch (e) {
            query[key] = value;
        }
    });
    return Object.assign(Object.assign({}, link), { query });
};
class NextRouterAdapter {
    constructor(router) {
        this.router = router;
        this.handleBeforeHistoryChange = (url, listener) => {
            listener(url);
            if (this.isBlockRun && this.blockedUrl) {
                this.router.events.emit('routeChangeError');
            }
        };
        this.handleRouterChangeError = (listener) => {
            listener(this.blockedUrl);
            throw 'Block history changing';
        };
        this.isBlockRun = false;
        this.blockedUrl = null;
    }
    getCurrentLink() {
        const parsedLink = parseQuery$1({
            pathname: this.router.pathname,
            query: this.router.query,
        });
        return parsedLink;
    }
    parseLinkWithQuery(link) {
        const result = Object.assign(Object.assign({}, link), { search: queryToSearch(link.query) });
        delete result.query;
        return result;
    }
    redirect(link) {
        this.router.push(this.parseLinkWithQuery(link));
        if (this.isBlockRun) {
            this.blockedUrl = link;
        }
    }
    transfer(link) {
        this.router.replace(this.parseLinkWithQuery(link));
        if (this.isBlockRun) {
            this.blockedUrl = link;
        }
    }
    isActive(link) {
        const current = this.getCurrentLink();
        return current.pathname === link.pathname;
    }
    createHref(link) {
        return createHref$1(link, this.router.basePath);
    }
    listen(listener) {
        const localHandler = (url) => this.handleBeforeHistoryChange(url, listener);
        this.router.events.on('beforeHistoryChange', localHandler);
        return () => this.router.events.off('beforeHistoryChange', localHandler);
    }
    block(listener) {
        const localHandler = () => this.handleRouterChangeError(listener);
        this.router.events.on('routeChangeError', localHandler);
        this.isBlockRun = true;
        return () => {
            this.isBlockRun = false;
            this.blockedUrl = null;
            this.router.events.off('routeChangeError', localHandler);
        };
    }
}

const beforeHistoryChangeEvent = 'beforeHistoryChange';
const blockNavigationEvent = 'blockNavigation';
class NextAppRouterAdapter {
    constructor(router) {
        this.router = router;
        this.isBlockRun = false;
    }
    updateURLParams(pathname, searchParams) {
        this.pathaname = pathname;
        this.searchParams = searchParams;
    }
    getCurrentLink() {
        return this.pathaname
            ? parseQuery({
                pathname: this.pathaname,
                query: paramsToQuery(this.searchParams),
            })
            : {
                pathname: '',
                query: {},
            };
    }
    redirect(link) {
        document.dispatchEvent(createBeforeHistoryEvent());
        if (this.isBlockRun) {
            document.dispatchEvent(createBlockNavigationEvent(link));
        }
        else {
            const search = link.search ? '?' + link.search : '';
            this.router.push(link.pathname + search);
        }
    }
    transfer(link) {
        document.dispatchEvent(createBeforeHistoryEvent());
        if (this.isBlockRun) {
            document.dispatchEvent(createBlockNavigationEvent(link));
        }
        else {
            const search = link.search ? '?' + link.search : '';
            this.router.replace(link.pathname + search);
        }
    }
    isActive(link) {
        const current = this.getCurrentLink();
        return current.pathname === link.pathname;
    }
    // See https://nextjs.org/docs/app/api-reference/next-config-js/basePath
    // https://nextjs.org/docs/pages/building-your-application/configuring/environment-variables#bundling-environment-variables-for-the-browser
    createHref(link) {
        return createHref(link, process.env.NEXT_PUBLIC_BASE_PATH || '');
    }
    listen(listener) {
        const onBeforeHistoryChange = (event) => {
            listener(event.detail.link);
        };
        document.addEventListener(beforeHistoryChangeEvent, onBeforeHistoryChange);
        return () => {
            document.removeEventListener(beforeHistoryChangeEvent, onBeforeHistoryChange);
        };
    }
    // adapter state might be invalid in potential edge case like
    // unblocking one form shouldn't unblock another one
    block(listener) {
        const onBlockNavigation = (event) => {
            const payload = event.detail;
            listener(payload.link);
        };
        this.isBlockRun = true;
        document.addEventListener(blockNavigationEvent, onBlockNavigation);
        return () => {
            this.isBlockRun = false;
            document.removeEventListener(blockNavigationEvent, onBlockNavigation);
        };
    }
}
const createBeforeHistoryEvent = () => new CustomEvent(beforeHistoryChangeEvent, {
    detail: {},
});
const createBlockNavigationEvent = (link) => new CustomEvent(blockNavigationEvent, {
    detail: { link },
});
const createHref = (location, basePath) => {
    const { pathname, query } = location;
    const search = new URLSearchParams(query).toString();
    return `${basePath}${pathname}${search ? '?' + search : ''}`;
};
const parseQuery = (link) => {
    const query = {};
    Object.keys(link.query).forEach((key) => {
        const value = link.query[key];
        if (!value)
            return;
        try {
            query[key] = JSON.parse(decodeURIComponent(value));
        }
        catch (e) {
            query[key] = value;
        }
    });
    return Object.assign(Object.assign({}, link), { query });
};
const paramsToQuery = (params) => {
    return params
        ? [...params.entries()].reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
        }, {})
        : {};
};

var Action;
(function (Action) {
    Action["Pop"] = "POP";
    Action["Push"] = "PUSH";
    Action["Replace"] = "REPLACE";
})(Action || (Action = {}));

function mapRouter6ActionToHistory4Action(src) {
    if (src === Action.Pop) {
        return 'POP';
    }
    else if (src === Action.Push) {
        return 'PUSH';
    }
    return 'REPLACE';
}
/**
 * Adds exactly 1 beforeunload event. It is no-op is such event is already added.
 * It's needed to make react-router 6 compatible with "history.block".
 */
function getBeforeUnloadSingletone() {
    const BeforeUnloadEventType = 'beforeunload';
    let _unblockFn;
    return {
        ensureBlock: () => {
            if (_unblockFn) {
                return;
            }
            function promptBeforeUnload(event) {
                // According to the specification, to show the confirmation dialog an event handler should call preventDefault() on the event.
                event.preventDefault();
                event.returnValue = '';
            }
            window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            _unblockFn = function unblockFn() {
                window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
            };
        },
        unblock: () => {
            if (_unblockFn) {
                _unblockFn();
                _unblockFn = undefined;
            }
        },
    };
}
function getRouter6BlockFn(router) {
    let blockerKeyIndex = 0;
    // uui- prefix looks sufficient so that we don't interfere with any internal blockers of router 6.
    const nextBlockerKey = () => `uui-${++blockerKeyIndex}`;
    const beforeUnloadSingletone = getBeforeUnloadSingletone();
    return function router6BlockFn(blockerFunction) {
        const _blockerFn = (params) => {
            blockerFunction(params.nextLocation, mapRouter6ActionToHistory4Action(params.historyAction));
            return true;
            // true means - block navigation.
            // we want to be compatible with the history 5 behavior for "block" as much as possible.
            // I.e.: keep navigation blocked until unblock function is explicitly invoked.
            // https://github.com/remix-run/history/blob/dev/docs/blocking-transitions.md
        };
        const key = nextBlockerKey();
        router.getBlocker(key, _blockerFn);
        beforeUnloadSingletone.ensureBlock();
        return function unblock() {
            router.deleteBlocker(key);
            if (router.state.blockers.size === 0) {
                // keep this singletone as long as there are any blockers
                beforeUnloadSingletone.unblock();
            }
        };
    };
}
function locationToLink(loc) {
    return Object.assign(Object.assign({}, loc), { query: searchToQuery(loc.search) });
}
const withFallback = (v, fallback = '') => typeof v !== 'undefined' ? v : fallback;
function linkToRouter6Dest(link) {
    return {
        to: {
            hash: withFallback(link.hash),
            search: queryToSearch(link.query) || link.search,
            pathname: withFallback(link.pathname),
        },
        state: link.state,
    };
}
function linkToLocation(link) {
    return {
        hash: withFallback(link.hash),
        search: queryToSearch(link.query),
        pathname: withFallback(link.pathname),
        key: withFallback(link.key),
        state: link.state,
    };
}
/**
 *
 * NOTE: Next methods/properties of the router are marked as PRIVATE - DO NOT USE in the https://github.com/remix-run/react-router/blob/main/packages/router/router.ts#L57
 *  - state
 *  - getBlocker
 *  - subscribe
 *  - deleteBlocker
 *  - createHref
 * So we should be extra careful if decide to use another version of the react-router.
 * Though, it's OK to use such API, because there are no alternatives yet (see https://github.com/remix-run/react-router/issues/9422)
 *
 * IMPORTANT: As of now, it was tested only using react-router 6.14.0
 */
class Router6AdaptedRouter {
    constructor(router6) {
        this.router6 = router6;
        this.block = getRouter6BlockFn(this.router6);
    }
    getCurrentLink() {
        return locationToLink(this.router6.state.location);
    }
    redirect(link) {
        // NOTE: navigate is async in the router 6
        if (typeof link === 'string') {
            this.router6.navigate(link);
        }
        else {
            const { to, state } = linkToRouter6Dest(link);
            this.router6.navigate(to, { state });
        }
    }
    transfer(link) {
        // NOTE: it's async in the router 6
        const { to, state } = linkToRouter6Dest(link);
        this.router6.navigate(to, { state, replace: true });
    }
    isActive(link) {
        const current = this.getCurrentLink();
        return current.pathname === link.pathname;
    }
    createHref(link) {
        return this.router6.createHref(linkToLocation(link));
    }
    listen(listener) {
        return this.router6.subscribe((rState) => {
            listener(rState.location);
        });
    }
}

class GAListener {
    constructor(gaCode) {
        this.gaCode = gaCode;
        this.init();
    }
    init() {
        this.addGaScript();
        this.sendToGA('js', new Date());
        this.sendPageView(window.location.pathname);
    }
    addGaScript() {
        window.dataLayer = window.dataLayer || [];
        const gtagScript = document.createElement('script');
        gtagScript.src = `https://www.googletagmanager.com/gtag/js?id=${this.gaCode}`;
        gtagScript.async = true;
        document.head.appendChild(gtagScript);
    }
    sendEvent(event, parameters, eventType) {
        switch (eventType) {
            case 'pageView':
                this.sendPageView(event.path);
                break;
            default:
                this.sendToGA('event', event.name, parameters);
                break;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendToGA(...args) {
        window.dataLayer.push(arguments); // For GA it's important to pass exactly arguments
    }
    sendPageView(path) {
        this.sendToGA('config', this.gaCode, { page_path: path, anonymize_ip: true });
    }
}

class AnalyticsContext extends BaseContext {
    constructor(options) {
        super();
        this.listeners = [];
        this.handleChangeRoute = (location) => {
            if (this.currentLocation !== (location === null || location === void 0 ? void 0 : location.pathname)) {
                this.currentLocation = location === null || location === void 0 ? void 0 : location.pathname;
                this.sendEvent({ path: location === null || location === void 0 ? void 0 : location.pathname, name: 'pageView' }, 'pageView');
            }
        };
        this.router = options.router;
    }
    destroyContext() {
        var _a;
        super.destroyContext();
        if (isClientSide) {
            (_a = this.removeRouteListener) === null || _a === void 0 ? void 0 : _a.call(this);
        }
    }
    init() {
        var _a, _b;
        super.init();
        if (isClientSide) {
            this.currentLocation = (_a = window.location) === null || _a === void 0 ? void 0 : _a.pathname;
            this.removeRouteListener = (_b = this.router) === null || _b === void 0 ? void 0 : _b.listen(this.handleChangeRoute);
        }
    }
    sendEvent(event, eventType = 'event') {
        if (!event)
            return;
        if (this.listeners.length)
            this.listeners.forEach((listener) => listener.sendEvent(event, this.getParameters(event), eventType));
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    getParameters(options) {
        const parameters = Object.assign({}, options);
        delete parameters.name;
        return parameters;
    }
}

function getCookie(name) {
    const matches = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
    return matches ? decodeURIComponent(matches[1]) : undefined;
}
// options - (expires, path, domain, secure)
function setCookie(name, value, options) {
    options = options || {};
    let expires = options.expires;
    if (typeof expires == 'number' && expires) {
        const d = new Date();
        d.setTime(d.getTime() + expires * 1000);
        options.expires = d;
        expires = d;
    }
    if (expires && expires.toUTCString) {
        options.expires = expires.toUTCString();
    }
    value = encodeURIComponent(value);
    let updatedCookie = name + '=' + value;
    for (const propName in options) {
        updatedCookie += '; ' + propName;
        const propValue = options[propName];
        if (propValue !== true) {
            updatedCookie += '=' + propValue;
        }
    }
    document.cookie = updatedCookie;
}
function deleteCookie(name) {
    setCookie(name, '', { expires: -1 });
}

class ApiCallError extends Error {
    constructor(call) {
        super('ApiContext: API call failed');
        this.call = call;
    }
}
class ApiContext extends BaseContext {
    constructor(props, analyticsCtx) {
        var _a, _b, _c;
        super();
        this.props = props;
        this.analyticsCtx = analyticsCtx;
        this.queue = [];
        this.isRunScheduled = false;
        this.status = 'idle';
        this.recoveryReason = null;
        this.handleWindowMessage = (e) => {
            if (e.data === 'authSuccess') {
                this.handleSuccessAuthRecovery();
                e.source.close();
            }
        };
        this.handleStorageUpdate = () => {
            const isRecoverySuccess = window.localStorage.getItem('uui-auth-recovery-success');
            if (isRecoverySuccess === 'true') {
                this.handleSuccessAuthRecovery();
                window.localStorage.removeItem('uui-auth-recovery-success');
            }
        };
        this.handleSuccessAuthRecovery = () => {
            if (this.status === 'recovery' && this.recoveryReason === 'auth-lost') {
                this.setStatus('running');
                this.runQueue();
                this.update({});
            }
        };
        this.defaultParseResponse = (res) => {
            return res.json();
        };
        this.processRequest = (url, method, data, options) => {
            let name = url;
            if (data && data.operationName) {
                name += ' ' + data.operationName;
            }
            options = Object.assign({ errorHandling: 'page', parseResponse: this.defaultParseResponse }, options);
            return new Promise((resolve, reject) => {
                const call = {
                    name,
                    url,
                    method,
                    requestData: data,
                    options,
                    resolve,
                    reject,
                    status: 'scheduled',
                    attemptsCount: 0,
                    dismissError: () => {
                        this.removeFromQueue(call);
                        this.update({});
                    },
                };
                this.queue.push(call);
                this.scheduleRun();
            });
        };
        this.apiReloginPath = (_a = this.props.apiReloginPath) !== null && _a !== void 0 ? _a : '/auth/login';
        this.props.apiPingPath = (_b = this.props.apiPingPath) !== null && _b !== void 0 ? _b : '/auth/ping';
        this.props.apiServerUrl = (_c = this.props.apiServerUrl) !== null && _c !== void 0 ? _c : '';
    }
    init() {
        super.init();
        if (isClientSide) {
            // If we opened another window to relogin and check auth - close this window and resume
            window.addEventListener('message', this.handleWindowMessage);
            window.addEventListener('storage', this.handleStorageUpdate);
        }
    }
    destroyContext() {
        super.destroyContext();
        if (isClientSide) {
            window.removeEventListener('message', this.handleWindowMessage);
        }
    }
    getActiveCalls() {
        return this.queue;
    }
    reset() {
        if (this.status === 'error' || this.status === 'recovery') {
            this.queue = [];
            this.status = 'running';
        }
    }
    setStatus(status, recoveryReason = null) {
        this.status = status;
        this.recoveryReason = recoveryReason;
        this.update({});
    }
    handleApiError(call, reason) {
        var _a;
        const error = new ApiCallError(call);
        if (((_a = call.options) === null || _a === void 0 ? void 0 : _a.errorHandling) === 'manual' && !(reason === 'auth-lost' || reason === 'connection-lost')) {
            this.removeFromQueue(call);
            call.reject(error);
            return;
        }
        if (reason) {
            call.status = 'scheduled';
            if (this.status === 'recovery') {
                return;
            }
            this.setStatus('recovery', reason);
            if (reason === 'auth-lost') {
                window.open(this.apiReloginPath);
            }
            else {
                this.recoverConnection();
            }
        }
        else {
            call.status = 'error';
            this.setStatus('error');
            call.reject(error);
        }
    }
    startCall(call) {
        var _a;
        const fetchOptions = (_a = call.options) === null || _a === void 0 ? void 0 : _a.fetchOptions;
        const headers = new Headers(fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.headers);
        if (!headers.has('Content-Type')) {
            headers.append('Content-Type', 'application/json');
        }
        const csrfCookie = isClientSide && getCookie('CSRF-TOKEN');
        if (csrfCookie) {
            headers.append('X-CSRF-Token', csrfCookie);
        }
        call.attemptsCount += 1;
        call.status = 'running';
        call.startedAt = new Date();
        const fetcher = this.props.fetch || fetch;
        fetcher(this.props.apiServerUrl + call.url, Object.assign(Object.assign({ method: call.method, body: call.requestData && JSON.stringify(call.requestData), credentials: 'include' }, fetchOptions), { headers }))
            .then((response) => {
            this.handleResponse(call, response);
        })
            .catch((e) => {
            if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {
                this.removeFromQueue(call);
                return;
            }
            if (call.attemptsCount < 2) {
                this.handleApiError(call, 'connection-lost');
            }
            else {
                this.handleApiError(call);
            }
        });
    }
    handleResponse(call, response) {
        var _a;
        call.finishedAt = new Date();
        call.httpStatus = response.status;
        if (response.ok) {
            (_a = this.analyticsCtx) === null || _a === void 0 ? void 0 : _a.sendEvent({
                name: 'timing_complete',
                parameters: {
                    value: call.finishedAt.getTime() - call.startedAt.getTime(),
                    name: call.name,
                    event_category: window.location.pathname,
                },
            }, 'apiTiming');
            if (response.status === 204) {
                return this.resolveCall(call, null);
            }
            call.options.parseResponse(response)
                .then((result) => {
                call.responseData = result;
                this.resolveCall(call, result);
            })
                .catch((e) => {
                /* Problem with response JSON parsing */
                call.status = 'error';
                this.setStatus('error');
                call.reject(e);
            });
        }
        else if (
        /* Network and server-related problems. We'll ping the server and then retry the call in this case. */
        (response.status === 408
            || /* Request Timeout */ response.status === 420
            || /* Enhance Your Calm */ response.status === 429
            || /* Too Many Requests */ response.status === 502
            || /* Bad Gateway */ response.status === 503
            || /* Service Unavailable */ response.status === 504)
            && /* Gateway Timeout */ call.attemptsCount < 2 /*
                There can be cases, when server returns some of these states, while /ping works.
                To not enter infinite loop in this case, we limit number of retries.
            */) {
            let reason = 'connection-lost';
            if (response.status === 420 || response.status === 429) {
                reason = 'server-overload';
            }
            if (response.status === 503) {
                reason = 'maintenance';
            }
            this.handleApiError(call, reason);
        }
        else if (response.status === 401) {
            /* Authentication cookies invalidated */ this.handleApiError(call, 'auth-lost');
        }
        else {
            // Try to parse response
            call.options.parseResponse(response)
                .catch(() => null) // Ignore parsing errors
                .then((result) => {
                call.responseData = result;
                this.handleApiError(call);
            });
        }
    }
    removeFromQueue(call) {
        this.queue = this.queue.filter((c) => c !== call);
        if (this.status === 'error' && !this.queue.some((c) => c.status === 'error')) {
            this.setStatus('idle');
            this.runQueue();
        }
    }
    resolveCall(call, result) {
        this.removeFromQueue(call);
        call.resolve(result);
    }
    runQueue() {
        this.isRunScheduled = false;
        if (this.status === 'idle' || this.status === 'running') {
            this.queue.filter((c) => c.status === 'scheduled').forEach((c) => this.startCall(c));
        }
    }
    recoverConnection() {
        const retry = () => setTimeout(() => this.recoverConnection(), 2000);
        const fetcher = this.props.fetch || fetch;
        fetcher(this.props.apiPingPath, {
            method: 'GET',
            credentials: 'include',
        })
            .then((response) => {
            if (response.ok) {
                this.setStatus('running');
                this.runQueue();
                this.update({});
            }
            else {
                retry();
            }
        })
            .catch(retry);
    }
    scheduleRun() {
        if (!this.isRunScheduled) {
            setTimeout(() => this.runQueue(), 0);
            this.isRunScheduled = false;
        }
    }
    uploadFile(url, file, options) {
        const trackProgress = (event) => {
            const progress = +((event.loaded / event.total) * 100).toFixed(2);
            options.onProgress && options.onProgress(progress);
        };
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append('file', file);
            const xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            const csrfCookie = getCookie('CSRF-TOKEN');
            if (csrfCookie) {
                xhr.setRequestHeader('X-CSRF-Token', csrfCookie);
            }
            xhr.withCredentials = true;
            const removeAllListeners = () => {
                xhr.upload.removeEventListener('progress', trackProgress);
                xhr.removeEventListener('abort', removeAllListeners);
            };
            if (options.onProgress) {
                xhr.upload.addEventListener('progress', trackProgress, false);
            }
            if (options.getXHR) {
                xhr.addEventListener('abort', removeAllListeners, false);
                options.getXHR(xhr);
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState !== 4)
                    return;
                let response;
                try {
                    response = JSON.parse(xhr.response);
                }
                catch (_b) {
                    reject({ error: { isError: true, message: 'File upload error' } });
                }
                if (!new RegExp('^2[0-9][0-9]').test(xhr.status.toString())) {
                    reject({ error: { isError: true, message: (_a = response === null || response === void 0 ? void 0 : response.error) === null || _a === void 0 ? void 0 : _a.message } });
                }
                removeAllListeners();
                resolve(response);
            };
            xhr.send(formData);
        });
    }
}

class ErrorContext extends BaseContext {
    constructor(analyticsCtx, modalCtx) {
        super();
        this.analyticsCtx = analyticsCtx;
        this.modalCtx = modalCtx;
        this.currentError = null;
        this.errorCallback = null;
        this.analyticsCtx = analyticsCtx;
    }
    reportError(error) {
        this.currentError = error;
        this.errorCallback && this.errorCallback(error);
        this.update({});
    }
    discardError() {
        this.currentError = null;
    }
    recover() {
        this.discardError();
        this.update({});
    }
    onError(callback) {
        this.errorCallback = callback;
    }
}
class UuiError extends Error {
    constructor(info) {
        super('UUI Error');
        this.info = info;
        this.name = 'UuiError';
        // Set the prototype explicitly.
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, UuiError.prototype);
    }
}

class Lock {
    constructor(tryRelease) {
        this.tryRelease = tryRelease;
    }
}
class LockContext extends BaseContext {
    constructor(router) {
        super();
        this.router = router;
    }
    destroyContext() {
        this.clearLock();
        super.destroyContext();
    }
    acquire(tryRelease) {
        if (this.currentLock) {
            return this.tryRelease().then(() => this.acquire(tryRelease));
        }
        else {
            const lock = new Lock(tryRelease);
            if (isClientSide) {
                this.unblock = this.router.block((location) => {
                    this.routerWillLeave(location);
                });
                this.currentLock = lock;
            }
            else {
                console.warn("An attempt to acquire lock in server side won't have any effect.");
            }
            return Promise.resolve(lock);
        }
    }
    getCurrentLock() {
        return this.currentLock;
    }
    tryRelease() {
        if (this.currentLock) {
            if (this.currentLock.tryRelease) {
                return this.currentLock.tryRelease().then(() => {
                    this.clearLock();
                });
            }
            else {
                this.clearLock();
                return Promise.resolve();
            }
        }
        else {
            return Promise.reject('Current lock is null');
        }
    }
    withLock(action) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.acquire(() => Promise.reject());
            return action().finally(() => this.clearLock());
        });
    }
    routerWillLeave(nextLocation) {
        if (this.currentLock) {
            this.tryRelease()
                .then(() => {
                this.router.redirect(nextLocation);
            })
                .catch(() => { });
        }
    }
    clearLock() {
        var _a;
        this.currentLock = null;
        (_a = this.unblock) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    release(lock) {
        if (lock && this.currentLock === lock) {
            this.clearLock();
        }
        else {
            throw new Error("Attempting to release a lock, which wasn't acquired");
        }
    }
}

let idCounter$1 = 0;
class ModalOperationCancelled {
}
class ModalContext extends BaseContext {
    constructor(layoutCtx) {
        super();
        this.layoutCtx = layoutCtx;
        this.operations = [];
    }
    destroyContext() {
        super.destroyContext();
        this.closeAll();
    }
    show(render, parameters) {
        const ModalAdapter = class extends React.Component {
            render() {
                return render(this.props);
            }
        };
        return this.showModal(ModalAdapter, parameters);
    }
    closeAll() {
        this.operations = [];
        this.update({});
    }
    showModal(component, parameters) {
        const layer = this.layoutCtx.getLayer();
        return new Promise((resolve, reject) => {
            const modalProps = {
                success: (r) => {
                    this.operations.pop();
                    this.layoutCtx.releaseLayer(layer);
                    resolve(r);
                    this.update({});
                },
                abort: (r) => {
                    this.operations.pop();
                    this.layoutCtx.releaseLayer(layer);
                    reject(r ? r : new ModalOperationCancelled());
                    this.update({});
                },
                zIndex: layer.zIndex,
                depth: layer.depth,
                isActive: true,
                key: idCounter$1++ + '',
                parameters,
            };
            const operation = { component, props: modalProps };
            this.operations.push(operation);
            this.update({});
        });
    }
    isModalOperationActive() {
        return this.operations.length > 0;
    }
    getOperations() {
        return this.operations.map((op, n) => (Object.assign(Object.assign({}, op), { props: Object.assign(Object.assign({}, op.props), { isActive: n === this.operations.length - 1 }) })));
    }
}

let idCounter = 0;
class NotificationContext extends BaseContext {
    constructor(layoutCtx) {
        super();
        this.layoutCtx = layoutCtx;
        this.notifications = [];
    }
    destroyContext() {
        this.clearAll();
        super.destroyContext();
    }
    show(render, notificationParams) {
        const NotificationAdapter = class extends React.Component {
            render() {
                return render(this.props);
            }
        };
        const params = Object.assign({ duration: 7, position: 'bot-left' }, notificationParams);
        return new Promise((resolve, reject) => {
            const layer = this.layoutCtx.getLayer();
            let durationTimer;
            const notificationProps = {
                onClose: () => {
                    this.remove(layer.id);
                    this.layoutCtx.releaseLayer(layer);
                    reject();
                    this.update({});
                },
                onSuccess: () => {
                    this.remove(layer.id);
                    this.layoutCtx.releaseLayer(layer);
                    resolve();
                    this.update({});
                },
                clearTimer: () => clearTimeout(durationTimer),
                refreshTimer: () => {
                    if (params.duration !== 'forever') {
                        clearTimeout(durationTimer);
                        durationTimer = setTimeout(() => {
                            notificationProps.onClose();
                        }, params.duration * 1000);
                    }
                },
                id: layer.id,
                key: idCounter++ + '',
            };
            if (params.duration !== 'forever') {
                durationTimer = setTimeout(() => {
                    notificationProps.onClose();
                }, params.duration * 1000);
            }
            const operation = { component: NotificationAdapter, props: notificationProps, config: params };
            this.notifications.push(operation);
            this.update({});
        });
    }
    getNotifications() {
        return this.notifications;
    }
    handleRedirect() {
        this.notifications = [];
    }
    remove(id) {
        this.notifications = this.notifications.filter((i) => {
            if (i.props.id === id) {
                this.layoutCtx.releaseLayer(i.props.id);
                return false;
            }
            return true;
        });
        this.update({});
    }
    clearAll() {
        this.notifications.map((i) => this.layoutCtx.releaseLayer(i.props.id));
        this.notifications = [];
        this.update({});
    }
}

class UserSettingsContext {
    get(key, initial) {
        if (!key) {
            return initial || null;
        }
        const keyStr = JSON.stringify(key);
        const json = window.localStorage.getItem(keyStr);
        if (!json) {
            return initial;
        }
        return JSON.parse(json);
    }
    set(key, value) {
        const keyStr = JSON.stringify(key);
        if (key) {
            window.localStorage.setItem(keyStr, JSON.stringify(value));
        }
    }
}

function createServices(props) {
    const { router, appContext, apiDefinition, apiReloginPath, apiServerUrl, apiPingPath, fetch, } = props;
    const uuiLayout = new LayoutContext();
    const uuiModals = new ModalContext(uuiLayout);
    const uuiNotifications = new NotificationContext(uuiLayout);
    const uuiAnalytics = new AnalyticsContext({ router });
    const uuiLocks = new LockContext(router);
    const uuiErrors = new ErrorContext(uuiAnalytics, uuiModals);
    const uuiApi = new ApiContext({ apiPingPath, apiReloginPath, apiServerUrl, fetch }, uuiAnalytics);
    const rawApi = apiDefinition ? apiDefinition(uuiApi.processRequest.bind(uuiApi)) : {};
    const withOptions = (options) => apiDefinition((url, method, data) => uuiApi.processRequest(url, method, data, options));
    const api = Object.assign(Object.assign({}, rawApi), { withOptions });
    const uuiUserSettings = new UserSettingsContext();
    const uuiDnD = new DndContext();
    const services = {
        uuiAnalytics,
        uuiErrors,
        uuiApi,
        api,
        uuiLayout,
        uuiNotifications,
        uuiModals,
        uuiUserSettings,
        uuiDnD,
        uuiRouter: router,
        uuiLocks,
        uuiApp: appContext || {},
    };
    return {
        services,
        destroyServices: () => {
            uuiAnalytics.destroyContext();
            uuiErrors.destroyContext();
            uuiApi.destroyContext();
            uuiLayout.destroyContext();
            uuiNotifications.destroyContext();
            uuiModals.destroyContext();
            uuiDnD.destroyContext();
            uuiLocks.destroyContext();
        },
        init: () => {
            uuiAnalytics.init();
            uuiErrors.init();
            uuiApi.init();
            uuiLayout.init();
            uuiNotifications.init();
            uuiModals.init();
            uuiDnD.init();
            uuiLocks.init();
        },
    };
}
const useUuiServices = (props) => {
    const [result] = useState(() => createServices(props));
    // Workaround to discard all errors on navigation. Need to find a better way. YakovZh
    result.services.uuiErrors.discardError();
    result.services.uuiApi.reset();
    useEffect(() => {
        result.init();
        window.UUI_VERSION = "5.9.1"; // it replaced with current uui version during build time
        return () => {
            result.destroyServices();
        };
    }, []);
    return { services: result.services };
};

function ContextProvider(props) {
    const [isLoaded, setIsLoaded] = useState(false);
    const { loadAppContext, onInitCompleted, children: propsChildren, history, gaCode } = props, restProps = __rest(props, ["loadAppContext", "onInitCompleted", "children", "history", "gaCode"]);
    const router = !!history ? new HistoryAdaptedRouter(history) : new StubAdaptedRouter();
    const { services } = useUuiServices(Object.assign(Object.assign({}, restProps), { router }));
    services.history = history;
    useEffect(() => {
        const loadAppContextPromise = loadAppContext || (() => Promise.resolve({}));
        gaCode && services.uuiAnalytics.addListener(new GAListener(gaCode));
        loadAppContextPromise(services.api).then((appCtx) => {
            services.uuiApp = appCtx;
            onInitCompleted(services);
            setIsLoaded(true);
        });
    }, []);
    const children = isLoaded ? propsChildren : '';
    return (React__default.createElement(UuiContext.Provider, { value: services },
        children,
        React__default.createElement(DragGhost, null)));
}
function useUuiContext() {
    const context = useContext(UuiContext);
    if (!Object.keys(context).length) {
        throw new Error('useUuiContext must be called within UuiContextProvider');
    }
    return context;
}

const defaultDelay = 500;
const IEditableDebouncerImpl = (props) => {
    var _a;
    const [state, setState] = useState({ value: props.value });
    const lastSentValue = useRef(props.value);
    const context = useUuiContext();
    useEffect(() => {
        if ((props.value !== lastSentValue.current)) {
            setState({ value: props.value });
            lastSentValue.current = props.value;
        }
    }, [props.value]);
    const debouncedOnValueChange = useMemo(() => {
        return debounce((value) => {
            lastSentValue.current = value;
            props.onValueChange(value);
            if (props.getValueChangeAnalyticsEvent) {
                const event = props.getValueChangeAnalyticsEvent(value, props.value);
                context.uuiAnalytics.sendEvent(event);
            }
        }, props.debounceDelay != null ? props.debounceDelay : defaultDelay, { leading: false, trailing: true });
    }, [
        props.onValueChange, props.getValueChangeAnalyticsEvent, props.debounceDelay, props.value,
    ]);
    const handleValueChange = useCallback((newValue) => {
        setState({ value: newValue });
        if (props.disableDebounce) {
            props.onValueChange(newValue);
        }
        else {
            debouncedOnValueChange(newValue);
        }
    }, [
        props.disableDebounce, props.onValueChange, debouncedOnValueChange,
    ]);
    const propsToRender = useMemo(() => ({
        value: state.value,
        onValueChange: handleValueChange,
    }), [state.value, handleValueChange]);
    return (_a = props.render) === null || _a === void 0 ? void 0 : _a.call(props, propsToRender);
};
/**
 * Wrap other IEditable components into the IEditableDebouncer to debounce onValueChange calls.
 * Useful for search inputs, or any other components that cause expensive computations on change.
 * Wrapped component still behaves as controlled component, and will react to external value changes immediately.
 */
const IEditableDebouncer = /* @__PURE__ */React__default.memo(IEditableDebouncerImpl);

const base = 26;
const memoized = [];
/**
 * Computes order string from integer item index in a sequence.
 * Useful for creating initial orders of items, which can be later manipulated with getOrderBetween to insert or move items.
 * @param input integer order of item
 * @returns order string
 */
function indexToOrder(input) {
    const existing = memoized[input];
    if (existing) {
        return existing;
    }
    const aChar = 97;
    const digits = [];
    let lastInputValue = input;
    while (lastInputValue > 0) {
        digits.unshift((lastInputValue % base) + aChar);
        lastInputValue = Math.floor(lastInputValue / base);
    }
    const order = String.fromCharCode(
    // Put number of digits first, to establish order between numbers
    // of different length (the longer is bigger)
    // We add '+ 1' is to start number of digits from 'b'
    // to leave room to insert orders before numberToOrder(0), w/o using digits.
    digits.length + aChar + 1, ...digits);
    memoized[input] = order;
    return order;
}
const minOrderStr = 'a';
const maxOrderStr = 'zzzz';
/**
 * Calculates a string, which is between two strings, if strings are sorted in alphabetic order.
 *
 * Examples:
 *
 *  - 'a', 'z' => 's'
 *  - 'a', 'b' => 'as'
 *  - 'as, 'b' => 'au'
 *  - 'aa, 'ab' => 'aas' // there's no precision limit
 *  - null, 'c' => 'b' // insert first
 *  - 'c', null => 'u' // insert last
 *
 * This approach allows to add order to arbitrary list of items.
 *
 * Any item can be moved to any place in the list by modifying only one attribute. So:
 * - you can save only moved item(s) to server, not the whole list
 * - you can store items in any suitable structure, e.g. - Map<id, Item>, instead of plain arrays
 * - server can trivially update items, as usual fields
 * - server can sort items as well - we use only ASCII 0-9 and a-z, to there's no collation issues
 * - it's better than using integer numbers: no need to renumber items in case you need to insert an item between 1 and 2
 * - it's better than using floats: they can have limited precision, which can lead to complicated issues
 *
 * The function implements a basic average of 2 numbers: (a + b)/2, interpreting strings as fractional part of base-36 number.
 *
 * Read more [here](https://uui.epam.com/documents?id=dragAndDrop&mode=doc&skin=UUI4_promo&category=advanced)
 * @param inputA order string before (can be start for the start of the list)
 * @param inputB order string after (can be null for the end of the list)
 * @returns order string between inputA and inputB
 */
function getOrderBetween(inputA, inputB) {
    const radix = 36;
    let a = inputA;
    const b = inputB || 'z';
    if (!a) {
        // We were generating chars 0-z prior. Now we try yo use only a-z.
        // This is done to avoid issues with string sort/compare algorithms (e.g. Intl.Collator().compare we use in DataSources),
        // which compare number so '1' < '10', and we rely on plain char-by-char comparators.
        // However, there's no options to generate value less than 'a' w/o digits.
        // This can happen for already generated orders.
        a = (b <= 'a') ? '0' : 'a';
    }
    const throwError = () => {
        throw new Error(`getOrderBetween: can't find values between ${inputA} and ${inputB}`);
    };
    if (a >= b) {
        throwError();
    }
    let result = '';
    let n = 0;
    // If we see two close chars, like 'a' and 'b' or '1' and '2' - we can't fit another
    // char between them at this position.
    // However, this means that A is already less than B, and we
    // can use this when comparing next positions.
    let resultIsLessThanB = false;
    while (true) {
        const aChar = a[n];
        // If result < B according to prior chars, any letter greater than aChar will be ok
        const bChar = resultIsLessThanB ? 'z' : b[n];
        let aDigit = parseInt(aChar || '0', radix);
        const bDigit = parseInt(bChar || 'z', radix);
        // We were generating chars 0-z, however now we try to use a-z if possible.
        // Unfortunately, it's not possible, if order already contains digits.
        if (bDigit > 10) {
            aDigit = Math.max(10, aDigit);
        }
        const midDigit = Math.floor((aDigit + bDigit) / 2);
        result += midDigit.toString(radix);
        if (aDigit !== midDigit) {
            break;
        }
        if (aDigit < bDigit) {
            resultIsLessThanB = true;
        }
        n++;
    }
    return result;
}

function isUrl(url) {
    const expression = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi;
    const regex = new RegExp(expression);
    return !!url.match(regex);
}
function prependHttp(url, options) {
    if (typeof url !== 'string') {
        throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof url}\``);
    }
    url = url.trim();
    if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
        return url;
    }
    return url.replace(/^(?!(?:\w+:)?\/\/)/, options.https ? 'https://' : 'http://');
}

const eqPredicate = () => 0;
// Previous versions use this comparer. While it works great for human-readable strings, it's broken for dates. Also, we need a plain sort in case of 'order' fields.
// const compareScalars = (new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'})).compare;
function compareScalars(a, b, order) {
    if (a == null) {
        if (b == null) {
            return 0;
        }
        return -order;
    }
    if (b == null)
        return order;
    if (a < b)
        return -order;
    if (a === b)
        return 0;
    return order;
}
function getOrderComparer(sorting) {
    if (!sorting || sorting.length === 0) {
        return eqPredicate;
    }
    const sortingOrders = sorting.map((s) => (s.direction === 'desc' ? -1 : 1));
    const comparer = (a, b) => {
        for (let n = 0; n < sorting.length; n++) {
            const fieldName = sorting[n].field;
            const compareResult = compareScalars(a[fieldName], b[fieldName], sortingOrders[n]);
            if (compareResult !== 0) {
                return compareResult;
            }
        }
        return 0;
    };
    return comparer;
}

/**
 * Function, which orders array of items by criteria in some direction.
 * @param arr - list of items to be ordered.
 * @param by - criteria of ordering.
 * @param order - direction of ordering. Default: 'asc'.
 * @returns - array of data, ordered by criteria.
 */
function orderBy(arr, by, order = 'asc') {
    const sortedArr = [...arr];
    const sign = order === 'desc' ? -1 : 1;
    return sortedArr.sort((a, b) => {
        const aBy = by(a);
        const bBy = by(b);
        return compareScalars(aBy, bBy, sign);
    });
}

const applyColumnsConfig = (columns, config) => {
    const newColumns = columns.reduce((acc, c) => {
        const restColumnProps = __rest(c, ["fix", "width"]);
        const cfg = config[c.key];
        cfg.isVisible
            && acc.push(Object.assign(Object.assign(Object.assign({}, restColumnProps), { width: cfg.width }), (cfg.fix ? { fix: cfg.fix } : {})));
        return acc;
    }, []);
    return orderBy(newColumns, (i) => config[i.key].order);
};
const getColumnsConfig = (columns, config) => {
    var _a;
    const resultConfig = {};
    const sortedOrders = orderBy(Object.values(config !== null && config !== void 0 ? config : {}).filter(Boolean), (f) => f.order);
    const lastItemOrder = (sortedOrders === null || sortedOrders === void 0 ? void 0 : sortedOrders.length) ? (_a = sortedOrders[sortedOrders.length - 1]) === null || _a === void 0 ? void 0 : _a.order : null;
    let prevOrder = lastItemOrder || 'a';
    columns.forEach((column) => {
        var _a;
        const hasPrevColumnConfig = !!(config === null || config === void 0 ? void 0 : config[column.key]);
        if (hasPrevColumnConfig) {
            resultConfig[column.key] = config === null || config === void 0 ? void 0 : config[column.key];
        }
        else {
            const order = getOrderBetween(prevOrder, null);
            resultConfig[column.key] = {
                width: column.width,
                fix: (_a = column.fix) !== null && _a !== void 0 ? _a : (column.isAlwaysVisible ? 'left' : undefined),
                isVisible: !column.isHiddenByDefault,
                order: order,
            };
            prevOrder = order;
        }
    });
    return resultConfig;
};

function formatBytes(bytes, decimals = 2, withSizes = true) {
    if (bytes === 0)
        return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = [
        'Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB',
    ];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    const numbersResult = parseFloat((bytes / Math.pow(k, i)).toFixed(dm));
    return withSizes ? `${numbersResult} ${sizes[i]}` : `${numbersResult}`;
}

const getMinMaxValidatedValue = ({ value, min = 0, max = Number.MAX_SAFE_INTEGER }) => {
    if (value > max) {
        return max;
    }
    else if (value < min) {
        return min;
    }
    else {
        return value;
    }
};
const getCalculatedValue = ({ value: initialValue, step = 1, action = 'incr' }) => {
    const value = initialValue || 0;
    const valueDecimalLength = getDecimalLength(value);
    const stepDecimalLength = getDecimalLength(step);
    const decimalLength = valueDecimalLength >= stepDecimalLength ? valueDecimalLength : stepDecimalLength;
    let adjustedValue = value;
    switch (action) {
        case 'decr':
            adjustedValue = value - step;
            break;
        case 'incr':
            adjustedValue = value + step;
            break;
        default:
            return 0;
    }
    return Number(adjustedValue.toFixed(decimalLength));
};
const getDecimalLength = (value) => {
    const splitedValue = String(value).split('.');
    if (splitedValue.length === 1)
        return 0;
    return splitedValue[1].length;
};
const getSeparatedValue = (value, formatOptions = {}, locale) => {
    if (!value && value !== 0)
        return null;
    return value.toLocaleString(locale, formatOptions);
};

const isMobile = (screenWidth = 720) => {
    var _a;
    return isClientSide && ((_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, `screen and (max-width: ${screenWidth}px)`).matches);
};
const mobilePopperModifier = {
    name: 'computeStyles',
    options: {
        roundOffsets: ({ x, y }) => ({
            x: isMobile() ? 0 : x,
            y: isMobile() ? 0 : y,
        }),
    },
};

var MsgLevel;
(function (MsgLevel) {
    MsgLevel["error"] = "error";
    MsgLevel["warn"] = "warn";
    MsgLevel["log"] = "log";
})(MsgLevel || (MsgLevel = {}));
function getCurrentStack(cutItems = 0) {
    let stack = new Error().stack;
    if (cutItems > 0) {
        const rest = stack.slice(1).split('\n');
        stack = rest.slice(cutItems).join('\n');
    }
    return stack;
}
function getKey(msg, args) {
    return msg + args.join();
}
class UuiLogger {
    constructor() {
        this.msgHistory = {};
        this.msgAddToHistory = (msg, args) => {
            this.msgHistory[getKey(msg, args)] = true;
        };
        this.msgIsAlreadyLogged = (msg, args) => {
            const isNew = !this.msgHistory[getKey(msg, args)];
            return !isNew;
        };
        this.addToLog = (severity, msg, args) => {
            if (this.msgIsAlreadyLogged(msg, args)) {
                return;
            }
            this.msgAddToHistory(msg, args);
            let method = console[severity];
            // @ts-ignore
            const origMethodReplaced = method.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__;
            if (origMethodReplaced) {
                method = origMethodReplaced;
            }
            method(msg, ...args);
        };
        /**
         * Logs warning to console in development mode. Has no effect in production mode.
         *
         * @param msg
         * @param args
         */
        this.warn = (msg, ...args) => {
            if (process.env.NODE_ENV !== "production") {
                const stack = getCurrentStack(3);
                this.addToLog(MsgLevel.error, `[UUI Warning]: ${msg}\n\n%s`, [...args, stack]);
            }
        };
        /**
         * Logs warning to console in development mode. Has no effect in production mode.
         * @param props
         */
        this.warnAboutDeprecatedPropValue = (props) => {
            const { propName, propValue, propValueUseInstead, condition, component, } = props;
            const shouldWarn = condition ? condition() : true;
            if (shouldWarn) {
                const comp = component ? `(${component}) ` : '';
                const instead = propValueUseInstead ? `Please use ${propValueUseInstead} value instead.` : '';
                this.warn(`${comp}The ${propValue} value of ${String(propName)} is deprecated and will be removed in future versions. ${instead}`);
            }
        };
    }
}
const devLogger = new UuiLogger();

const clearEmptyValueFromRecord = (record) => {
    if (record === undefined || record === null || typeof record !== 'object') {
        return record;
    }
    return Object.keys(record).reduce((acc, key) => {
        let newAcc = acc;
        if (record[key] !== undefined) {
            if (!newAcc) {
                newAcc = {};
            }
            newAcc[key] = record[key];
        }
        return newAcc;
    }, undefined);
};

function createSkinComponent(Component, getProps, getCx) {
    return withMods(Component, getCx, getProps);
}

function rangeFromTo(start, end, step) {
    const defaultStepForRange = (end >= start) ? 1 : -1;
    return Array.from({ length: (end - start) / (step || defaultStepForRange) }, (_, index) => {
        if (step === 0) {
            return 1;
        }
        return start + (index * (step !== null && step !== void 0 ? step : defaultStepForRange));
    });
}
/**
 * Factory of numeric sequences with the exact step.
 * @param start - a start number of the sequence inclusively.
 * @param end - an end number of the sequence exclusively.
 * @param step - step of the progression. Defaults:
 * - if start <= end, step = 1
 * - if start > end, step = -1.
 * @returns a sequence of numbers in progression, described by bounds with a specific step.
 */
function range(start, end, step) {
    if (end === undefined) {
        return rangeFromTo(0, start, step);
    }
    return rangeFromTo(start, end, step);
}

const uuiContextTypes = {
    uuiAnalytics: PropTypes.object,
    uuiErrors: PropTypes.object,
    uuiApi: PropTypes.object,
    uuiModals: PropTypes.object,
    uuiNotifications: PropTypes.object,
    api: PropTypes.object,
    uuiUserSettings: PropTypes.object,
    uuiDnD: PropTypes.object,
    uuiApp: PropTypes.object,
    uuiRouter: PropTypes.object,
    uuiLayout: PropTypes.object,
    uuiLocks: PropTypes.object,
    history: PropTypes.object,
    uuiSkin: PropTypes.object,
};

const CascadeSelectionTypes = {
    IMPLICIT: 'implicit',
    EXPLICIT: 'explicit',
};

/* eslint-disable no-restricted-imports */
const uuiDayjs = /* @__PURE__ */TREE_SHAKEABLE_INIT();
function TREE_SHAKEABLE_INIT() {
    let extended = false;
    return {
        get dayjs() {
            if (!extended) {
                dayjs.extend(isSameOrBefore);
                dayjs.extend(isSameOrAfter);
                extended = true;
            }
            return dayjs;
        },
    };
}

function simplifyPredicates(filter) {
    if (!filter) {
        return {};
    }
    const result = filter;
    const keys = Object.keys(filter);
    for (let n = 0; n < keys.length; n++) {
        const key = keys[n];
        const condition = filter[key];
        if (condition != null && typeof condition === 'object') {
            if ('inRange' in condition) {
                const value = condition.inRange;
                result[key] = {
                    gte: value.from,
                    lte: value.to,
                };
            }
            if ('notInRange' in condition) {
                const value = condition.notInRange;
                result[key] = {
                    not: {
                        gte: value.from,
                        lte: value.to,
                    },
                };
            }
            if (Array.isArray(condition)) {
                result[key] = {
                    in: condition,
                };
            }
        }
    }
    return result;
}
function isDate(val) {
    return uuiDayjs.dayjs(val).isValid();
}
const truePredicate = () => true;
function getFilterPredicate(filter) {
    filter = simplifyPredicates(filter);
    if (filter == null) {
        return truePredicate;
    }
    const predicates = [];
    const keys = Object.keys(filter);
    for (let n = 0; n < keys.length; n++) {
        const key = keys[n];
        const condition = filter[key];
        if (condition != null && typeof condition === 'object') {
            if ('isNull' in condition) {
                if (condition.isNull) {
                    predicates.push((item) => item[key] == null);
                }
                else {
                    predicates.push((item) => item[key] != null);
                }
            }
            if ('in' in condition && Array.isArray(condition.in)) {
                const values = condition.in;
                predicates.push((item) => values.includes(item[key]));
            }
            if ('nin' in condition && Array.isArray(condition.nin)) {
                const values = condition.nin;
                predicates.push((item) => !values.includes(item[key]));
            }
            if (condition.gte != null) {
                const conditionValue = condition.gte;
                predicates.push((item) => {
                    const value = item[key];
                    if (typeof value === 'string' && isDate(conditionValue)) {
                        return uuiDayjs.dayjs(value).isSameOrAfter(conditionValue);
                    }
                    return !(value !== null && value !== undefined) || value >= conditionValue;
                });
            }
            if (condition.lte != null) {
                const conditionValue = condition.lte;
                predicates.push((item) => {
                    const value = item[key];
                    if (typeof value === 'string' && isDate(conditionValue)) {
                        return uuiDayjs.dayjs(value).isSameOrBefore(conditionValue);
                    }
                    return !(value !== null && value !== undefined) || value <= conditionValue;
                });
            }
            if (condition.gt != null) {
                const conditionValue = condition.gt;
                predicates.push((item) => {
                    const value = item[key];
                    if (typeof value === 'string' && isDate(conditionValue)) {
                        return uuiDayjs.dayjs(value).isAfter(conditionValue);
                    }
                    return !(value !== null && value !== undefined) || value > conditionValue;
                });
            }
            if (condition.lt != null) {
                const conditionValue = condition.lt;
                predicates.push((item) => {
                    const value = item[key];
                    if (typeof value === 'string' && isDate(conditionValue)) {
                        return uuiDayjs.dayjs(value).isBefore(conditionValue);
                    }
                    return !(value !== null && value !== undefined) || value < conditionValue;
                });
            }
            if (condition.eq !== undefined && condition.eq !== null) {
                const conditionValue = condition.eq;
                predicates.push((item) => item[key] === conditionValue);
            }
            if (condition.neq !== undefined && condition.neq !== null) {
                const conditionValue = condition.neq;
                predicates.push((item) => item[key] !== conditionValue);
            }
            if ('not' in condition) {
                const predicate = getFilterPredicate({ [key]: condition.not });
                predicates.push((i) => !predicate(i));
            }
        }
        else {
            predicates.push((item) => {
                if (typeof condition === 'string' && isDate(condition)) {
                    return uuiDayjs.dayjs(item[key]).isSame(condition);
                }
                else {
                    return item[key] === condition;
                }
            });
        }
    }
    if (predicates.length === 1) {
        return predicates[0];
    }
    else if (predicates.length === 0) {
        return truePredicate;
    }
    else {
        return (item) => {
            for (let n = 0; n < predicates.length; n++) {
                if (!predicates[n](item)) {
                    return false;
                }
            }
            return true;
        };
    }
}

const getRank = (match) => {
    const [word] = match;
    const { index, input } = match;
    if (index === 0) {
        return word.length === input.length || input[index + word.length] === ' ' ? 4 : 3;
    }
    return input[index - 1] === ' ' ? 2 : 1;
};
function getSearchFilter(searchString) {
    if (!searchString) {
        return () => true;
    }
    const searchStr = searchString.replace(/[\s\n\r\t\0]+/g, ' ').trim(); // trim and normalize whitespaces
    // split by comma-separated groups, then by spaces, and make regex of each word
    const words = searchStr
        .split(' ')
        .map((word) => word.trim())
        .filter((s) => s.length > 0)
        .map((word) => word.trim().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')) // esape regex characters inside the string
        .map((word) => new RegExp(word, 'i'));
    return (texts) => {
        if (!words.length) {
            return true;
        }
        const ranks = words.map((wordRegex) => {
            // matching regex word with fields values
            const wordRanks = texts.map((text) => {
                const match = text.match(wordRegex);
                if (match === null) {
                    return null;
                }
                return getRank(match);
            });
            // if keyword was not found in every field value
            if (wordRanks.every((rank) => rank === null)) {
                return false;
            }
            return Math.max(...wordRanks);
        });
        // some keyword of a group was not found in fields values
        if (ranks.some((rank) => !rank)) {
            return false;
        }
        return ranks.reduce((totalRank, rank) => totalRank + rank, 0);
    };
}

function runDataQuery(allItems, request, searchBy) {
    let items = allItems || [];
    request = request || {};
    if (request.ids) {
        return {
            items: items.filter((i) => request.ids.includes(i.id)),
        };
    }
    if (request.search) {
        searchBy = searchBy || ((i) => [i.name]);
        const searchFilter = getSearchFilter(request.search);
        items = items.filter((item) => searchFilter(searchBy(item)));
    }
    if (request.filter) {
        const predicate = getFilterPredicate(request.filter);
        items = items.filter(predicate);
    }
    if (request.sorting) {
        const comparer = getOrderComparer(request.sorting);
        items.sort(comparer);
    }
    else {
        items = orderBy(items, ({ name }) => name);
    }
    const filteredAndSorted = items;
    if (request.range) {
        const from = request.range.from || 0;
        const count = request.range.count == null ? items.length : request.range.count;
        items = items.slice(from, from + count);
    }
    return {
        items,
        count: filteredAndSorted.length,
    };
}

/**
 * Hook, which returns previous version of the value, passed to the arguments.
 * @param value
 * @param config - Hook configuration, which defines if previous value will be deeply compared with new value to be saved or not.
 * @param config.compare - If compare is set to true, previous value will be deeply compared with the new value,
 * and previous value will be updated only if value is changed (not the link to the object). Otherwise, previous value will be returned.
 * If compare is false, previous value will be changed on every rerender.
 * @returns previous version of the value, passed to the props.
 */
function usePrevious(value, { compare } = {}) {
    const previousValueRef = useRef(null);
    useEffect(() => {
        if (compare) {
            if (!isEqual(previousValueRef.current, value)) {
                previousValueRef.current = value;
            }
        }
        else {
            previousValueRef.current = value;
        }
    }, [value]);
    return previousValueRef.current;
}

function cloneMap(map) {
    return new map.constructor(map);
}
function newMap(params) {
    if (params.complexIds) {
        return new CompositeKeysMap();
    }
    else {
        return new Map();
    }
}
class CompositeKeysMap {
    constructor(original) {
        if (original) {
            this.map = new Map(original.map);
        }
        else {
            this.map = new Map();
        }
    }
    keyToString(key) {
        return key === undefined ? undefined : JSON.stringify(key);
    }
    get(key) {
        return this.map.get(this.keyToString(key));
    }
    set(key, value) {
        this.map.set(this.keyToString(key), value);
        return this;
    }
    delete(key) {
        return this.map.delete(this.keyToString(key));
    }
    *[Symbol.iterator]() {
        for (const [key, value] of this.map) {
            yield [key !== undefined ? JSON.parse(key) : undefined, value];
        }
    }
    has(key) {
        return this.map.has(this.keyToString(key));
    }
    get size() {
        return this.map.size;
    }
}

const ROOT_ID = undefined;
// ITreeNodeStatus
const PARTIALLY_LOADED = 'PARTIALLY_LOADED';
const FULLY_LOADED = 'FULLY_LOADED';
const EMPTY = 'EMPTY';
// RecordStatus && not found item in tree
const NOT_FOUND_RECORD = Symbol('NOT_FOUND_RECORD');
// RecordStatus
const PENDING_RECORD = Symbol('PENDING_RECORD');
const LOADING_RECORD = Symbol('LOADING_RECORD');
const LOADED_RECORD = Symbol('LOADED_RECORD');
const FAILED_RECORD = Symbol('FAILED_RECORD');
const PatchOrdering = {
    TOP: Symbol('ORDERING_TOP'),
    BOTTOM: Symbol('ORDERING_BOTTOM'),
};

class ItemsAccessor {
    constructor(itemsMap) {
        this.itemsMap = itemsMap;
        this.get = (id) => this.itemsMap.has(id) ? this.itemsMap.get(id) : NOT_FOUND_RECORD;
    }
    forEach(action) {
        this.itemsMap.forEach(action);
    }
    static toItemsAccessor(itemsMap) {
        return new ItemsAccessor(itemsMap);
    }
}

const getSelectedAndChecked = (dataSourceState, patch) => {
    var _a;
    let checked = [];
    if ((_a = dataSourceState.checked) === null || _a === void 0 ? void 0 : _a.length) {
        checked = [...dataSourceState.checked];
    }
    if (dataSourceState.selectedId !== null && dataSourceState.selectedId !== undefined) {
        checked = [...checked, dataSourceState.selectedId];
    }
    if (!patch || !patch.size) {
        return checked;
    }
    return checked.filter((id) => !patch.has(id));
};

class FetchingHelper {
    static loadAll(_a) {
        return __awaiter(this, arguments, void 0, function* ({ treeStructure, itemsMap, options, dataSourceState, }) {
            const response = yield options.api({
                sorting: dataSourceState.sorting,
                search: dataSourceState.search,
                filter: options.filter,
                page: dataSourceState.page,
                pageSize: dataSourceState.pageSize,
            });
            const newItemsMap = itemsMap.clear().setItems(response.items);
            return {
                itemsMap: newItemsMap,
                treeStructure: TreeStructure.createFromItems({
                    params: treeStructure.getParams(),
                    items: response.items,
                    itemsAccessor: ItemsAccessor.toItemsAccessor(newItemsMap),
                }),
                loadedItems: response.items,
            };
        });
    }
    static load(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, options, dataSourceState, patch, }) {
            const { loadedItems: loadedMissingItems, loadedItemsMap, byParentId, nodeInfoById } = yield this.loadMissing({
                tree,
                options,
                dataSourceState,
            });
            const missing = getSelectedAndChecked(dataSourceState, patch);
            const { loadedItems: loadedMissingItemsAndParents } = yield this.loadMissingItemsAndParents({
                tree,
                newItemsMap: loadedItemsMap,
                options,
                itemsToLoad: missing,
            });
            return {
                loadedItems: loadedMissingItems.concat(loadedMissingItemsAndParents),
                byParentId,
                nodeInfoById,
            };
        });
    }
    static loadMissing(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, options, dataSourceState, }) {
            var _b;
            const requiredRowsCount = dataSourceState.topIndex + dataSourceState.visibleCount;
            const byParentId = newMap(tree.getParams());
            const nodeInfoById = newMap(tree.getParams());
            const newItemsMap = newMap(tree.getParams());
            const flatten = dataSourceState.search && options.flattenSearchResults;
            const loadAllChildren = (_b = options.loadAllChildren) !== null && _b !== void 0 ? _b : (() => ({ nestedChildren: true, children: false }));
            let newItems = [];
            const loadRecursive = (parentId_1, parent_1, _c, remainingRowsCount_1) => __awaiter(this, [parentId_1, parent_1, _c, remainingRowsCount_1], void 0, function* (parentId, parent, { children: parentLoadAllChildren, nestedChildren: parentLoadAllNestedChildren }, remainingRowsCount) {
                let recursiveLoadedCount = 0;
                const { ids, nodeInfo, loadedItems } = yield this.loadItems({
                    tree,
                    byParentId,
                    options,
                    parentId,
                    parent,
                    dataSourceState,
                    remainingRowsCount,
                    loadAll: parentLoadAllChildren,
                });
                const _d = tree.getItems(parentId), { ids: originalIds } = _d, originalNodeInfo = __rest(_d, ["ids"]);
                const currentIds = byParentId.has(parentId) ? byParentId.get(parentId) : originalIds;
                if (ids !== currentIds
                    || nodeInfo.count !== originalNodeInfo.count
                    || nodeInfo.totalCount !== originalNodeInfo.totalCount
                    || nodeInfo.assumedCount !== originalNodeInfo.assumedCount) {
                    nodeInfoById.set(parentId, nodeInfo);
                }
                byParentId.set(parentId, ids);
                recursiveLoadedCount += ids.length;
                if (loadedItems.length > 0) {
                    loadedItems.forEach((item) => {
                        var _a, _b, _c, _d;
                        const id = tree.getParams().getId(item);
                        const prevNodeInfo = (_a = nodeInfoById.get(id)) !== null && _a !== void 0 ? _a : {};
                        const assumedCount = flatten ? undefined : (_b = prevNodeInfo.assumedCount) !== null && _b !== void 0 ? _b : (_d = (_c = tree.getParams()).getChildCount) === null || _d === void 0 ? void 0 : _d.call(_c, item);
                        nodeInfoById.set(id, Object.assign(Object.assign({}, prevNodeInfo), (tree.getParams().getChildCount ? { assumedCount } : {})));
                        newItemsMap.set(id, item);
                    });
                    newItems = newItems.concat(loadedItems);
                }
                if (!flatten && tree.getParams().getChildCount) {
                    const childrenPromises = [];
                    for (let n = 0; n < ids.length; n++) {
                        const id = ids[n];
                        const itemInTree = tree.getById(id);
                        let item = itemInTree === NOT_FOUND_RECORD ? undefined : itemInTree;
                        if (newItemsMap.has(id)) {
                            item = newItemsMap.get(id);
                        }
                        let isFolded = false;
                        let hasChildren = false;
                        if (tree.getParams().getChildCount) {
                            // not a root node
                            const childrenCount = tree.getParams().getChildCount(item);
                            if (childrenCount) {
                                // foldable
                                isFolded = options.isFolded(item);
                                hasChildren = true;
                            }
                        }
                        const { nestedChildren, children } = loadAllChildren(id);
                        const shouldLoadAllChildren = hasChildren && children;
                        const loadAll = parentLoadAllNestedChildren ? parentLoadAllChildren || shouldLoadAllChildren : shouldLoadAllChildren;
                        remainingRowsCount--;
                        if (hasChildren && ((!isFolded && remainingRowsCount > 0) || loadAll)) {
                            const childPromise = loadRecursive(id, item, { children: loadAll, nestedChildren }, remainingRowsCount);
                            childrenPromises.push(childPromise);
                            if (options.fetchStrategy === 'sequential') {
                                const loadedCount = yield childPromise;
                                remainingRowsCount -= loadedCount;
                                recursiveLoadedCount += loadedCount;
                            }
                        }
                    }
                    const childCounts = yield Promise.all(childrenPromises);
                    if (options.fetchStrategy === 'parallel') {
                        const recursiveChildrenCount = childCounts.reduce((a, b) => a + b, 0);
                        recursiveLoadedCount += recursiveChildrenCount;
                        remainingRowsCount -= recursiveChildrenCount;
                    }
                }
                return recursiveLoadedCount;
            });
            yield loadRecursive(undefined, undefined, loadAllChildren(undefined), requiredRowsCount);
            return {
                tree,
                loadedItemsMap: newItemsMap,
                loadedItems: newItems,
                byParentId,
                nodeInfoById,
            };
        });
    }
    static loadMissingItemsAndParents(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, newItemsMap, options, itemsToLoad, }) {
            const updatedItemsMap = cloneMap(newItemsMap);
            let iteration = 0;
            let prevMissingIds = new Set();
            let loadedItems = [];
            const isItemNotLoaded = (id) => tree.getById(id) === NOT_FOUND_RECORD && !updatedItemsMap.has(id);
            while (true) {
                const missingIds = new Set();
                if (itemsToLoad && itemsToLoad.length > 0) {
                    itemsToLoad.forEach((id) => {
                        if (isItemNotLoaded(id)) {
                            missingIds.add(id);
                        }
                    });
                }
                if (tree.getParams().getParentId) {
                    for (const [, item] of updatedItemsMap) {
                        const parentId = tree.getParams().getParentId(item);
                        if (parentId != null && isItemNotLoaded(parentId)) {
                            missingIds.add(parentId);
                        }
                    }
                }
                if (missingIds.size === 0) {
                    break;
                }
                else {
                    const ids = Array.from(missingIds);
                    const response = yield options.api({ ids });
                    if (response.items.length !== ids.length) {
                        console.error(`LazyTree: api does not returned requested items. Check that you handle 'ids' argument correctly.
                        Read more here: https://github.com/epam/UUI/issues/89`);
                    }
                    const newItems = response.items.filter((item) => {
                        const id = item ? tree.getParams().getId(item) : null;
                        return id !== null;
                    });
                    newItems.forEach((item) => {
                        const id = tree.getParams().getId(item);
                        updatedItemsMap.set(id, item);
                    });
                    loadedItems = loadedItems.concat(newItems);
                    if (prevMissingIds.size === missingIds.size && isEqual(prevMissingIds, missingIds)) {
                        break;
                    }
                    prevMissingIds = new Set([...missingIds]);
                }
                iteration++;
                if (iteration > 1000) {
                    throw new Error('LazyTree: More than 1000 iterations are made to load required items and their parents by ID. Check your api implementation');
                }
            }
            return { itemsMap: updatedItemsMap, loadedItems };
        });
    }
    static loadItems(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, options, byParentId, parentId, parent, dataSourceState, remainingRowsCount, loadAll, }) {
            var _b, _c, _d, _e, _f;
            const { ids: originalIds, count: childrenCount, totalCount, assumedCount: prevAssumedCount } = tree.getItems(parentId);
            const inputIds = byParentId.has(parentId) ? (_b = byParentId.get(parentId)) !== null && _b !== void 0 ? _b : originalIds : originalIds;
            let ids = inputIds !== null && inputIds !== void 0 ? inputIds : [];
            const loadedItems = [];
            const flatten = dataSourceState.search && options.flattenSearchResults;
            // Selection cascading forces to load all nodes under particular node
            if (loadAll) {
                remainingRowsCount = Number.MAX_SAFE_INTEGER;
            }
            const missingCount = Math.max(0, remainingRowsCount - ids.length);
            const availableCount = childrenCount != null ? childrenCount - ids.length : missingCount;
            const range = { from: ids.length };
            let skipRequest = false;
            if (!loadAll) {
                range.count = missingCount;
                skipRequest = options.isLoadStrict ? true : skipRequest;
            }
            if (missingCount === 0 || availableCount === 0 || skipRequest) {
                return {
                    ids,
                    nodeInfo: { count: childrenCount, totalCount, assumedCount: prevAssumedCount },
                    loadedItems,
                };
            }
            // Need to load additional items in the current layer
            const requestContext = {};
            if (!flatten) {
                if (parent != null) {
                    requestContext.parentId = parentId;
                    requestContext.parent = parent;
                }
                else {
                    // in flatten mode, we don't set parent and parentId even for root - as we don't want to limit results to top-level nodes only
                    requestContext.parentId = null;
                    requestContext.parent = null;
                }
            }
            const response = yield options.api({
                sorting: dataSourceState.sorting,
                search: dataSourceState.search,
                filter: options.filter,
                range,
                page: dataSourceState.page,
                pageSize: dataSourceState.pageSize,
            }, requestContext);
            const from = response.from == null ? range.from : response.from;
            if ((_c = response.items) === null || _c === void 0 ? void 0 : _c.length) {
                ids = [...ids];
                for (let n = 0; n < response.items.length; n++) {
                    const item = response.items[n];
                    loadedItems.push(item);
                    const id = tree.getParams().getId(item);
                    ids[n + from] = id;
                }
            }
            let newNodesCount;
            const loadedItemsCount = ((_e = (_d = response.items) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0);
            if (response.count !== null && response.count !== undefined) {
                newNodesCount = response.count;
            }
            else if (loadedItemsCount < missingCount) {
                newNodesCount = from + loadedItemsCount;
            }
            let assumedCount = undefined;
            if (!flatten && parent && tree.getParams().getChildCount) {
                assumedCount = tree.getParams().getChildCount(parent);
            }
            let nodeInfo = { count: childrenCount, totalCount, assumedCount: prevAssumedCount };
            if (newNodesCount !== childrenCount || assumedCount !== prevAssumedCount) {
                nodeInfo = Object.assign(Object.assign({}, nodeInfo), { count: newNodesCount, assumedCount });
            }
            nodeInfo = Object.assign(Object.assign({}, nodeInfo), { totalCount: (_f = response.totalCount) !== null && _f !== void 0 ? _f : totalCount });
            return {
                ids,
                nodeInfo,
                loadedItems,
            };
        });
    }
}

class ItemsMap {
    constructor(...args) {
        if (args.length === 1) {
            const [itemsMap] = args;
            this.params = itemsMap.params;
            this._itemsMap = cloneMap(itemsMap._itemsMap);
        }
        else {
            const [map, params] = args;
            this.params = params;
            this._itemsMap = map ? cloneMap(map) : newMap(params);
        }
    }
    get(id) {
        return this._itemsMap.has(id) ? this._itemsMap.get(id) : undefined;
    }
    has(id) {
        return this._itemsMap.has(id);
    }
    set(...args) {
        const [id, item] = args;
        let itemsMap = cloneMap(this._itemsMap);
        if (args.length > 1) {
            itemsMap.set(id, item);
        }
        else {
            itemsMap = itemsMap.set(id);
        }
        return new ItemsMap(itemsMap, this.params);
    }
    delete(id) {
        const itemsMap = cloneMap(this._itemsMap);
        itemsMap.delete(id);
        return new ItemsMap(itemsMap, this.params);
    }
    forEach(action) {
        for (const [id] of this._itemsMap) {
            action(this.get(id), id);
        }
    }
    clear() {
        return new ItemsMap(newMap(this.params), this.params);
    }
    setItems(items) {
        let updated = false;
        const itemsLink = cloneMap(this._itemsMap);
        items.forEach((item) => {
            const isExistingItem = itemsLink.has(this.params.getId(item));
            if (!isExistingItem || (isExistingItem && item !== itemsLink.get(this.params.getId(item)))) {
                itemsLink.set(this.params.getId(item), item);
                updated = true;
            }
        });
        if (updated) {
            return new ItemsMap(itemsLink, this.params);
        }
        return this;
    }
    get size() {
        return this._itemsMap.size;
    }
    [Symbol.iterator]() {
        return this._itemsMap[Symbol.iterator]();
    }
    static fromObject(obj, params) {
        const itemsMap = newMap(params);
        for (const [, value] of Object.entries(obj)) {
            itemsMap.set(params.getId(value), value);
        }
        return new ItemsMap(itemsMap, params);
    }
    static blank(params) {
        return new ItemsMap(newMap(params), params);
    }
}

const simpleComparator = (a, b) => {
    if (a < b) {
        return -1;
    }
    return a === b ? 0 : 1;
};
const buildComparators = (options) => {
    const compareScalars = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;
    const comparators = [];
    if (options.sorting) {
        options.sorting.forEach((sortingOption) => {
            const sortByFn = options.sortBy || ((i) => { var _a; return (_a = i[sortingOption.field]) !== null && _a !== void 0 ? _a : ''; });
            const sign = sortingOption.direction === 'desc' ? -1 : 1;
            comparators.push((a, b) => sign * compareScalars(sortByFn(a, sortingOption) + '', sortByFn(b, sortingOption) + ''));
        });
    }
    return comparators;
};
const composeComparators = (comparators, getId) => {
    return (a, b) => {
        for (let n = 0; n < comparators.length; n++) {
            const compare = comparators[n];
            const result = compare(a, b);
            if (result !== 0) {
                return result;
            }
        }
        const aId = getId(a);
        const bId = getId(b);
        const aCompareId = typeof aId === 'object' && aId !== null ? JSON.stringify(aId) : aId;
        const bCompareId = typeof bId === 'object' && bId !== null ? JSON.stringify(bId) : bId;
        return simpleComparator(aCompareId, bCompareId);
    };
};
const buildSorter = (options) => {
    const comparators = buildComparators(options);
    const composedComparator = composeComparators(comparators, options.getId);
    return (items) => {
        if (comparators.length === 0) {
            return items;
        }
        items = [...items];
        items.sort(composedComparator);
        return items;
    };
};

class Tree {
    static createFromItems({ params, items }) {
        const itemsMap = ItemsMap.blank(params);
        const itemsAccessor = ItemsAccessor.toItemsAccessor(itemsMap.setItems(items));
        return TreeStructure.createFromItems({ params, items, itemsAccessor });
    }
    static getParents(id, tree) {
        var _a, _b;
        const parentIds = [];
        let parentId = id;
        while (true) {
            const item = tree.getById(parentId);
            if (item === NOT_FOUND_RECORD) {
                break;
            }
            parentId = (_b = (_a = tree.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item);
            if (parentId === undefined) {
                break;
            }
            parentIds.unshift(parentId);
        }
        return parentIds;
    }
    static getPathById(id, tree) {
        const foundParents = this.getParents(id, tree);
        const path = [];
        foundParents.forEach((parentId) => {
            const parent = tree.getById(parentId);
            if (parent === NOT_FOUND_RECORD) {
                return;
            }
            const pathItem = this.getPathItem(parent, tree);
            path.push(pathItem);
        });
        return path;
    }
    static getPathItem(item, tree) {
        var _a, _b;
        const parentId = (_b = (_a = tree.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item);
        const id = tree.getParams().getId(item);
        const { ids, count, status } = tree.getItems(parentId);
        const lastId = ids[ids.length - 1];
        const isLastChild = lastId !== undefined
            && lastId === id
            && status === FULLY_LOADED
            && count === ids.length;
        return {
            id: tree.getParams().getId(item),
            value: item,
            isLastChild,
        };
    }
    static forEach(tree, action, options) {
        let shouldStop = false;
        const stop = () => {
            shouldStop = true;
        };
        options = Object.assign({ direction: 'top-down', parentId: undefined }, options);
        if (options.includeParent == null) {
            options.includeParent = options.parentId != null;
        }
        const iterateNodes = (ids) => {
            if (shouldStop)
                return;
            ids.forEach((id) => {
                var _a, _b;
                if (shouldStop)
                    return;
                const item = tree.getById(id);
                const parentId = item !== NOT_FOUND_RECORD ? (_b = (_a = tree.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item) : undefined;
                walkChildrenRec(item === NOT_FOUND_RECORD ? undefined : item, id, parentId);
            });
        };
        const walkChildrenRec = (item, id, parentId) => {
            if (options.direction === 'top-down') {
                action(item, id, parentId, stop);
            }
            const { ids: childrenIds } = tree.getItems(id);
            childrenIds && iterateNodes(childrenIds);
            if (options.direction === 'bottom-up') {
                action(item, id, parentId, stop);
            }
        };
        if (options.includeParent) {
            iterateNodes([options.parentId]);
        }
        else {
            iterateNodes(tree.getItems(options.parentId).ids);
        }
    }
    static forEachChildren(tree, action, isSelectable, parentId, includeParent = true) {
        this.forEach(tree, (item, id) => {
            if (item && isSelectable(id, item)) {
                action(id);
            }
        }, { parentId: parentId, includeParent });
    }
    static load(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, dataSourceState, api, getChildCount, isFolded, filter, }) {
            return yield FetchingHelper.load({
                tree,
                options: {
                    api,
                    getChildCount,
                    isFolded,
                    filter: Object.assign(Object.assign({}, dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.filter), filter),
                },
                dataSourceState,
            });
        });
    }
    static loadMissingOnCheck(_a) {
        return __awaiter(this, arguments, void 0, function* ({ tree, dataSourceState, api, getChildCount, isFolded, filter, cascadeSelection, isRoot, isChecked, checkedId, }) {
            const isImplicitMode = cascadeSelection === CascadeSelectionTypes.IMPLICIT;
            if (!cascadeSelection && !isRoot) {
                return tree;
            }
            const parents = this.getParents(checkedId, tree);
            return yield FetchingHelper.load({
                tree,
                options: {
                    api,
                    getChildCount,
                    isFolded,
                    filter: Object.assign(Object.assign({}, dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.filter), filter),
                    loadAllChildren: (itemId) => {
                        var _a;
                        const loadAllConfig = { nestedChildren: !isImplicitMode, children: false };
                        if (!cascadeSelection) {
                            return Object.assign(Object.assign({}, loadAllConfig), { children: isChecked && isRoot });
                        }
                        if (!isChecked && isRoot) {
                            return Object.assign(Object.assign({}, loadAllConfig), { children: false });
                        }
                        if (isImplicitMode) {
                            return Object.assign(Object.assign({}, loadAllConfig), { children: itemId === ROOT_ID || parents.some((parent) => isEqual(parent, itemId)) });
                        }
                        const { ids } = tree.getItems(undefined);
                        const rootIsNotLoaded = ids.length === 0;
                        const shouldLoadChildrenAfterSearch = (!!((_a = dataSourceState.search) === null || _a === void 0 ? void 0 : _a.length)
                            && (parents.some((parent) => isEqual(parent, itemId))
                                || (itemId === ROOT_ID && rootIsNotLoaded)));
                        // `isEqual` is used, because complex ids can be recreated after fetching of parents.
                        // So, they should be compared not by reference, but by value.
                        const shouldLoadAllChildren = isRoot
                            || isEqual(itemId, checkedId)
                            || shouldLoadChildrenAfterSearch;
                        return { children: shouldLoadAllChildren, nestedChildren: !shouldLoadChildrenAfterSearch };
                    },
                    isLoadStrict: true,
                },
                dataSourceState: Object.assign(Object.assign({}, dataSourceState), { search: null }),
            });
        });
    }
    static computeSubtotals(tree, get, add) {
        const subtotalsMap = newMap(tree.getParams());
        Tree.forEach(tree, (item, id, parentId) => {
            const { ids } = tree.getItems(id);
            const hasChildren = ids.length > 0;
            let itemSubtotals = get(item, hasChildren);
            // add already computed children subtotals
            if (subtotalsMap.has(id)) {
                itemSubtotals = add(itemSubtotals, subtotalsMap.get(id));
            }
            // store
            subtotalsMap.set(id, itemSubtotals);
            // add value to parent
            let parentSubtotals;
            if (!subtotalsMap.has(parentId)) {
                parentSubtotals = itemSubtotals;
            }
            else {
                parentSubtotals = add(itemSubtotals, subtotalsMap.get(parentId));
            }
            subtotalsMap.set(parentId, parentSubtotals);
        }, { direction: 'bottom-up' });
        return subtotalsMap;
    }
}

class TreeStructure {
    constructor(_params, _itemsAccessor, _byParentId = newMap(_params), _nodeInfoById = newMap(_params)) {
        this._params = _params;
        this._itemsAccessor = _itemsAccessor;
        this._byParentId = _byParentId;
        this._nodeInfoById = _nodeInfoById;
    }
    get itemsAccessor() {
        return this._itemsAccessor;
    }
    getParams() {
        return this._params;
    }
    get byParentId() {
        return this._byParentId;
    }
    get nodeInfoById() {
        return this._nodeInfoById;
    }
    getRootItems() {
        return this.getItems(undefined).ids
            .map((id) => this.itemsAccessor.get(id))
            .filter((item) => item !== NOT_FOUND_RECORD);
    }
    getById(id) {
        return this.itemsAccessor.get(id);
    }
    getItems(parentId) {
        var _a;
        const currentParentId = parentId !== null && parentId !== void 0 ? parentId : undefined;
        const ids = (_a = this.byParentId.get(currentParentId)) !== null && _a !== void 0 ? _a : [];
        const _b = this.nodeInfoById.get(currentParentId) || {}, { count } = _b, restNodeInfo = __rest(_b, ["count"]);
        let status = count === undefined ? PARTIALLY_LOADED : EMPTY;
        if (count !== 0 && ids.length === count) {
            status = FULLY_LOADED;
        }
        return Object.assign({ ids, count, status }, restNodeInfo);
    }
    getChildren(parentId) {
        const { ids } = this.getItems(parentId);
        const children = ids.map((id) => this.itemsAccessor.get(id));
        return children.filter((item) => item !== NOT_FOUND_RECORD);
    }
    getTotalCount() {
        let count = undefined;
        for (const [, info] of this.nodeInfoById) {
            if (info.count == null) {
                // TBD: getTotalCount() is used for totalCount, but we can't have correct count until all branches are loaded
                return null;
            }
            else {
                if (count === undefined) {
                    count = 0;
                }
                count += info.count;
            }
        }
        return count;
    }
    computeSubtotals(get, add) {
        const subtotalsMap = newMap(this.getParams());
        Tree.forEach(this, (item, id, parentId) => {
            let itemSubtotals = get(item, this.byParentId.has(id));
            // add already computed children subtotals
            if (subtotalsMap.has(id)) {
                itemSubtotals = add(itemSubtotals, subtotalsMap.get(id));
            }
            // store
            subtotalsMap.set(id, itemSubtotals);
            // add value to parent
            let parentSubtotals;
            if (!subtotalsMap.has(parentId)) {
                parentSubtotals = itemSubtotals;
            }
            else {
                parentSubtotals = add(itemSubtotals, subtotalsMap.get(parentId));
            }
            subtotalsMap.set(parentId, parentSubtotals);
        }, { direction: 'bottom-up' });
        return subtotalsMap;
    }
    static create(params, itemsAccessor, byParentId, nodeInfoById) {
        return new TreeStructure(params, itemsAccessor, byParentId, nodeInfoById);
    }
    static withNewItemsAccessor(itemsAccessor, treeStructure) {
        return TreeStructure.create(treeStructure.getParams(), itemsAccessor, treeStructure.byParentId, treeStructure.nodeInfoById);
    }
    static createFromItems({ params, items, itemsAccessor, }) {
        var _a;
        const byParentId = newMap(params);
        const itemsMap = newMap(params);
        items.forEach((item) => {
            var _a, _b;
            const parentId = (_b = (_a = params.getParentId) === null || _a === void 0 ? void 0 : _a.call(params, item)) !== null && _b !== void 0 ? _b : undefined;
            if (!byParentId.has(parentId)) {
                byParentId.set(parentId, []);
            }
            const children = byParentId.get(parentId);
            children.push(params.getId(item));
            byParentId.set(parentId, children);
            itemsMap.set(parentId, item);
        });
        const newNodeInfoById = newMap(params);
        for (const [parentId, ids] of byParentId) {
            const assumedCount = itemsMap.has(parentId) ? (_a = params.getChildCount) === null || _a === void 0 ? void 0 : _a.call(params, itemsMap.get(parentId)) : undefined;
            newNodeInfoById.set(parentId, Object.assign({ count: ids.length }, (params.getChildCount ? { assumedCount } : {})));
        }
        // if items is empty, count should be defined, otherwise, loading placeholders will be rendered.
        if (!newNodeInfoById.size) {
            newNodeInfoById.set(undefined, { count: 0 });
        }
        return this.create(params, itemsAccessor, byParentId, newNodeInfoById);
    }
}

class CheckingHelper {
    static cascadeSelection({ tree, currentCheckedIds, checkedId, isChecked, isCheckable, isUnknown, cascadeSelectionType, }) {
        const isImplicitMode = cascadeSelectionType === CascadeSelectionTypes.IMPLICIT;
        let checkedIdsMap = newMap(tree.getParams());
        if (!(checkedId === ROOT_ID && isImplicitMode)) {
            currentCheckedIds.forEach((id) => checkedIdsMap.set(id, true));
        }
        const optionsWithDefaults = { isCheckable: isCheckable !== null && isCheckable !== void 0 ? isCheckable : (() => true), cascadeSelectionType };
        const { count } = tree.getItems(undefined);
        const treeIsLoaded = count !== 0;
        // If clear items while tree is not loaded yet (while clearing tags of PickerInput before opening body).
        if (!treeIsLoaded && !isChecked) {
            checkedIdsMap = this.clearIfTreeNotLoaded({
                tree,
                checkedIdsMap,
                checkedId,
                isCheckable: optionsWithDefaults.isCheckable,
            });
        }
        if (treeIsLoaded && !optionsWithDefaults.cascadeSelectionType) {
            checkedIdsMap = this.simpleSelection(Object.assign({ tree,
                checkedIdsMap,
                checkedId,
                isChecked }, optionsWithDefaults));
        }
        if (treeIsLoaded && (optionsWithDefaults.cascadeSelectionType === true
            || optionsWithDefaults.cascadeSelectionType === CascadeSelectionTypes.EXPLICIT)) {
            checkedIdsMap = this.explicitCascadeSelection(Object.assign({ tree,
                checkedIdsMap,
                checkedId,
                isChecked }, optionsWithDefaults));
        }
        if (treeIsLoaded && optionsWithDefaults.cascadeSelectionType === CascadeSelectionTypes.IMPLICIT) {
            checkedIdsMap = this.implicitCascadeSelection(Object.assign({ tree,
                checkedIdsMap,
                checkedId,
                isChecked }, optionsWithDefaults));
        }
        if (!isChecked && checkedId === ROOT_ID && checkedIdsMap.size > 0) {
            checkedIdsMap = this.clearUnknownItems({ checkedIdsMap, isUnknown });
        }
        const result = [];
        for (const [id, value] of checkedIdsMap) {
            value && result.push(id);
        }
        return result;
    }
    static simpleSelection({ tree, checkedIdsMap, checkedId, isChecked, isCheckable, }) {
        if (isChecked) {
            // eslint-disable-next-line eqeqeq
            if (checkedId != ROOT_ID) {
                checkedIdsMap.set(checkedId, true);
            }
            else {
                Tree.forEachChildren(tree, (id) => { checkedIdsMap.set(id, true); }, isCheckable);
            }
            return checkedIdsMap;
        }
        // eslint-disable-next-line eqeqeq
        if (checkedId != ROOT_ID) {
            checkedIdsMap.delete(checkedId);
            return checkedIdsMap;
        }
        return this.clearAllChecked({ tree, checkedIdsMap, isCheckable });
    }
    static clearAllChecked({ tree, checkedIdsMap, isCheckable, }) {
        for (const [checkedItemId, isItemChecked] of checkedIdsMap) {
            if (isItemChecked) {
                this.actForCheckable({
                    tree,
                    action: (id) => checkedIdsMap.delete(id),
                    isCheckable,
                    id: checkedItemId,
                });
            }
        }
        return checkedIdsMap;
    }
    static actForCheckable({ tree, action, isCheckable, id, }) {
        const item = tree.getById(id);
        if (isCheckable(id, item)) {
            action(id);
        }
    }
    static explicitCascadeSelection({ tree, checkedIdsMap, checkedId, isChecked, isCheckable, }) {
        if (isChecked) {
            // eslint-disable-next-line eqeqeq
            if (checkedId != ROOT_ID) {
                checkedIdsMap.set(checkedId, true);
            }
            // check all children recursively
            Tree.forEachChildren(tree, 
            // eslint-disable-next-line eqeqeq
            (id) => id != ROOT_ID && checkedIdsMap.set(id, true), isCheckable, checkedId);
            return this.checkParentsWithFullCheck({ tree, checkedIdsMap, checkedId, isCheckable });
        }
        // eslint-disable-next-line eqeqeq
        if (checkedId != ROOT_ID) {
            checkedIdsMap.delete(checkedId);
            // uncheck all children recursively
            Tree.forEachChildren(tree, (id) => checkedIdsMap.delete(id), isCheckable, checkedId);
            Tree.getParents(checkedId, tree).forEach((parentId) => checkedIdsMap.delete(parentId));
            return checkedIdsMap;
        }
        return this.clearAllChecked({ tree, checkedIdsMap, isCheckable });
    }
    static implicitCascadeSelection({ tree, checkedIdsMap, checkedId, isChecked, isCheckable, }) {
        if (isChecked) {
            // eslint-disable-next-line eqeqeq
            if (checkedId != ROOT_ID) {
                checkedIdsMap.set(checkedId, true);
            }
            // In implicit mode, no children are loaded into the parent.
            // When some child is checked and the search is cleared, while checking the top parent no children will be loaded,
            // so there will be no children in the list of checked parent's children. Because of such behavior, explicitly checked
            // children will not be removed from the list.
            // To remove them, it is required to pass through all the checked items and check, if their parents don't contain the checked item.
            if (checkedIdsMap.size) {
                for (const [id] of checkedIdsMap) {
                    if (isEqual(id, checkedId)) {
                        continue;
                    }
                    const path = Tree.getPathById(id, tree);
                    if (path.some((item) => isEqual(item.id, checkedId))) {
                        checkedIdsMap.delete(id);
                    }
                }
            }
            if (checkedId === ROOT_ID) {
                const { ids: childrenIds } = tree.getItems(checkedId);
                // if selectedId is undefined and it is selected, that means selectAll
                childrenIds.forEach((id) => checkedIdsMap.set(id, true));
            }
            // check parents if all children are checked
            return this.checkParentsWithFullCheck({
                tree,
                checkedIdsMap,
                checkedId,
                isCheckable,
                removeExplicitChildrenSelection: true,
            });
        }
        // eslint-disable-next-line eqeqeq
        if (checkedId != ROOT_ID) {
            checkedIdsMap.delete(checkedId);
            const selectNeighboursOnly = (itemId) => {
                var _a, _b;
                const item = tree.getById(itemId);
                if (item === NOT_FOUND_RECORD) {
                    return;
                }
                const parentId = (_b = (_a = tree.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item);
                const parents = Tree.getParents(itemId, tree);
                // if some parent is checked, it is required to check all children explicitly,
                // except unchecked one.
                const someParentIsChecked = parents.some((parent) => checkedIdsMap.get(parent));
                tree.getItems(parentId).ids.forEach((id) => {
                    if (itemId !== id && someParentIsChecked) {
                        checkedIdsMap.set(id, true);
                    }
                });
                checkedIdsMap.delete(parentId);
            };
            const parents = Tree.getParents(checkedId, tree);
            [checkedId, ...parents.reverse()].forEach(selectNeighboursOnly);
            return checkedIdsMap;
        }
        return this.clearAllChecked({ tree, checkedIdsMap, isCheckable });
    }
    static checkParentsWithFullCheck({ tree, checkedIdsMap, checkedId, isCheckable, removeExplicitChildrenSelection, }) {
        Tree.getParents(checkedId, tree)
            .reverse()
            .forEach((parentId) => {
            const { ids: childrenIds } = tree.getItems(parentId);
            if (childrenIds && childrenIds.every((childId) => checkedIdsMap.has(childId))) {
                // eslint-disable-next-line eqeqeq
                if (parentId != ROOT_ID) {
                    checkedIdsMap.set(parentId, true);
                }
                if (removeExplicitChildrenSelection) {
                    Tree.forEachChildren(tree, (id) => checkedIdsMap.delete(id), isCheckable, parentId, false);
                }
            }
        });
        return checkedIdsMap;
    }
    static clearIfTreeNotLoaded({ tree, checkedIdsMap, checkedId, isCheckable, }) {
        if (checkedId !== ROOT_ID) {
            const item = tree.getById(checkedId);
            if (isCheckable(checkedId, item)) {
                checkedIdsMap.delete(checkedId);
            }
        }
        else {
            for (const [selectedItemId, isItemSelected] of checkedIdsMap) {
                const selectedItem = tree.getById(selectedItemId);
                if (isItemSelected && isCheckable(selectedItemId, selectedItem)) {
                    checkedIdsMap.delete(selectedItemId);
                }
            }
        }
        return checkedIdsMap;
    }
    static clearUnknownItems({ checkedIdsMap, isUnknown, }) {
        for (const [selectedItemId, isItemSelected] of checkedIdsMap) {
            if (isItemSelected && isUnknown(selectedItemId)) {
                checkedIdsMap.delete(selectedItemId);
            }
        }
        return checkedIdsMap;
    }
}

class FilterHelper {
    static filter({ treeStructure, getFilter, filter }) {
        const isMatchingFilter = getFilter === null || getFilter === void 0 ? void 0 : getFilter(filter);
        return this.applyFilterToTreeSnapshot({ treeStructure, filter: isMatchingFilter });
    }
    static applyFilterToTreeSnapshot({ treeStructure, filter }) {
        if (!filter)
            return treeStructure;
        const matchedItems = [];
        const applyFilterRec = (items) => {
            let isSomeMatching = false;
            items.forEach((item) => {
                const isItemMatching = filter(item);
                const id = treeStructure.getParams().getId(item);
                const isSomeChildMatching = applyFilterRec(treeStructure.getChildren(id));
                const isMatching = isItemMatching || isSomeChildMatching;
                if (isMatching) {
                    matchedItems.push(item);
                }
                if (!isSomeMatching) {
                    isSomeMatching = isMatching;
                }
            });
            return isSomeMatching;
        };
        applyFilterRec(treeStructure.getRootItems());
        return TreeStructure.createFromItems({
            itemsAccessor: treeStructure.itemsAccessor,
            params: treeStructure.getParams(),
            items: matchedItems,
        });
    }
}

class SearchHelper {
    static search(options) {
        const search = this.buildSearchFilter(options);
        return this.applySearchToTree({ treeStructure: options.treeStructure, search, sortSearchByRelevance: options.sortSearchByRelevance });
    }
    static buildSearchFilter({ search, getSearchFields }) {
        if (!search)
            return null;
        if (!getSearchFields) {
            console.warn('[Tree] Search value is set, but options.getSearchField is not specified. Nothing to search on.');
            return null;
        }
        const searchFilter = getSearchFilter(search);
        return (i) => searchFilter(getSearchFields(i));
    }
    static applySearchToTree({ treeStructure, search, sortSearchByRelevance }) {
        if (!search)
            return treeStructure;
        const matchedItems = [];
        const ranks = new Map();
        const applySearchRec = (items) => {
            let isSomeMatching = false;
            items.forEach((item) => {
                const isItemMatching = search(item);
                const id = treeStructure.getParams().getId(item);
                const isSomeChildMatching = applySearchRec(treeStructure.getChildren(id));
                const isMatching = isItemMatching || isSomeChildMatching;
                if (isMatching !== false) {
                    matchedItems.push(item);
                    if (typeof isMatching !== 'boolean') {
                        const rank = ranks.has(id) ? Math.max(ranks.get(id), isMatching) : isMatching;
                        ranks.set(treeStructure.getParams().getId(item), rank);
                    }
                }
                if (!isSomeMatching) {
                    isSomeMatching = isMatching;
                }
                else if (typeof isMatching === 'number') {
                    isSomeMatching = typeof isSomeMatching === 'number'
                        ? Math.max(isMatching, isSomeMatching)
                        : isMatching;
                }
            });
            return isSomeMatching;
        };
        applySearchRec(treeStructure.getRootItems());
        const searchItems = sortSearchByRelevance ? this.sortByRanks(matchedItems, ranks, treeStructure.getParams().getId) : matchedItems;
        return TreeStructure.createFromItems({
            itemsAccessor: treeStructure.itemsAccessor,
            params: treeStructure.getParams(),
            items: searchItems,
        });
    }
    static sortByRanks(items, ranks, getId) {
        if (ranks.size === 0) {
            return items;
        }
        const itemsToSort = [...items];
        return orderBy(itemsToSort, (item) => {
            const id = getId(item);
            if (!ranks.has(id)) {
                return 0;
            }
            return ranks.get(id);
        }, 'desc');
    }
}

class SortHelper {
    static sort(_a) {
        var { treeStructure } = _a, options = __rest(_a, ["treeStructure"]);
        const sort = buildSorter(options);
        const sortedItems = [];
        const sortRec = (items) => {
            sortedItems.push(sort(items));
            items.forEach((item) => {
                const id = treeStructure.getParams().getId(item);
                const children = treeStructure.getChildren(id);
                sortRec(children);
            });
        };
        sortRec(treeStructure.getRootItems());
        return TreeStructure.createFromItems({
            params: treeStructure.getParams(),
            itemsAccessor: treeStructure.itemsAccessor,
            items: sortedItems.flat(),
        });
    }
}

/**
 * Storage of items with subscriptions. Enables sharing loaded data between multiple consumers.
 * @internal For internal usage only. API can be changed in future releases.
 */
class ItemsStorage {
    constructor({ items, params }) {
        this.subs = new Map();
        this.setItems = (items, options) => {
            const itemsMap = (options === null || options === void 0 ? void 0 : options.reset)
                ? this._itemsMap.clear().setItems(items)
                : this._itemsMap.setItems(items);
            if (itemsMap !== this._itemsMap) {
                this._itemsMap = itemsMap;
                this.subs.forEach((_, onUpdate) => onUpdate(itemsMap));
            }
            return this._itemsMap;
        };
        this._itemsMap = new ItemsMap(null, params);
        if (items === null || items === void 0 ? void 0 : items.length) {
            this.setItems(items);
        }
    }
    subscribe(onUpdate) {
        this.subs.set(onUpdate);
        onUpdate(this._itemsMap);
        return () => this.subs.delete(onUpdate);
    }
    getItemsMap() {
        return this._itemsMap;
    }
}

function useLoadData$1(props) {
    const { api, filter, isFolded, cascadeSelection } = props;
    const promiseInProgressRef = useRef();
    const loadMissingImpl = useCallback((_a) => __awaiter(this, [_a], void 0, function* ({ using, tree, loadAllChildren = () => ({ nestedChildren: true, children: false }), isLoadStrict, dataSourceState, }) {
        var _b;
        const loadingTree = tree;
        const completeDsState = Object.assign(Object.assign({}, props.dataSourceState), dataSourceState);
        try {
            const newTreePromise = tree.load({
                using,
                options: Object.assign(Object.assign({}, props), { loadAllChildren,
                    isLoadStrict,
                    isFolded,
                    api, filter: Object.assign(Object.assign(Object.assign({}, filter), (_b = props.dataSourceState) === null || _b === void 0 ? void 0 : _b.filter), dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.filter) }),
                dataSourceState: completeDsState,
            });
            const newTree = yield newTreePromise;
            const linkToTree = tree;
            // If tree is changed during this load, than there was reset occurred (new value arrived)
            // We need to tell caller to reject this result
            const isOutdated = linkToTree !== loadingTree;
            const isUpdated = linkToTree !== newTree;
            return { isUpdated, isOutdated, tree: newTree };
        }
        catch (e) {
            // TBD - correct error handling
            console.error('LazyListView: Error while loading items.', e);
            return { isUpdated: false, isOutdated: false, tree: loadingTree };
        }
    }), [isFolded, api, filter, props.dataSourceState]);
    const loadMissing = useCallback(({ tree, using, abortInProgress, loadAllChildren, isLoadStrict, dataSourceState, }) => {
        // Make tree updates sequential, by executing all consequent calls after previous promise completed
        if (!promiseInProgressRef.current || abortInProgress) {
            promiseInProgressRef.current = Promise.resolve({ isUpdated: false, isOutdated: false, tree });
        }
        promiseInProgressRef.current = promiseInProgressRef.current.then(({ tree: currentTree }) => loadMissingImpl({ tree: currentTree, using, loadAllChildren, isLoadStrict, dataSourceState }));
        return promiseInProgressRef.current;
    }, [loadMissingImpl]);
    const loadMissingOnCheck = useCallback((currentTree, id, isChecked, isRoot) => __awaiter(this, void 0, void 0, function* () {
        const isImplicitMode = cascadeSelection === CascadeSelectionTypes.IMPLICIT;
        if (!cascadeSelection && !isRoot) {
            return currentTree;
        }
        const parents = Tree.getParents(id, currentTree.full);
        const { tree: treeWithMissingRecords } = yield loadMissing({
            tree: currentTree,
            // If cascadeSelection is implicit and the element is unchecked, it is necessary to load all children
            // of all parents of the unchecked element to be checked explicitly. Only one layer of each parent should be loaded.
            // Otherwise, should be loaded only checked element and all its nested children.
            loadAllChildren: (itemId) => {
                var _a;
                const loadAllConfig = { nestedChildren: !isImplicitMode, children: false };
                if (!cascadeSelection) {
                    return Object.assign(Object.assign({}, loadAllConfig), { children: isChecked && isRoot });
                }
                if (!isChecked && isRoot) {
                    return Object.assign(Object.assign({}, loadAllConfig), { children: false });
                }
                if (isImplicitMode) {
                    return Object.assign(Object.assign({}, loadAllConfig), { children: itemId === ROOT_ID || parents.some((parent) => isEqual(parent, itemId)) });
                }
                const { ids } = currentTree.full.getItems(undefined);
                const rootIsNotLoaded = ids.length === 0;
                const shouldLoadChildrenAfterSearch = (!!((_a = props.dataSourceState.search) === null || _a === void 0 ? void 0 : _a.length)
                    && (parents.some((parent) => isEqual(parent, itemId))
                        || (itemId === ROOT_ID && rootIsNotLoaded)));
                // `isEqual` is used, because complex ids can be recreated after fetching of parents.
                // So, they should be compared not by reference, but by value.
                const shouldLoadAllChildren = isRoot
                    || isEqual(itemId, id)
                    || shouldLoadChildrenAfterSearch;
                return {
                    children: shouldLoadAllChildren,
                    // If checking is run after the search, it is required to load only
                    // children of the checked item parents, without nestings.
                    nestedChildren: !shouldLoadChildrenAfterSearch,
                };
            },
            isLoadStrict: true,
            dataSourceState: { search: null },
            using: 'full',
        });
        return treeWithMissingRecords;
    }), [cascadeSelection, loadMissing, props.dataSourceState.search]);
    return { loadMissing, loadMissingOnCheck };
}

const getDataSourceStateWithDefaults = (dataSourceState) => {
    var _a, _b;
    return ((dataSourceState.topIndex === undefined || dataSourceState.visibleCount)
        ? Object.assign(Object.assign({}, dataSourceState), { topIndex: (_a = dataSourceState.topIndex) !== null && _a !== void 0 ? _a : 0, visibleCount: (_b = dataSourceState.visibleCount) !== null && _b !== void 0 ? _b : 20 }) : dataSourceState);
};
function useDataSourceStateWithDefaults({ dataSourceState }) {
    const dataSourceStateRef = useRef(getDataSourceStateWithDefaults(dataSourceState));
    dataSourceStateRef.current = getDataSourceStateWithDefaults(dataSourceState);
    return dataSourceStateRef.current;
}

class ItemsStatusCollector {
    constructor(itemsStatusMap, params) {
        this.params = params;
        this.getItemStatus = (itemsMap) => (id) => {
            var _a;
            if (itemsMap.has(id)) {
                return LOADED_RECORD;
            }
            const status = (_a = this.itemsStatusMap.get(id)) !== null && _a !== void 0 ? _a : NOT_FOUND_RECORD;
            if (status === LOADED_RECORD) {
                return LOADING_RECORD;
            }
            return status;
        };
        this.itemsStatusMap = itemsStatusMap !== null && itemsStatusMap !== void 0 ? itemsStatusMap : newMap(params);
        this.subscriptions = newMap(params);
    }
    setPending(ids) {
        this.setStatus(ids, PENDING_RECORD);
    }
    setLoading(ids) {
        this.setStatus(ids, LOADING_RECORD);
    }
    setLoaded(ids) {
        this.setStatus(ids, LOADED_RECORD);
    }
    setFailed(ids) {
        this.setStatus(ids, FAILED_RECORD);
    }
    setNotFound(ids) {
        this.setStatus(ids, NOT_FOUND_RECORD);
    }
    withPending(ids) {
        ids.forEach((id) => {
            this.itemsStatusMap.set(id, PENDING_RECORD);
        });
        return this;
    }
    watch(api) {
        return (request, context) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (request.ids) {
                try {
                    this.setLoading(request.ids);
                    const result = yield api(request, context);
                    const loadedIds = ((_a = result.items) !== null && _a !== void 0 ? _a : []).map((item) => {
                        const id = this.params.getId(item);
                        return [id, id];
                    });
                    this.setLoaded(loadedIds.map(([id]) => id));
                    const loadedIdsMap = new Map(loadedIds);
                    const notLoadedIds = request.ids.filter((id) => !loadedIdsMap.has(id));
                    this.setNotFound(notLoadedIds);
                    return result;
                }
                catch (e) {
                    this.setFailed(request.ids);
                    throw e;
                }
            }
            return yield api(request, context);
        });
    }
    setStatus(ids, status) {
        ids.forEach((id) => {
            this.itemsStatusMap.set(id, status);
        });
        this.onUpdate();
    }
    onUpdate() {
        for (const [onSubscribe] of this.subscriptions) {
            onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(this.itemsStatusMap);
        }
    }
    subscribe(onSubscribe) {
        this.subscriptions = this.subscriptions.set(onSubscribe);
        return () => this.subscriptions.delete(onSubscribe);
    }
}

function useItemsStatusCollector({ itemsStatusMap, complexIds, getId, itemsStatusCollector, dataSourceState, patch, }, deps) {
    const statusCollector = useMemo(() => {
        if (itemsStatusCollector) {
            return itemsStatusCollector;
        }
        return new ItemsStatusCollector(itemsStatusMap, { complexIds, getId });
    }, deps);
    return useMemo(() => {
        return statusCollector.withPending(getSelectedAndChecked(dataSourceState, patch));
    }, [statusCollector]);
}

function useItemsStorage({ itemsMap: outerItemsMap, setItems, items, params }) {
    var _a;
    const itemsStorage = useMemo(() => {
        if (!outerItemsMap) {
            return new ItemsStorage({ items, params });
        }
        return null;
    }, [outerItemsMap, items]);
    const [itemsMap, setItemsMap] = useState(outerItemsMap !== null && outerItemsMap !== void 0 ? outerItemsMap : itemsStorage === null || itemsStorage === void 0 ? void 0 : itemsStorage.getItemsMap());
    useEffect(() => {
        if (itemsStorage) {
            const unsubscribe = itemsStorage.subscribe(() => {
                setItemsMap(itemsStorage.getItemsMap());
            });
            return () => {
                unsubscribe();
            };
        }
    }, []);
    useEffect(() => {
        if (Array.isArray(items)) {
            if (itemsStorage) {
                itemsStorage.setItems(items);
            }
            setItems === null || setItems === void 0 ? void 0 : setItems(items);
        }
    }, [items]);
    const currentItemsMap = outerItemsMap !== null && outerItemsMap !== void 0 ? outerItemsMap : itemsMap;
    return {
        itemsMap: currentItemsMap,
        setItems: setItems !== null && setItems !== void 0 ? setItems : ((_a = itemsStorage === null || itemsStorage === void 0 ? void 0 : itemsStorage.setItems) !== null && _a !== void 0 ? _a : currentItemsMap.setItems),
    };
}

const groupByParentId = (patch, getParentId, complexIds) => {
    var _a;
    const patchByParentId = newMap({ complexIds });
    if (!patch) {
        return patchByParentId;
    }
    for (const [, item] of patch) {
        const parentId = (_a = getParentId === null || getParentId === void 0 ? void 0 : getParentId(item)) !== null && _a !== void 0 ? _a : undefined;
        if (!patchByParentId.has(parentId)) {
            patchByParentId.set(parentId, []);
        }
        const prevItems = patchByParentId.get(parentId);
        patchByParentId.set(parentId, [...prevItems, item]);
    }
    return patchByParentId;
};
const getPatchByCategories = (items, tree, patchAtLastSort, getNewItemPosition, getItemTemporaryOrder, isDeleted, fixItemBetweenSortings) => {
    var _a, _b, _c, _d;
    const { getId, getParentId, complexIds } = tree.getParams();
    const top = [];
    const bottom = [];
    const updated = [];
    const movedToOtherParent = [];
    const updatedItemsMap = newMap({ complexIds });
    const newItems = [];
    const withTempOrder = [];
    for (const item of items) {
        const id = getId(item);
        const itemInOriginalTree = tree.getById(id) !== NOT_FOUND_RECORD;
        const itemInPatchBeforeSort = patchAtLastSort.has(id);
        updatedItemsMap.set(id, item);
        newItems.push(item);
        const tempOrder = getItemTemporaryOrder === null || getItemTemporaryOrder === void 0 ? void 0 : getItemTemporaryOrder(item);
        const prevItem = (_a = patchAtLastSort.get(id)) !== null && _a !== void 0 ? _a : tree.getById(id);
        const prevParentId = (_b = getParentId === null || getParentId === void 0 ? void 0 : getParentId(prevItem)) !== null && _b !== void 0 ? _b : undefined;
        const newParentId = (_c = getParentId === null || getParentId === void 0 ? void 0 : getParentId(item)) !== null && _c !== void 0 ? _c : undefined;
        if (!fixItemBetweenSortings) {
            const realPrevItem = tree.getById(id);
            if (realPrevItem !== NOT_FOUND_RECORD) {
                const realPrevParentId = (_d = getParentId === null || getParentId === void 0 ? void 0 : getParentId(realPrevItem)) !== null && _d !== void 0 ? _d : undefined;
                if (realPrevParentId !== newParentId) {
                    movedToOtherParent.push(id);
                }
            }
        }
        else if (prevParentId !== newParentId) {
            movedToOtherParent.push(id);
        }
        if (tempOrder) {
            if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(item)) {
                continue;
            }
            withTempOrder.push(id);
            continue;
        }
        if (!itemInPatchBeforeSort && !itemInOriginalTree) {
            const position = getNewItemPosition(item);
            if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(item)) {
                continue;
            }
            if (position === PatchOrdering.BOTTOM) {
                bottom.push(id);
            }
            else {
                top.unshift(id);
            }
            continue;
        }
        if (prevParentId !== newParentId) {
            const position = getNewItemPosition(item);
            if (position === PatchOrdering.BOTTOM) {
                bottom.push(id);
            }
            else {
                top.unshift(id);
            }
            continue;
        }
        updated.push(id);
    }
    return { top, bottom, movedToOtherParent, updated, withTempOrder, updatedItemsMap, newItems };
};
const sortUpdatedItems = (updated, composedComparator, tree, patchAtLastSort) => {
    return updated.sort((aId, bId) => {
        var _a, _b;
        const bItem = (_a = patchAtLastSort.get(bId)) !== null && _a !== void 0 ? _a : tree.getById(bId);
        const aItem = (_b = patchAtLastSort.get(aId)) !== null && _b !== void 0 ? _b : tree.getById(aId);
        return composedComparator(aItem, bItem);
    });
};
const sortByTemporaryOrder = (withTempOrder, getItemTemporaryOrder, updatedItemsMap) => {
    const comparator = (a, b) => a < b ? -1 : 1;
    return withTempOrder.sort((aId, bId) => {
        const a = updatedItemsMap.get(aId);
        const b = updatedItemsMap.get(bId);
        return comparator(getItemTemporaryOrder(a), getItemTemporaryOrder((b)));
    });
};
const sortPatchByParentId = (tree, groupedByParentId, getNewItemPosition, getItemTemporaryOrder, patchAtLastSort, sortBy, sorting, isDeleted, fixItemBetweenSortings) => {
    const { complexIds } = tree.getParams();
    const comparators = buildComparators({ sorting, sortBy, getId: tree.getParams().getId });
    const composedComparator = composeComparators(comparators, tree.getParams().getId);
    const sorted = newMap({ complexIds });
    for (const [parentId, items] of groupedByParentId) {
        const { top, bottom, updated, movedToOtherParent, withTempOrder, updatedItemsMap, newItems } = getPatchByCategories(items, tree, patchAtLastSort, getNewItemPosition, getItemTemporaryOrder, isDeleted, fixItemBetweenSortings);
        const sortedUpdated = sortUpdatedItems(updated, composedComparator, tree, patchAtLastSort);
        const sortedByTempOrder = sortByTemporaryOrder(withTempOrder, getItemTemporaryOrder, updatedItemsMap);
        sorted.set(parentId, {
            top,
            bottom,
            updated: sortedUpdated,
            moved: movedToOtherParent,
            withTempOrder: sortedByTempOrder,
            updatedItemsMap,
            newItems,
        });
    }
    return sorted;
};
const getSortedPatchByParentId = (tree, patch, patchAtLastSort, getNewItemPosition, getItemTemporaryOrder, sortBy, sorting, isDeleted, fixItemBetweenSortings) => {
    const params = tree.getParams();
    const grouped = groupByParentId(patch, params.getParentId, params.complexIds);
    return sortPatchByParentId(tree, grouped, getNewItemPosition, getItemTemporaryOrder, patchAtLastSort, sortBy, sorting, isDeleted, fixItemBetweenSortings);
};

function usePatchTree({ tree, patch, getNewItemPosition = () => PatchOrdering.TOP, getItemTemporaryOrder, fixItemBetweenSortings = true, isDeleted, sorting, sortBy, }) {
    const prevPatch = usePrevious(patch);
    const params = tree.visible.getParams();
    const patchAtLastSort = useMemo(() => {
        return prevPatch === null ? newMap({ complexIds: params.complexIds }) : patch;
    }, [sorting]);
    const sortedPatch = useMemo(() => getSortedPatchByParentId(tree.visible, patch, fixItemBetweenSortings ? patchAtLastSort : patch, getNewItemPosition, getItemTemporaryOrder, sortBy, sorting, isDeleted, fixItemBetweenSortings), [patch, sorting, fixItemBetweenSortings]);
    const patchedTree = useMemo(() => {
        return tree.patch(Object.assign({ sortedPatch, patchAtLastSort: fixItemBetweenSortings ? patchAtLastSort : patch, getItemTemporaryOrder,
            isDeleted,
            sorting,
            sortBy }, tree.visible.getParams()));
    }, [tree, patch]);
    const applyPatch = useCallback((updated) => {
        const patchAfterSort = getSortedPatchByParentId(tree.visible, updated, fixItemBetweenSortings ? patchAtLastSort : updated, getNewItemPosition, getItemTemporaryOrder, sortBy, sorting, isDeleted, fixItemBetweenSortings);
        return tree.patch(Object.assign({ sortedPatch: patchAfterSort, patchAtLastSort: fixItemBetweenSortings ? patchAtLastSort : updated, getItemTemporaryOrder,
            isDeleted,
            sorting,
            sortBy }, tree.visible.getParams())).visible;
    }, [tree, sorting, fixItemBetweenSortings]);
    return { tree: patchedTree, applyPatch };
}

const isSelectedOrCheckedChanged = (dataSourceState, prevDataSourceState) => {
    var _a;
    return (((_a = dataSourceState.checked) === null || _a === void 0 ? void 0 : _a.length) && !isEqual(prevDataSourceState === null || prevDataSourceState === void 0 ? void 0 : prevDataSourceState.checked, dataSourceState.checked)) || (dataSourceState.selectedId !== null
        && dataSourceState.selectedId !== undefined
        && dataSourceState.selectedId !== (prevDataSourceState === null || prevDataSourceState === void 0 ? void 0 : prevDataSourceState.selectedId));
};
const getChecked = (dataSourceState) => {
    if (dataSourceState.checked !== null) {
        return dataSourceState.checked;
    }
    if (dataSourceState.selectedId !== null && dataSourceState.selectedId !== undefined) {
        return [dataSourceState.selectedId];
    }
    return [];
};

function useDepsChanged(deps) {
    const prevDeps = usePrevious(deps);
    const isDepsChanged = (prevDeps === null || prevDeps === void 0 ? void 0 : prevDeps.length) !== deps.length
        || (prevDeps !== null && prevDeps !== void 0 ? prevDeps : []).some((devVal, index) => devVal !== deps[index]);
    return isDepsChanged;
}

function useUpdateTree({ tree, shouldUpdate, update, }, deps) {
    const treeRef = useRef(null);
    const prevTree = usePrevious(tree);
    const depsChanged = useDepsChanged(deps);
    const updatedTree = useMemo(() => {
        if (treeRef.current === null || prevTree !== tree || shouldUpdate() || depsChanged) {
            treeRef.current = update(tree);
        }
        return treeRef.current;
    }, [tree, depsChanged, ...deps]);
    return updatedTree;
}

function useSelectedOnlyTree({ tree, dataSourceState, isLoading }, deps) {
    const prevDataSourceState = usePrevious(dataSourceState);
    const selectedOnlyTree = useUpdateTree({
        tree,
        shouldUpdate: () => isSelectedOrCheckedChanged(dataSourceState, prevDataSourceState),
        update: (currentTree) => currentTree.buildSelectedOnly(getChecked(dataSourceState)),
    }, [dataSourceState.checked, dataSourceState.selectedId, ...deps]);
    if (isLoading || selectedOnlyTree === null) {
        return tree;
    }
    return selectedOnlyTree;
}

function useSearchTree({ tree, dataSourceState: { search }, getSearchFields, sortSearchByRelevance, isLoading, }, deps = []) {
    const prevSearch = usePrevious(search);
    const searchTree = useUpdateTree({
        tree,
        shouldUpdate: () => search !== prevSearch,
        update: (currentTree) => currentTree.search({ search, getSearchFields, sortSearchByRelevance }),
    }, [search, ...deps]);
    if (isLoading || searchTree === null) {
        return tree;
    }
    return searchTree;
}

function useSortTree({ tree, dataSourceState: { sorting }, sortBy, isLoading, }, deps) {
    const prevSorting = usePrevious(sorting);
    const sortTree = useUpdateTree({
        tree,
        shouldUpdate: () => sorting !== prevSorting,
        update: (currentTree) => currentTree.sort({ sorting, sortBy, getId: tree.visible.getParams().getId }),
    }, [sorting, ...deps]);
    if (isLoading || sortTree === null) {
        return tree;
    }
    return sortTree;
}

function useFilterTree({ tree, dataSourceState: { filter }, getFilter, isLoading }, deps) {
    const prevFilter = usePrevious(filter);
    const filteredTree = useUpdateTree({
        tree,
        shouldUpdate: () => filter !== prevFilter,
        update: (currentTree) => currentTree.filter({ filter, getFilter }),
    }, [filter, ...deps]);
    if (isLoading || filteredTree === null) {
        return tree;
    }
    return filteredTree;
}

function useActualItemsMap({ tree, itemsMap, }) {
    return useMemo(() => {
        // if clear cache was executed, itemsMap should not be rewritten.
        if (!itemsMap.size) {
            return tree;
        }
        return tree.updateItemsMap(itemsMap);
    }, [tree, itemsMap]);
}

const searchWasChanged = (prevValue, newValue) => (newValue === null || newValue === void 0 ? void 0 : newValue.search) !== (prevValue === null || prevValue === void 0 ? void 0 : prevValue.search);
const sortingWasChanged = (prevValue, newValue) => !isEqual(newValue === null || newValue === void 0 ? void 0 : newValue.sorting, prevValue === null || prevValue === void 0 ? void 0 : prevValue.sorting);
const filterWasChanged = (prevValue, newValue) => !isEqual(newValue === null || newValue === void 0 ? void 0 : newValue.filter, prevValue === null || prevValue === void 0 ? void 0 : prevValue.filter);
const isQueryChanged = (prevValue, newValue) => searchWasChanged(prevValue, newValue)
    || sortingWasChanged(prevValue, newValue)
    || filterWasChanged(prevValue, newValue)
    || (newValue === null || newValue === void 0 ? void 0 : newValue.page) !== (prevValue === null || prevValue === void 0 ? void 0 : prevValue.page)
    || (newValue === null || newValue === void 0 ? void 0 : newValue.pageSize) !== (prevValue === null || prevValue === void 0 ? void 0 : prevValue.pageSize);

function useLazyFetchingAdvisor({ dataSourceState, filter, forceReload, backgroundReload, showSelectedOnly, }, deps = []) {
    const depsChanged = useDepsChanged(deps);
    const areMoreRowsNeeded = useCallback((prevValue, newValue) => {
        const isFetchPositionAndAmountChanged = (prevValue === null || prevValue === void 0 ? void 0 : prevValue.topIndex) !== (newValue === null || newValue === void 0 ? void 0 : newValue.topIndex)
            || (prevValue === null || prevValue === void 0 ? void 0 : prevValue.visibleCount) !== (newValue === null || newValue === void 0 ? void 0 : newValue.visibleCount);
        return isFetchPositionAndAmountChanged;
    }, []);
    const prevFilter = usePrevious(filter);
    const prevDataSourceState = usePrevious(dataSourceState);
    const prevShowSelectedOnly = usePrevious(showSelectedOnly);
    const isFoldingChanged = !prevDataSourceState || dataSourceState.folded !== prevDataSourceState.folded;
    const shouldRefetch = useMemo(() => !prevDataSourceState
        || !isEqual(prevFilter, filter)
        || isQueryChanged(prevDataSourceState, dataSourceState)
        || (prevShowSelectedOnly !== showSelectedOnly && !showSelectedOnly)
        || forceReload
        || depsChanged, [dataSourceState, filter, forceReload, depsChanged]);
    const moreRowsNeeded = areMoreRowsNeeded(prevDataSourceState, dataSourceState);
    const shouldReload = shouldRefetch && !backgroundReload;
    const shouldLoad = isFoldingChanged || moreRowsNeeded || shouldReload;
    const shouldFetch = shouldRefetch || isFoldingChanged || moreRowsNeeded;
    return useMemo(() => ({
        shouldLoad,
        shouldRefetch,
        shouldFetch,
        shouldReload,
    }), [shouldLoad, shouldRefetch, shouldFetch]);
}

function useLazyTree(_a, deps) {
    var { flattenSearchResults = true } = _a, restProps = __rest(_a, ["flattenSearchResults"]);
    const props = Object.assign({ flattenSearchResults }, restProps);
    const { filter, backgroundReload, showSelectedOnly, isFoldedByDefault, getId, getParentId, setDataSourceState, cascadeSelection, getRowOptions, rowOptions, selectAll, fetchStrategy, getChildCount, itemsStatusMap, complexIds, patch, isDeleted, getNewItemPosition, sortBy, fixItemBetweenSortings, getItemTemporaryOrder, } = props;
    const dataSourceState = useDataSourceStateWithDefaults({ dataSourceState: props.dataSourceState });
    const { itemsMap, setItems } = useItemsStorage({
        itemsMap: props.itemsMap,
        setItems: props.setItems,
        params: { getId, complexIds },
    });
    const itemsStatusCollector = useItemsStatusCollector({
        itemsStatusCollector: props.itemsStatusCollector,
        itemsStatusMap,
        complexIds,
        getId,
        dataSourceState,
        patch,
    }, [itemsStatusMap, props.itemsStatusCollector]);
    const api = useMemo(() => itemsStatusCollector.watch(props.api), [itemsStatusCollector, props.api]);
    const blankTree = useMemo(() => TreeState.blank({ getId, getParentId, getChildCount, complexIds }, itemsMap, setItems), deps);
    const [treeWithData, setTreeWithData] = useState(blankTree);
    const prevDataSourceState = usePrevious(dataSourceState);
    const [isFetching, setIsFetching] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [isForceReload, setIsForceReload] = useState(false);
    const { isFolded } = useFoldingService({
        getId,
        isFoldedByDefault,
        dataSourceState,
        setDataSourceState,
    });
    useEffect(() => {
        setTreeWithData(blankTree);
    }, [blankTree]);
    const { loadMissing, loadMissingOnCheck } = useLoadData$1({
        api,
        filter,
        dataSourceState,
        isFolded,
        fetchStrategy,
        flattenSearchResults,
        getChildCount,
        cascadeSelection,
    });
    const loadMissingRecordsOnCheck = useCallback((id, isChecked, isRoot) => __awaiter(this, void 0, void 0, function* () {
        const newTree = yield loadMissingOnCheck(tree, id, isChecked, isRoot);
        if (tree !== treeWithData || tree !== newTree) {
            setTreeWithData(newTree);
        }
        return newTree.full;
    }), [loadMissingOnCheck, setTreeWithData, treeWithData]);
    const { shouldRefetch, shouldLoad, shouldFetch } = useLazyFetchingAdvisor({
        dataSourceState,
        filter,
        forceReload: isForceReload,
        backgroundReload,
        showSelectedOnly,
    }, [...deps]);
    const treeWithDataActual = useActualItemsMap({
        tree: treeWithData,
        itemsMap,
    });
    useEffect(() => {
        if (showSelectedOnly && isSelectedOrCheckedChanged(dataSourceState, prevDataSourceState)) {
            loadMissing({
                tree: treeWithDataActual,
                using: 'full',
                abortInProgress: shouldRefetch,
                dataSourceState: {
                    visibleCount: 0,
                    topIndex: 0,
                },
            })
                .then(({ isUpdated, isOutdated, tree: newTree }) => {
                if (!isOutdated && (isUpdated || newTree !== treeWithDataActual)) {
                    setTreeWithData(newTree);
                }
            });
        }
    }, [showSelectedOnly, dataSourceState.checked, dataSourceState.selectedId]);
    useEffect(() => {
        if (showSelectedOnly) {
            return;
        }
        let currentTree = treeWithDataActual;
        if (shouldRefetch) {
            setIsFetching(true);
            currentTree = treeWithDataActual.clearStructure();
        }
        if (shouldLoad) {
            if (currentTree !== treeWithDataActual) {
                setTreeWithData(currentTree);
            }
            setIsLoading(true);
        }
        if (shouldFetch) {
            loadMissing({
                tree: currentTree,
                using: 'visible',
                abortInProgress: shouldRefetch,
            })
                .then(({ isUpdated, isOutdated, tree: newTree }) => {
                if (!isOutdated && (isUpdated || newTree !== treeWithDataActual)) {
                    setTreeWithData(newTree);
                }
            }).finally(() => {
                setIsFetching(false);
                setIsLoading(false);
                if (isForceReload === true) {
                    setIsForceReload(false);
                }
            });
        }
    }, [
        showSelectedOnly,
        shouldFetch,
        shouldLoad,
        shouldRefetch,
    ]);
    const treeWithSelectedOnly = useSelectedOnlyTree({
        tree: treeWithDataActual,
        dataSourceState,
        isLoading: isLoading || isFetching,
    }, [treeWithDataActual]);
    const treeWithNewItemsMap = useActualItemsMap({
        tree: treeWithSelectedOnly,
        itemsMap,
    });
    const { tree, applyPatch } = usePatchTree({
        tree: treeWithNewItemsMap,
        patch: showSelectedOnly ? null : patch,
        isDeleted,
        getNewItemPosition,
        getItemTemporaryOrder,
        fixItemBetweenSortings,
        sorting: dataSourceState.sorting,
        sortBy,
    });
    const reload = useCallback(() => {
        setIsForceReload(true);
    }, [props, setTreeWithData]);
    const totalCount = useMemo(() => {
        var _a, _b;
        const { totalCount: rootTotalCount } = tree.visible.getItems(undefined);
        return rootTotalCount !== null && rootTotalCount !== void 0 ? rootTotalCount : (_b = (_a = tree.visible).getTotalCount) === null || _b === void 0 ? void 0 : _b.call(_a);
    }, [tree.visible]);
    return {
        tree: showSelectedOnly ? tree.selectedOnly : tree.visible,
        treeWithoutPatch: treeWithSelectedOnly.visible,
        selectionTree: tree.full,
        totalCount,
        dataSourceState,
        setDataSourceState,
        isFoldedByDefault,
        getId,
        getParentId,
        cascadeSelection,
        getRowOptions,
        rowOptions,
        reload,
        isFetching,
        isLoading,
        getItemStatus: itemsStatusCollector.getItemStatus(itemsMap),
        flattenSearchResults,
        loadMissingRecordsOnCheck,
        showSelectedOnly,
        selectAll,
        applyPatch,
    };
}

function merge(mergeSrcArr, mergeTgArr, compare, initialArr = [], options = {}) {
    const { complexIds, isDeleted } = options;
    let srcItemIndex = 0, tgItemIndex = 0, isUpdated = false;
    const merged = [...initialArr];
    const patchedItems = newMap({ complexIds });
    mergeSrcArr.forEach((id) => {
        patchedItems.set(id, true);
    });
    while (srcItemIndex < mergeSrcArr.length || tgItemIndex < mergeTgArr.length) {
        if (srcItemIndex >= mergeSrcArr.length) {
            if (!patchedItems.get(mergeTgArr[tgItemIndex]) && !(isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(mergeTgArr[tgItemIndex]))) {
                merged.push(mergeTgArr[tgItemIndex]);
            }
            if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(mergeTgArr[tgItemIndex])) {
                isUpdated = true;
            }
            tgItemIndex++;
            continue;
        }
        if (tgItemIndex >= mergeTgArr.length) {
            if (!(isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(mergeSrcArr[srcItemIndex]))) {
                merged.push(mergeSrcArr[srcItemIndex]);
                isUpdated = true;
            }
            srcItemIndex++;
            continue;
        }
        const srcItemId = mergeSrcArr[srcItemIndex];
        const tgItemId = mergeTgArr[tgItemIndex];
        if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(srcItemId)) {
            srcItemIndex++;
            continue;
        }
        if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(tgItemId)) {
            isUpdated = true;
            tgItemIndex++;
            continue;
        }
        if (patchedItems.has(tgItemId)) {
            isUpdated = true;
            tgItemIndex++;
            continue;
        }
        const result = compare(srcItemId, tgItemId, srcItemIndex, tgItemIndex);
        if (result === -1) {
            merged.push(srcItemId);
            isUpdated = true;
            srcItemIndex++;
        }
        else {
            if (!patchedItems.has(tgItemId) && !(isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(tgItemId))) {
                merged.push(tgItemId);
            }
            if (isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(tgItemId)) {
                isUpdated = true;
            }
            tgItemIndex++;
        }
    }
    return [merged, isUpdated];
}

class PatchHelper {
    static applyPatchWithSorting(patchIds, originalIds, { comparator, patchAtLastSort, originalItemsMap, patchedItemsMap, isDeleted, complexIds, }, initialIds = []) {
        return merge(patchIds, originalIds, (patchItemId, itemId) => {
            const inPatchBeforeSort = patchAtLastSort.has(patchItemId);
            const inOriginalTree = originalItemsMap.has(patchItemId);
            let patchItemToCompare;
            if (inPatchBeforeSort) {
                patchItemToCompare = patchAtLastSort.get(patchItemId);
            }
            else if (inOriginalTree) {
                patchItemToCompare = originalItemsMap.get(patchItemId);
            }
            else {
                patchItemToCompare = patchedItemsMap.get(patchItemId);
            }
            const item = originalItemsMap.get(itemId);
            return comparator(patchItemToCompare, item);
        }, initialIds, { isDeleted, complexIds });
    }
    static applyPatchTemporaryReordering(patchIds, originalIds, { getItemTemporaryOrder, patchedItemsMap, isDeleted, complexIds, }) {
        return merge(patchIds, originalIds, (patchItemId, itemId, _, itemIndex) => {
            var _a;
            const a = patchedItemsMap.get(patchItemId);
            const b = patchedItemsMap.get(itemId);
            const aTempOrder = getItemTemporaryOrder(a);
            const bTempOrder = (_a = getItemTemporaryOrder(b)) !== null && _a !== void 0 ? _a : indexToOrder(itemIndex);
            return simpleComparator(aTempOrder, bTempOrder);
        }, [], { isDeleted, complexIds });
    }
    static patch({ itemsMap: originalItemsMap, treeStructure, sortedPatch, patchAtLastSort, getItemTemporaryOrder, isDeleted, sorting, sortBy, }) {
        var _a, _b, _c;
        if (!sortedPatch || !sortedPatch.size)
            return { treeStructure, itemsMap: originalItemsMap, newItems: [] };
        const newByParentId = cloneMap(treeStructure.byParentId); // shallow clone, still need to copy arrays inside!
        let patchedItemsMap = originalItemsMap;
        let newItems = [];
        const comparators = buildComparators({ sorting, sortBy, getId: treeStructure.getParams().getId });
        const composedComparator = composeComparators(comparators, treeStructure.getParams().getId);
        const complexIds = treeStructure.getParams().complexIds;
        const parentsWithNewChildren = newMap({ complexIds });
        let isUpdated = false;
        for (const [patchParentId, sorted] of sortedPatch) {
            patchedItemsMap = patchedItemsMap.setItems(sorted.newItems);
            newItems = newItems.concat(sorted.newItems);
            const itemIds = (_a = newByParentId.get(patchParentId)) !== null && _a !== void 0 ? _a : [];
            // eslint-disable-next-line no-loop-func
            const isDeletedFn = (id) => { var _a; return (_a = isDeleted === null || isDeleted === void 0 ? void 0 : isDeleted(patchedItemsMap.get(id))) !== null && _a !== void 0 ? _a : false; };
            const [sortedItems, isUpdatedOnPatch] = this.applyPatchWithSorting(sorted.updated, itemIds, {
                comparator: composedComparator,
                patchAtLastSort,
                originalItemsMap,
                patchedItemsMap,
                isDeleted: isDeletedFn,
                complexIds,
            }, sorted.top);
            const sortedItemsWithBottom = sortedItems.concat(sorted.bottom);
            const [reorderedItems, isUpdatedOnReordering] = this.applyPatchTemporaryReordering(sorted.withTempOrder, sortedItemsWithBottom, {
                getItemTemporaryOrder,
                patchedItemsMap,
                isDeleted: isDeletedFn,
                complexIds,
            });
            // eslint-disable-next-line no-loop-func
            sorted.moved.forEach((id) => {
                var _a, _b, _c, _d, _e, _f;
                const item = treeStructure.getById(id);
                if (item !== NOT_FOUND_RECORD) {
                    const parentId = (_c = (_b = (_a = treeStructure.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item)) !== null && _c !== void 0 ? _c : undefined;
                    const prevItems = newByParentId.get(parentId);
                    newByParentId.set(parentId, prevItems.filter((itemId) => itemId !== id));
                }
                const newItem = patchedItemsMap.get(id);
                const newParentId = (_f = (_e = (_d = treeStructure.getParams()).getParentId) === null || _e === void 0 ? void 0 : _e.call(_d, newItem)) !== null && _f !== void 0 ? _f : undefined;
                parentsWithNewChildren.set(newParentId, true);
            });
            newByParentId.set(patchParentId, reorderedItems);
            if (isUpdatedOnReordering || isUpdatedOnPatch || sorted.top.length || sorted.bottom.length || sorted.moved.length) {
                isUpdated = true;
            }
        }
        if (!isUpdated) {
            return { treeStructure, itemsMap: originalItemsMap, newItems };
        }
        const newNodeInfoById = cloneMap(treeStructure.nodeInfoById);
        for (const [parentId, ids] of newByParentId) {
            if (treeStructure.nodeInfoById.has(parentId)) {
                const prevNodeInfo = treeStructure.nodeInfoById.get(parentId);
                if (prevNodeInfo.count !== undefined) {
                    // Count, different from ids.length can be sent by server.
                    // After patch, it is required to add a delta of new and old children, to figure out,
                    // how patch affected count by adding/deleting/moving children.
                    const newCount = prevNodeInfo.count + (ids.length - ((_c = (_b = treeStructure.byParentId.get(parentId)) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0));
                    newNodeInfoById.set(parentId, Object.assign(Object.assign({}, prevNodeInfo), { count: newCount }));
                }
                else if (parentsWithNewChildren.has(parentId)) {
                    const { assumedCount } = prevNodeInfo, prev = __rest(prevNodeInfo, ["assumedCount"]);
                    newNodeInfoById.set(parentId, Object.assign(Object.assign({}, prev), (assumedCount === undefined ? { count: ids.length } : { assumedCount })));
                }
            }
            else {
                newNodeInfoById.set(parentId, { count: ids.length });
            }
        }
        return {
            treeStructure: TreeStructure.create(treeStructure.getParams(), ItemsAccessor.toItemsAccessor(patchedItemsMap), newByParentId, newNodeInfoById),
            itemsMap: patchedItemsMap,
            newItems,
        };
    }
}

class TreeHelper {
    static getParents(id, tree) {
        var _a, _b;
        const parentIds = [];
        let parentId = id;
        while (true) {
            const item = tree.getById(parentId);
            if (item === NOT_FOUND_RECORD) {
                break;
            }
            parentId = (_b = (_a = tree.getParams()).getParentId) === null || _b === void 0 ? void 0 : _b.call(_a, item);
            if (parentId === undefined) {
                break;
            }
            parentIds.unshift(parentId);
        }
        return parentIds;
    }
}

class TreeState {
    constructor(_fullTree, _visibleTree, _selectedOnlyTree, _itemsMap, _setItems) {
        this._fullTree = _fullTree;
        this._visibleTree = _visibleTree;
        this._selectedOnlyTree = _selectedOnlyTree;
        this._itemsMap = _itemsMap;
        this._setItems = _setItems;
    }
    get itemsMap() {
        return this._itemsMap;
    }
    get setItems() {
        return this._setItems;
    }
    get visible() {
        return this._visibleTree;
    }
    get selectedOnly() {
        return this._selectedOnlyTree;
    }
    get full() {
        return this._fullTree;
    }
    getById(id) {
        return this.itemsMap.has(id) ? this.itemsMap.get(id) : NOT_FOUND_RECORD;
    }
    load(_a) {
        return __awaiter(this, arguments, void 0, function* ({ using, options, dataSourceState, }) {
            const treeStructure = this.getTreeStructure(using);
            const { loadedItems, byParentId, nodeInfoById } = yield FetchingHelper.load({
                tree: treeStructure,
                options,
                dataSourceState,
            });
            if (!loadedItems.length && !byParentId.size && !nodeInfoById.size) {
                if (using === undefined && treeStructure !== this.getTreeStructure('visible')) {
                    return this.withNewTreeStructures({
                        using,
                        treeStructure,
                        itemsMap: this.itemsMap,
                    });
                }
                return this;
            }
            const itemsMap = loadedItems.length ? this.setItems(loadedItems, { on: 'load' }) : this.itemsMap;
            const newByParentId = byParentId.size ? cloneMap(treeStructure.byParentId) : treeStructure.byParentId;
            for (const [id, ids] of byParentId) {
                newByParentId.set(id, ids);
            }
            const newNodeInfoById = nodeInfoById.size ? cloneMap(treeStructure.nodeInfoById) : treeStructure.nodeInfoById;
            for (const [id, nodeInfo] of nodeInfoById) {
                newNodeInfoById.set(id, nodeInfo);
            }
            let treeToUpdate = using;
            if (treeToUpdate === 'visible') {
                treeToUpdate = dataSourceState.search ? 'visible' : undefined;
            }
            return this.withNewTreeStructures({
                using: treeToUpdate,
                treeStructure: TreeStructure.create(treeStructure.getParams(), ItemsAccessor.toItemsAccessor(itemsMap), newByParentId, newNodeInfoById),
                itemsMap,
            });
        });
    }
    loadAll(_a) {
        return __awaiter(this, arguments, void 0, function* ({ using, options, dataSourceState, }) {
            const treeStructure = this.getTreeStructure(using);
            const { treeStructure: newTreeStructure, itemsMap: newItemsMap, loadedItems } = yield FetchingHelper.loadAll({
                treeStructure,
                itemsMap: this.itemsMap,
                options,
                dataSourceState,
            });
            if (newTreeStructure === treeStructure && newItemsMap === this.itemsMap && !loadedItems.length) {
                return this;
            }
            if (loadedItems.length) {
                this.setItems(loadedItems, { reset: true });
            }
            return this.withNewTreeStructures({ using, treeStructure: newTreeStructure, itemsMap: newItemsMap });
        });
    }
    filter({ filter, getFilter, }) {
        const treeStructure = this.getTreeStructure('full');
        const newTreeStructure = FilterHelper.filter({ treeStructure, getFilter, filter });
        if (treeStructure === newTreeStructure) {
            return this;
        }
        return this.withNewTreeStructures({ treeStructure: newTreeStructure, itemsMap: this.itemsMap });
    }
    sort({ getId, sorting, sortBy, }) {
        const treeStructure = this.getTreeStructure('full');
        const newTreeStructure = SortHelper.sort({ treeStructure, sorting, sortBy, getId });
        if (treeStructure === newTreeStructure) {
            return this;
        }
        return this.withNewTreeStructures({ treeStructure: newTreeStructure, itemsMap: this.itemsMap });
    }
    search({ search, getSearchFields, sortSearchByRelevance, }) {
        const treeStructure = this.getTreeStructure('full');
        const newTreeStructure = SearchHelper.search({ treeStructure, search, getSearchFields, sortSearchByRelevance });
        if (newTreeStructure === treeStructure) {
            return this;
        }
        return this.withNewTreeStructures({ using: 'visible', treeStructure: newTreeStructure, itemsMap: this.itemsMap });
    }
    patchTreeStructure({ treeStructure, itemsMap, sortedPatch, patchAtLastSort, getItemTemporaryOrder, isDeleted, sorting, sortBy }) {
        const { treeStructure: newTreeStructure, itemsMap: newItemsMap, newItems } = PatchHelper.patch({
            treeStructure,
            itemsMap: itemsMap,
            sortedPatch,
            patchAtLastSort,
            getItemTemporaryOrder,
            isDeleted,
            sorting,
            sortBy,
        });
        if (newTreeStructure === treeStructure && newItemsMap === itemsMap && !newItems.length) {
            return { treeStructure, itemsMap };
        }
        return { treeStructure: newTreeStructure, itemsMap: newItemsMap };
    }
    patch({ sortedPatch, patchAtLastSort, getItemTemporaryOrder, isDeleted, sorting, sortBy }) {
        const { treeStructure: newFull } = this.patchTreeStructure({
            treeStructure: this.getTreeStructure('full'),
            itemsMap: this.itemsMap,
            sortedPatch,
            patchAtLastSort,
            getItemTemporaryOrder,
            isDeleted,
            sorting,
            sortBy,
        });
        const { treeStructure: newVisible, itemsMap: updatedItemsMap } = this.patchTreeStructure({
            treeStructure: this.getTreeStructure('visible'),
            itemsMap: this.itemsMap,
            sortedPatch,
            patchAtLastSort,
            getItemTemporaryOrder,
            isDeleted,
            sorting,
            sortBy,
        });
        if (this.getTreeStructure('full') === newFull && this.getTreeStructure('visible') === newVisible) {
            return this;
        }
        const itemsAccessor = ItemsAccessor.toItemsAccessor(updatedItemsMap);
        const selectedOnly = TreeStructure.withNewItemsAccessor(itemsAccessor, this._selectedOnlyTree);
        return TreeState.create(newFull, newVisible, selectedOnly, updatedItemsMap, this._setItems);
    }
    /**
     * TODO: Add later `selectedOnlyMode: 'tree' | 'flat'.
     */
    buildSelectedOnlyTree(checkedIds) {
        const foundIds = checkedIds
            .filter((id) => this.getById(id) !== NOT_FOUND_RECORD);
        let items = new ItemsMap(null, this.selectedOnly.getParams());
        foundIds.forEach((id) => {
            const parents = TreeHelper.getParents(id, this.full);
            parents
                .filter((parentId) => !items.has(parentId) && this.getById(parentId) !== NOT_FOUND_RECORD)
                .forEach((parentId) => {
                items = items.set(parentId, this.getById(parentId));
            });
            items = items.set(id, this.getById(id));
        });
        const newSelectedOnly = TreeStructure.createFromItems({
            params: this.selectedOnly.getParams(),
            items,
            itemsAccessor: ItemsAccessor.toItemsAccessor(this.itemsMap),
        });
        return TreeState.create(this.full, this.visible, newSelectedOnly, this.itemsMap, this.setItems);
    }
    buildSelectedOnly(checkedIds) {
        const foundIds = (checkedIds !== null && checkedIds !== void 0 ? checkedIds : [])
            .filter((id) => this.getById(id) !== NOT_FOUND_RECORD);
        const byParentId = newMap(this.selectedOnly.getParams());
        const nodeInfoById = newMap(this.selectedOnly.getParams());
        byParentId.set(undefined, foundIds);
        nodeInfoById.set(undefined, { count: foundIds.length });
        const newSelectedOnly = TreeStructure.create(this.selectedOnly.getParams(), ItemsAccessor.toItemsAccessor(this.itemsMap), byParentId, nodeInfoById);
        return TreeState.create(this.full, this.visible, newSelectedOnly, this.itemsMap, this.setItems);
    }
    updateItemsMap(itemsMap) {
        if (itemsMap === this.itemsMap) {
            return this;
        }
        const itemsAccessor = ItemsAccessor.toItemsAccessor(itemsMap);
        return new TreeState(TreeStructure.withNewItemsAccessor(itemsAccessor, this.full), TreeStructure.withNewItemsAccessor(itemsAccessor, this.visible), TreeStructure.withNewItemsAccessor(itemsAccessor, this.selectedOnly), itemsMap, this.setItems);
    }
    getTreeStructure(treeStructureId = 'full') {
        return (treeStructureId !== null && treeStructureId !== void 0 ? treeStructureId : 'full') === 'full' ? this._fullTree : this._visibleTree;
    }
    clearStructure() {
        return TreeState.create(this.full, TreeStructure.create(this.visible.getParams(), ItemsAccessor.toItemsAccessor(this.itemsMap)), this.selectedOnly, this.itemsMap, this.setItems);
    }
    reset() {
        return TreeState.create(this.full, this.full, this.selectedOnly, this.itemsMap, this.setItems);
    }
    withNewTreeStructures({ using, treeStructure, itemsMap, }) {
        const itemsAccessor = ItemsAccessor.toItemsAccessor(itemsMap);
        const selectedOnly = TreeStructure.withNewItemsAccessor(itemsAccessor, this._selectedOnlyTree);
        if (!using) {
            return TreeState.create(treeStructure, treeStructure, selectedOnly, itemsMap, this._setItems);
        }
        const visibleTree = using === 'visible'
            ? treeStructure
            : TreeStructure.withNewItemsAccessor(itemsAccessor, this._visibleTree);
        const fullTree = using === 'full'
            ? treeStructure
            : TreeStructure.withNewItemsAccessor(itemsAccessor, this._fullTree);
        return TreeState.create(fullTree, visibleTree, selectedOnly, itemsMap, this._setItems);
    }
    static create(fullTree, visibleTree, selectedOnlyTree, itemsMap, setItems) {
        return new TreeState(fullTree, visibleTree, selectedOnlyTree, itemsMap, setItems);
    }
    static createFromItems(items, itemsMap, params, setItems) {
        if (items === undefined && itemsMap === undefined) {
            throw Error('At least one of the following args should be defined: `items` or `itemsMap`.');
        }
        let treeItemsMap;
        if (itemsMap) {
            treeItemsMap = items ? itemsMap.setItems(items) : itemsMap;
        }
        else {
            treeItemsMap = new ItemsMap(new Map(), params).setItems(items);
        }
        const itemsAccessor = ItemsAccessor.toItemsAccessor(treeItemsMap);
        const treeStructure = TreeStructure.createFromItems({ params, items: items !== null && items !== void 0 ? items : treeItemsMap, itemsAccessor });
        return new TreeState(treeStructure, treeStructure, TreeStructure.create(params, ItemsAccessor.toItemsAccessor(itemsMap)), treeItemsMap, setItems);
    }
    static createFromItemsMap(itemsMap, setItems, params) {
        const itemsAccessor = ItemsAccessor.toItemsAccessor(itemsMap);
        const treeStructure = TreeStructure.createFromItems({ params, items: itemsMap, itemsAccessor });
        return new TreeState(treeStructure, treeStructure, TreeStructure.create(params, ItemsAccessor.toItemsAccessor(itemsMap)), itemsMap, setItems);
    }
    static blank(params, itemsMap, setItems) {
        const treeStructure = TreeStructure.create(params, ItemsAccessor.toItemsAccessor(itemsMap));
        return this.create(treeStructure, treeStructure, treeStructure, itemsMap, setItems);
    }
}

function useLoadData({ tree, api, dataSourceState, showSelectedOnly, isLoaded: isPrevouslyLoaded, complexIds, getId, onForceReloadComplete, forceReload, patch, itemsStatusCollector: externalItemsStatusCollector, itemsStatusMap, }, deps) {
    const prevDataSourceState = usePrevious(dataSourceState);
    const prevForceReload = usePrevious(forceReload);
    const [loadedTree, setLoadedTree] = useState(tree);
    const [isLoaded, setIsLoaded] = useState(isPrevouslyLoaded);
    const [isLoading, setIsLoading] = useState(false);
    const [isFetching, setIsFetching] = useState(false);
    const itemsStatusCollector = useItemsStatusCollector({
        itemsStatusMap,
        complexIds,
        getId,
        itemsStatusCollector: externalItemsStatusCollector,
        dataSourceState,
        patch,
    }, [itemsStatusMap, externalItemsStatusCollector]);
    const watchedApi = useMemo(() => itemsStatusCollector.watch(api), [itemsStatusCollector, api]);
    const loadData = useCallback((sourceTree_1, ...args_1) => __awaiter(this, [sourceTree_1, ...args_1], void 0, function* (sourceTree, dsState = {}) {
        const loadingTree = sourceTree;
        const partialDsState = __rest(dsState, ["checked"]);
        try {
            const newTreePromise = sourceTree.loadAll({
                using: partialDsState.search ? 'visible' : undefined,
                options: {
                    api: watchedApi,
                    filter: Object.assign({}, dsState === null || dsState === void 0 ? void 0 : dsState.filter),
                },
                dataSourceState: partialDsState,
            });
            const newTree = yield newTreePromise;
            const linkToTree = sourceTree;
            // If tree is changed during this load, than there was reset occurred (new value arrived)
            // We need to tell caller to reject this result
            const isOutdated = linkToTree !== loadingTree;
            const isUpdated = linkToTree !== newTree;
            return { isUpdated, isOutdated, tree: newTree };
        }
        catch (e) {
            // TBD - correct error handling
            console.error('useLoadData: Error while loading items.', e);
            return { isUpdated: false, isOutdated: false, tree: loadingTree, error: e };
        }
    }), [api]);
    const depsChanged = useDepsChanged(deps);
    const shouldForceReload = prevForceReload !== forceReload && forceReload;
    const shouldLoad = (!isFetching
        && !isLoaded
        && (!showSelectedOnly || (showSelectedOnly && getSelectedAndChecked(dataSourceState, patch).length))) || forceReload;
    useEffect(() => {
        if (shouldForceReload) {
            setLoadedTree(tree);
        }
    }, [shouldForceReload]);
    useEffect(() => {
        if (shouldLoad) {
            setIsFetching(true);
            if (!isQueryChanged(prevDataSourceState, dataSourceState)) {
                setIsLoading(true);
            }
            const checked = getSelectedAndChecked(dataSourceState, patch);
            loadData(tree, dataSourceState)
                .then(({ isOutdated, isUpdated, tree: newTree }) => {
                if (isUpdated && !isOutdated) {
                    setLoadedTree(newTree);
                    const notLoaded = checked.filter((id) => newTree.getById(id) === NOT_FOUND_RECORD);
                    itemsStatusCollector.setNotFound(notLoaded);
                    if (forceReload) {
                        onForceReloadComplete();
                    }
                }
            })
                .catch((e) => {
                itemsStatusCollector.setFailed(checked);
                throw e;
            })
                .finally(() => {
                setIsLoaded(true);
                setIsFetching(false);
                setIsLoading(false);
            });
        }
    }, [shouldLoad, depsChanged, shouldForceReload]);
    return { tree: loadedTree, isLoading, isFetching, isLoaded, itemsStatusCollector };
}

function useAsyncTree(props, deps) {
    const { getId, complexIds, getParentId, getFilter, getSearchFields, sortBy, sortSearchByRelevance = true, rowOptions, getRowOptions, setDataSourceState, isFoldedByDefault, cascadeSelection, showSelectedOnly, patch, isDeleted, getNewItemPosition, itemsStatusMap, selectAll, isLoaded, getItemTemporaryOrder, fixItemBetweenSortings, } = props;
    const { itemsMap, setItems } = useItemsStorage({
        itemsMap: props.itemsMap,
        setItems: props.setItems,
        params: { getId, complexIds },
    });
    const [isForceReload, setIsForceReload] = useState(false);
    const baseTree = useMemo(() => {
        if (isLoaded) {
            return TreeState.createFromItemsMap(itemsMap, setItems, { getId, getParentId, complexIds });
        }
        return TreeState.blank({ getId, getParentId, complexIds }, itemsMap, setItems);
    }, [...deps, isLoaded]);
    const [incommingTree, setIncommingTree] = useState(baseTree);
    const prevIsForceReload = usePrevious(isForceReload);
    const dataSourceState = useDataSourceStateWithDefaults({ dataSourceState: props.dataSourceState });
    const { tree: treeWithData, itemsStatusCollector, isLoaded: isTreeLoaded, isLoading, isFetching } = useLoadData({
        getId,
        complexIds,
        api: () => props.api().then((items) => ({ items })),
        tree: incommingTree,
        dataSourceState: {
            visibleCount: dataSourceState.visibleCount,
            topIndex: dataSourceState.topIndex,
            checked: dataSourceState.checked,
            selectedId: dataSourceState.selectedId,
        },
        itemsStatusCollector: props.itemsStatusCollector,
        forceReload: isForceReload,
        onForceReloadComplete: () => setIsForceReload(false),
        showSelectedOnly,
        isLoaded,
        itemsStatusMap,
    }, [...deps, isForceReload, incommingTree]);
    const prevIsFetching = usePrevious(isFetching);
    useEffect(() => {
        if (prevIsForceReload !== isForceReload && isForceReload
            && prevIsFetching !== isFetching && !isFetching) {
            setIsForceReload(false);
        }
    }, [treeWithData]);
    const reload = useCallback(() => {
        setIncommingTree(TreeState.blank({ getId, getParentId, complexIds }, itemsMap, setItems));
        setIsForceReload(true);
    }, [setIsForceReload]);
    const isTreeLoading = !isTreeLoaded || isLoading || isFetching;
    const filteredTree = useFilterTree({ tree: treeWithData, getFilter, dataSourceState, isLoading: isTreeLoading }, [treeWithData, isTreeLoading]);
    const sortTree = useSortTree({ tree: filteredTree, sortBy, dataSourceState, isLoading: isTreeLoading }, [filteredTree, isTreeLoading]);
    const searchTree = useSearchTree({
        tree: sortTree,
        getSearchFields,
        sortSearchByRelevance,
        dataSourceState,
        isLoading: isTreeLoading,
    }, [sortTree, isTreeLoading]);
    const treeWithSelectedOnly = useSelectedOnlyTree({
        tree: searchTree,
        dataSourceState,
        isLoading: isTreeLoading,
    }, [searchTree, isTreeLoading]);
    const { tree, applyPatch } = usePatchTree({
        tree: treeWithSelectedOnly,
        patch: showSelectedOnly ? null : patch,
        isDeleted,
        getNewItemPosition,
        getItemTemporaryOrder,
        fixItemBetweenSortings,
        sorting: dataSourceState.sorting,
        sortBy,
    });
    const totalCount = useMemo(() => {
        var _a, _b, _c;
        const { totalCount: rootTotalCount } = tree.visible.getItems(undefined);
        return (_c = rootTotalCount !== null && rootTotalCount !== void 0 ? rootTotalCount : (_b = (_a = tree.visible).getTotalCount) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : 0;
    }, [tree.visible]);
    return {
        tree: showSelectedOnly ? tree.selectedOnly : tree.visible,
        treeWithoutPatch: treeWithSelectedOnly.visible,
        selectionTree: tree.full,
        reload,
        totalCount,
        getItemStatus: itemsStatusCollector.getItemStatus(itemsMap),
        rowOptions,
        getRowOptions,
        getParentId,
        getId,
        dataSourceState,
        setDataSourceState,
        isFoldedByDefault,
        cascadeSelection,
        showSelectedOnly,
        selectAll,
        applyPatch,
        isLoading,
        isFetching,
    };
}

function useCreateTree(props, deps) {
    const { items, itemsMap, setItems, complexIds, getId, getParentId } = props;
    const tree = useMemo(() => {
        if (items instanceof TreeState) {
            return items;
        }
        return TreeState.createFromItems(items, itemsMap, { getId, getParentId, complexIds }, setItems);
    }, [...deps, itemsMap]);
    return tree;
}

function useSyncTree(_a, deps) {
    var { sortSearchByRelevance = true, items } = _a, restProps = __rest(_a, ["sortSearchByRelevance", "items"]);
    const props = Object.assign(Object.assign({}, restProps), { sortSearchByRelevance });
    const [triggerValue, trigger] = useState(false);
    const resetTree = useCallback(() => {
        trigger((currentTriggerValue) => !currentTriggerValue);
    }, [trigger]);
    const { getId, getParentId, complexIds, getFilter, getSearchFields, sortBy, rowOptions, getRowOptions, setDataSourceState, isFoldedByDefault, cascadeSelection, showSelectedOnly, selectAll, fixItemBetweenSortings, getNewItemPosition, isDeleted, } = props;
    const { itemsMap, setItems } = useItemsStorage({
        items,
        setItems: props.setItems,
        params: { getId, complexIds },
    });
    const fullTree = useCreateTree({ items, itemsMap, setItems, getId, getParentId, complexIds }, [...deps, items, itemsMap, triggerValue]);
    const dataSourceState = useDataSourceStateWithDefaults({ dataSourceState: props.dataSourceState });
    const filteredTree = useFilterTree({ tree: fullTree, getFilter, dataSourceState }, [fullTree]);
    const sortTree = useSortTree({ tree: filteredTree, sortBy, dataSourceState }, [filteredTree]);
    const searchTree = useSearchTree({ tree: sortTree, getSearchFields, sortSearchByRelevance, dataSourceState }, [sortTree]);
    const treeWithSelectedOnly = useSelectedOnlyTree({
        tree: searchTree,
        dataSourceState,
    }, [searchTree]);
    const { tree, applyPatch } = usePatchTree({
        tree: treeWithSelectedOnly,
        patch: showSelectedOnly ? null : restProps.patch,
        isDeleted,
        getNewItemPosition,
        fixItemBetweenSortings,
        sorting: dataSourceState.sorting,
        sortBy,
    });
    const reload = useCallback(() => {
        resetTree();
    }, [resetTree]);
    const totalCount = useMemo(() => {
        var _a, _b, _c;
        const { totalCount: rootTotalCount } = tree.visible.getItems(undefined);
        return (_c = rootTotalCount !== null && rootTotalCount !== void 0 ? rootTotalCount : (_b = (_a = tree.visible).getTotalCount) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : 0;
    }, [tree.visible]);
    return {
        tree: showSelectedOnly ? tree.selectedOnly : tree.visible,
        treeWithoutPatch: treeWithSelectedOnly.visible,
        selectionTree: tree.full,
        totalCount,
        rowOptions,
        getRowOptions,
        getParentId,
        getId,
        dataSourceState,
        setDataSourceState,
        isFoldedByDefault,
        reload,
        cascadeSelection,
        showSelectedOnly,
        selectAll,
        applyPatch,
    };
}

const strategies = {
    sync: useSyncTree,
    async: useAsyncTree,
    lazy: useLazyTree,
};

function useTree(props, deps) {
    const prevType = usePrevious(props.type);
    if (prevType && props.type !== prevType) {
        throw new Error("Tree type can't be changed between renders");
    }
    const useStrategy = useMemo(() => strategies[props.type], [props.type]);
    const tree = useStrategy(props, [...deps]);
    return tree;
}

const idToKey$1 = (id) => typeof id === 'object' ? JSON.stringify(id) : `${id}`;

const setObjectFlag = (object, key, value) => {
    return Object.assign(Object.assign({}, object), { [key]: value });
};

const isInProgress = (status) => [PENDING_RECORD, LOADING_RECORD].includes(status);

const idToKey = (id) => typeof id === 'object' ? JSON.stringify(id) : `${id}`;
const buildParentsLookup = (ids, tree, getParentId) => {
    const idsByKey = {};
    const someChildInIdsByKey = {};
    const checkedItems = ids !== null && ids !== void 0 ? ids : [];
    for (let i = checkedItems.length - 1; i >= 0; i--) {
        const id = checkedItems[i];
        idsByKey[idToKey(id)] = true;
        if (!tree || !getParentId) {
            continue;
        }
        const item = tree.getById(id);
        if (item === NOT_FOUND_RECORD) {
            continue;
        }
        const parentId = getParentId(item);
        if (!someChildInIdsByKey[idToKey(parentId)]) {
            const parents = Tree.getParents(id, tree).reverse();
            for (const parent of parents) {
                if (someChildInIdsByKey[idToKey(parent)]) {
                    break;
                }
                someChildInIdsByKey[idToKey(parent)] = true;
            }
        }
    }
    return { idsByKey, someChildInIdsByKey };
};

/**
 * Service, which provides checking functionality.
 * @returns checking service.
 */
function useCheckingService({ tree, getParentId, dataSourceState, setDataSourceState, cascadeSelection, getRowOptions, rowOptions, getCompleteTreeForCascadeSelection, getItemStatus, }) {
    var _a;
    const checked = (_a = dataSourceState.checked) !== null && _a !== void 0 ? _a : [];
    const checkingInfoById = useMemo(() => buildParentsLookup(checked, tree, getParentId), [tree, getParentId, checked]);
    const { idsByKey: checkedByKey, someChildInIdsByKey: someChildCheckedByKey } = checkingInfoById;
    const isRowChecked = useCallback((row) => {
        const exactCheck = !!checkedByKey[row.rowKey];
        if (exactCheck || cascadeSelection !== CascadeSelectionTypes.IMPLICIT) {
            return exactCheck;
        }
        const { path } = row;
        return path.some(({ id }) => !!checkedByKey[idToKey(id)]);
    }, [checkedByKey]);
    const isRowChildrenChecked = useCallback((row) => {
        var _a;
        if (cascadeSelection === CascadeSelectionTypes.IMPLICIT) {
            return isRowChecked(row) || someChildCheckedByKey[row.rowKey] || false;
        }
        return (_a = someChildCheckedByKey[row.rowKey]) !== null && _a !== void 0 ? _a : false;
    }, [someChildCheckedByKey, isRowChecked, tree]);
    const getRowProps = useCallback((item) => {
        const externalRowOptions = getRowOptions ? getRowOptions(item) : {};
        return Object.assign(Object.assign({}, rowOptions), externalRowOptions);
    }, [rowOptions, getRowOptions]);
    const isItemCheckable = useCallback((id, item) => {
        var _a, _b;
        if (item === NOT_FOUND_RECORD) {
            if (!getItemStatus) {
                return true;
            }
            const status = getItemStatus(id);
            if (isInProgress(status)) {
                return false;
            }
            if (status === FAILED_RECORD || status === NOT_FOUND_RECORD) {
                return true;
            }
            return false;
        }
        const rowProps = getRowProps(item);
        return ((_a = rowProps === null || rowProps === void 0 ? void 0 : rowProps.checkbox) === null || _a === void 0 ? void 0 : _a.isVisible) && !((_b = rowProps === null || rowProps === void 0 ? void 0 : rowProps.checkbox) === null || _b === void 0 ? void 0 : _b.isDisabled);
    }, [getRowProps]);
    const isItemUnknown = useCallback((id) => {
        const item = tree.getById(id);
        if (item !== NOT_FOUND_RECORD) {
            return false;
        }
        if (!getItemStatus) {
            return true;
        }
        const status = getItemStatus(id);
        return status === FAILED_RECORD || status === NOT_FOUND_RECORD;
    }, [tree, getItemStatus]);
    const handleCheck = useCallback((isChecked, checkedId, isRoot) => __awaiter(this, void 0, void 0, function* () {
        const completeTree = yield getCompleteTreeForCascadeSelection(checkedId, isChecked, isRoot);
        setDataSourceState((dsState) => {
            var _a;
            return (Object.assign(Object.assign({}, dsState), { checked: CheckingHelper.cascadeSelection({
                    tree: completeTree,
                    currentCheckedIds: (_a = dsState.checked) !== null && _a !== void 0 ? _a : [],
                    checkedId,
                    isChecked,
                    isCheckable: isItemCheckable,
                    isUnknown: isItemUnknown,
                    cascadeSelectionType: cascadeSelection,
                }) }));
        });
    }), [getCompleteTreeForCascadeSelection, setDataSourceState, isItemCheckable, isItemUnknown, cascadeSelection]);
    const handleSelectAll = useCallback((isChecked) => {
        handleCheck(isChecked, undefined, true);
    }, [handleCheck]);
    const clearAllChecked = useCallback(() => {
        handleCheck(false, undefined, true);
    }, [handleCheck]);
    const handleOnCheck = useCallback((rowProps) => {
        const id = rowProps.id;
        const isChecked = !rowProps.isChecked;
        handleCheck(isChecked, id);
    }, [handleCheck]);
    return {
        isRowChecked,
        isRowChildrenChecked,
        handleOnCheck,
        handleSelectAll,
        clearAllChecked,
        isItemCheckable,
    };
}

/**
 * Service, which provides folding functionality.
 * @returns folding service.
 */
function useFoldingService({ dataSourceState, setDataSourceState, isFoldedByDefault, getId, }) {
    const defaultIsFolded = (state) => {
        return state.foldAll;
    };
    const isFolded = useCallback((item) => {
        var _a;
        const searchIsApplied = !!(dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.search);
        if (searchIsApplied) {
            return false;
        }
        const folded = dataSourceState.folded || {};
        const key = idToKey$1(getId(item));
        if (folded[key] != null) {
            return folded[key];
        }
        if (isFoldedByDefault) {
            return isFoldedByDefault(item, { foldAll: dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.foldAll });
        }
        return (_a = defaultIsFolded(dataSourceState)) !== null && _a !== void 0 ? _a : true;
    }, [isFoldedByDefault, dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.search, dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.folded, dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.foldAll]);
    const handleOnFold = useCallback((rowProps) => {
        setDataSourceState((dsState) => {
            var _a, _b;
            const fold = !rowProps.isFolded;
            const indexToScroll = rowProps.index - ((_b = (_a = rowProps.path) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            const scrollTo = fold && rowProps.isPinned
                ? { index: indexToScroll, align: 'nearest' }
                : dsState.scrollTo;
            return Object.assign(Object.assign({}, dsState), { scrollTo, folded: setObjectFlag(dsState && dsState.folded, rowProps.rowKey, fold) });
        });
    }, [setDataSourceState]);
    return { handleOnFold, isFolded };
}

/**
 * Service, which provides focus functionality.
 * @returns focus service.
 */
function useFocusService({ setDataSourceState, }) {
    const handleOnFocus = useCallback((focusIndex) => {
        setDataSourceState((dataSourceState) => (Object.assign(Object.assign({}, dataSourceState), { focusedIndex: focusIndex })));
    }, [setDataSourceState]);
    return { handleOnFocus };
}

/**
 * Service, which provides selection functionality.
 * @returns selecting service.
 */
function useSelectingService({ tree, getParentId, dataSourceState, setDataSourceState, }) {
    const { selectedId } = dataSourceState;
    const selectingInfoById = useMemo(() => buildParentsLookup(selectedId === null ? [] : [selectedId], tree, getParentId), [tree, getParentId, selectedId]);
    const { idsByKey: selectedByKey, someChildInIdsByKey: someChildSelectedByKey } = selectingInfoById;
    const isRowSelected = useCallback((row) => {
        return !!selectedByKey[idToKey(row.id)];
    }, [selectedByKey]);
    const isRowChildSelected = useCallback((row) => {
        var _a;
        return (_a = someChildSelectedByKey[idToKey(row.id)]) !== null && _a !== void 0 ? _a : false;
    }, [someChildSelectedByKey]);
    const handleOnSelect = useCallback((rowProps) => {
        setDataSourceState((dsState) => (Object.assign(Object.assign({}, dsState), { selectedId: rowProps.id })));
    }, [setDataSourceState]);
    return { handleOnSelect, isRowSelected, isRowChildSelected };
}

/**
 * Service, which provides cascade selection functionality with support of loading missing records as needed.
 * @returns cascade selection service.
 */
function useCascadeSelectionService({ tree, loadMissingRecordsOnCheck = () => __awaiter(this, void 0, void 0, function* () { return tree; }), }) {
    const getCompleteTreeForCascadeSelection = useCallback((checkedId, isChecked, isRoot) => __awaiter(this, void 0, void 0, function* () {
        return yield loadMissingRecordsOnCheck(checkedId, isChecked, isRoot);
    }), [tree, loadMissingRecordsOnCheck]);
    return { getCompleteTreeForCascadeSelection };
}

function useDataRowProps({ tree, getId, dataSourceState, getRowOptions, rowOptions, isFolded, handleOnCheck, handleOnSelect, handleOnFocus, handleOnFold, isRowSelected, isRowChildSelected, isRowChecked, isRowChildrenChecked, getEstimatedChildrenCount, }) {
    const updateRowOptions = useCallback((row) => {
        var _a, _b, _c;
        const externalRowOptions = (getRowOptions && !row.isLoading)
            ? getRowOptions(row.value, row.index)
            : {};
        const fullRowOptions = Object.assign(Object.assign({}, rowOptions), externalRowOptions);
        const estimatedChildrenCount = getEstimatedChildrenCount(row.id);
        row.isFoldable = false;
        if (estimatedChildrenCount > 0) {
            row.isFoldable = true;
        }
        const isCheckable = !!((fullRowOptions === null || fullRowOptions === void 0 ? void 0 : fullRowOptions.checkbox) && ((_a = fullRowOptions === null || fullRowOptions === void 0 ? void 0 : fullRowOptions.checkbox) === null || _a === void 0 ? void 0 : _a.isVisible) && !((_b = fullRowOptions === null || fullRowOptions === void 0 ? void 0 : fullRowOptions.checkbox) === null || _b === void 0 ? void 0 : _b.isDisabled));
        const isSelectable = fullRowOptions && fullRowOptions.isSelectable;
        if (fullRowOptions != null) {
            const rowValue = row.value;
            Object.assign(row, fullRowOptions);
            row.value = (_c = fullRowOptions.value) !== null && _c !== void 0 ? _c : rowValue;
        }
        row.isFocused = dataSourceState.focusedIndex === row.index;
        row.isChecked = isRowChecked(row);
        row.isSelected = isRowSelected(row);
        row.isCheckable = isCheckable;
        row.onCheck = isCheckable ? handleOnCheck : undefined;
        row.onSelect = (fullRowOptions === null || fullRowOptions === void 0 ? void 0 : fullRowOptions.isSelectable) ? handleOnSelect : undefined;
        row.onFocus = (isSelectable || isCheckable || row.isFoldable) ? handleOnFocus : undefined;
        row.onFold = row.isFoldable ? handleOnFold : undefined;
        row.isFolded = row.isFoldable && isFolded(row.value);
        row.isChildrenChecked = row.isChildrenChecked || isRowChildrenChecked(row);
        row.isChildrenSelected = row.isChildrenSelected || isRowChildSelected(row);
        return row;
    }, [
        tree,
        getRowOptions,
        rowOptions,
        getEstimatedChildrenCount,
        dataSourceState.focusedIndex,
        dataSourceState.selectedId,
        isRowChecked,
        isRowChildrenChecked,
        handleOnCheck,
        handleOnSelect,
        handleOnFocus,
        isFolded,
        handleOnFold,
    ]);
    const getRowProps = useCallback((item, index) => {
        const id = getId(item);
        const key = idToKey$1(id);
        const path = Tree.getPathById(id, tree);
        const parentId = path.length > 0 ? path[path.length - 1].id : undefined;
        const rowProps = {
            id,
            parentId,
            key,
            rowKey: key,
            index,
            value: item,
            depth: path.length,
            path,
        };
        return updateRowOptions(rowProps);
    }, [getId, tree, updateRowOptions]);
    const getEmptyRowProps = useCallback((id, index = 0, path = null) => {
        var _a, _b;
        const checked = (_a = dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.checked) !== null && _a !== void 0 ? _a : [];
        const isChecked = checked.includes(id);
        return {
            id,
            rowKey: idToKey$1(id),
            value: undefined,
            index,
            depth: path ? path.length : 0,
            path: path !== null && path !== void 0 ? path : [],
            checkbox: ((_b = rowOptions === null || rowOptions === void 0 ? void 0 : rowOptions.checkbox) === null || _b === void 0 ? void 0 : _b.isVisible) && { isVisible: true, isDisabled: true },
            isChecked,
        };
    }, [dataSourceState === null || dataSourceState === void 0 ? void 0 : dataSourceState.checked, rowOptions]);
    const getLoadingRowProps = useCallback((id, index = 0, path = null) => {
        const rowProps = getEmptyRowProps(id, index, path);
        return Object.assign(Object.assign({}, rowProps), { checkbox: Object.assign(Object.assign({}, rowProps.checkbox), { isDisabled: true }), isLoading: true });
    }, [getEmptyRowProps]);
    const getUnknownRowProps = useCallback((id, index = 0, path = null) => {
        var _a;
        const emptyRowProps = getEmptyRowProps(id, index, path);
        const checkbox = (((_a = rowOptions === null || rowOptions === void 0 ? void 0 : rowOptions.checkbox) === null || _a === void 0 ? void 0 : _a.isVisible) || emptyRowProps.isChecked)
            ? { isVisible: true, isDisabled: false }
            : undefined;
        const isCheckable = checkbox && checkbox.isVisible && !checkbox.isDisabled;
        return Object.assign(Object.assign({}, emptyRowProps), { checkbox, isUnknown: true, onCheck: isCheckable ? handleOnCheck : undefined });
    }, [getEmptyRowProps, rowOptions, handleOnCheck]);
    return useMemo(() => ({ getRowProps, getEmptyRowProps, getLoadingRowProps, getUnknownRowProps, updateRowOptions }), [getRowProps, getEmptyRowProps, getLoadingRowProps, getUnknownRowProps, updateRowOptions]);
}

const getDefaultNodeStats = () => ({
    isSomeCheckable: false,
    isSomeChecked: false,
    isAllChecked: true,
    isSomeSelected: false,
    hasMoreRows: false,
    isSomeCheckboxEnabled: false,
});
const mergeStats = (parentStats, childStats) => (Object.assign(Object.assign({}, parentStats), { isSomeSelected: parentStats.isSomeSelected || childStats.isSomeSelected, isSomeCheckable: parentStats.isSomeCheckable || childStats.isSomeCheckable, isSomeChecked: parentStats.isSomeChecked || childStats.isSomeChecked, isAllChecked: parentStats.isAllChecked && childStats.isAllChecked, isSomeCheckboxEnabled: parentStats.isSomeCheckboxEnabled || childStats.isSomeCheckboxEnabled, hasMoreRows: parentStats.hasMoreRows || childStats.hasMoreRows }));
const getRowStats = (row, actualStats, cascadeSelection) => {
    let { isSomeCheckable, isSomeChecked, isAllChecked, isSomeSelected, isSomeCheckboxEnabled, } = actualStats;
    if (row.checkbox && row.checkbox.isVisible) {
        isSomeCheckable = true;
        if (row.isChecked || row.isChildrenChecked) {
            isSomeChecked = true;
        }
        if (!row.checkbox.isDisabled || isSomeCheckboxEnabled) {
            isSomeCheckboxEnabled = true;
        }
        const isImplicitCascadeSelection = cascadeSelection === CascadeSelectionTypes.IMPLICIT;
        if ((!row.isChecked && !row.checkbox.isDisabled && !isImplicitCascadeSelection)
            || (row.parentId === undefined && !row.isChecked && isImplicitCascadeSelection)) {
            isAllChecked = false;
        }
    }
    if (row.isSelected || row.isChildrenSelected) {
        isSomeSelected = true;
    }
    return Object.assign(Object.assign({}, actualStats), { isSomeCheckable, isSomeChecked, isAllChecked, isSomeSelected, isSomeCheckboxEnabled });
};

function useBuildRows({ tree, dataSourceState, getEstimatedChildrenCount, getMissingRecordsCount, cascadeSelection, maxVisibleRowIndex, getRowProps, getLoadingRowProps, isLoading = false, }) {
    const buildRows = () => {
        const rows = [];
        const pinned = {};
        const pinnedByParentId = {};
        const iterateNode = (parentId, appendRows) => {
            var _a, _b, _c;
            let currentLevelRows = 0;
            let stats = getDefaultNodeStats();
            const layerRows = [];
            const { ids, count } = tree.getItems(parentId);
            for (let n = 0; n < ids.length; n++) {
                const id = ids[n];
                const item = tree.getById(id);
                if (item === NOT_FOUND_RECORD) {
                    continue;
                }
                const row = getRowProps(item, rows.length);
                if (appendRows) {
                    rows.push(row);
                    layerRows.push(row);
                    currentLevelRows++;
                }
                stats = getRowStats(row, stats, cascadeSelection);
                row.isLastChild = n === ids.length - 1 && count === ids.length;
                const assumedChildrenOfParent = getEstimatedChildrenCount(parentId);
                row.indent = (!assumedChildrenOfParent && parentId !== undefined) ? 0 : row.path.length + 1;
                const estimatedChildrenCount = getEstimatedChildrenCount(id);
                if (estimatedChildrenCount !== undefined) {
                    const { ids: childrenIds } = tree.getItems(id);
                    if (estimatedChildrenCount > 0) {
                        if (childrenIds.length > 0) {
                            // some children are loaded
                            const childStats = iterateNode(id, appendRows && !row.isFolded);
                            row.isChildrenChecked = row.isChildrenChecked || childStats.isSomeChecked;
                            row.isChildrenSelected = row.isChildrenSelected || childStats.isSomeSelected;
                            stats = mergeStats(stats, childStats);
                            // while searching and no children in visible tree, no need to append placeholders.
                        }
                        else if (!dataSourceState.search && !row.isFolded && appendRows) {
                            // children are not loaded
                            const parentsWithRow = [...row.path, Tree.getPathItem(item, tree)];
                            for (let m = 0; m < estimatedChildrenCount && rows.length < maxVisibleRowIndex; m++) {
                                const loadingRow = getLoadingRowProps('_loading_' + rows.length, rows.length, parentsWithRow);
                                loadingRow.indent = parentsWithRow.length + 1;
                                loadingRow.isLastChild = m === estimatedChildrenCount - 1;
                                rows.push(loadingRow);
                                currentLevelRows++;
                            }
                        }
                    }
                }
                row.isPinned = (_b = (_a = row.pin) === null || _a === void 0 ? void 0 : _a.call(row, row)) !== null && _b !== void 0 ? _b : false;
                if (row.isPinned) {
                    pinned[idToKey$1(row.id)] = row.index;
                    if (!pinnedByParentId[idToKey$1(row.parentId)]) {
                        pinnedByParentId[idToKey$1(row.parentId)] = [];
                    }
                    (_c = pinnedByParentId[idToKey$1(row.parentId)]) === null || _c === void 0 ? void 0 : _c.push(row.index);
                }
            }
            const pathToParent = Tree.getPathById(parentId, tree);
            const parent = tree.getById(parentId);
            const parentPathItem = parent !== NOT_FOUND_RECORD ? [Tree.getPathItem(parent, tree)] : [];
            const path = parentId ? [...pathToParent, ...parentPathItem] : pathToParent;
            if (appendRows) {
                let missingCount = getMissingRecordsCount(parentId, rows.length, currentLevelRows);
                if (missingCount > 0) {
                    stats.hasMoreRows = true;
                }
                // Append loading rows, stop at maxVisibleRowIndex (maximum assumed row visible)
                while (rows.length < maxVisibleRowIndex && missingCount > 0) {
                    const row = getLoadingRowProps('_loading_' + rows.length, rows.length, path);
                    rows.push(row);
                    layerRows.push(row);
                    currentLevelRows++;
                    missingCount--;
                }
            }
            const isListFlat = path.length === 0 && !layerRows.some((r) => r.isFoldable);
            if (isListFlat) {
                layerRows.forEach((r) => {
                    r.indent = 0;
                });
            }
            return stats;
        };
        const rootStats = iterateNode(undefined, true);
        return {
            rows,
            pinned,
            pinnedByParentId,
            stats: rootStats,
        };
    };
    return useMemo(() => buildRows(), [tree, dataSourceState.folded, dataSourceState.checked, isLoading, dataSourceState.foldAll]);
}

function useSelectAll(props) {
    const isSelectAllEnabled = useMemo(() => props.selectAll === undefined ? true : props.selectAll, [props.selectAll]);
    const selectAll = useMemo(() => {
        var _a;
        if (props.stats.isSomeCheckable && isSelectAllEnabled) {
            return {
                value: props.stats.isSomeCheckboxEnabled ? props.stats.isAllChecked : false,
                onValueChange: props.handleSelectAll,
                indeterminate: props.checked && props.checked.length > 0 && !props.stats.isAllChecked,
            };
        }
        else if (props.tree.getItems().ids.length === 0 && props.areCheckboxesVisible && isSelectAllEnabled) {
            // Nothing loaded yet, but we guess that something is checkable. Add disabled checkbox for less flicker.
            return {
                value: false,
                onValueChange: () => { },
                isDisabled: true,
                indeterminate: ((_a = props.checked) === null || _a === void 0 ? void 0 : _a.length) > 0,
            };
        }
        return null;
    }, [
        props.tree,
        props.areCheckboxesVisible,
        props.checked,
        props.stats,
        isSelectAllEnabled,
        props.handleSelectAll,
    ]);
    return selectAll;
}

function usePinnedRows({ rows, pinned, pinnedByParentId, }) {
    const getLastPinnedBeforeRow = useCallback((row, pinnedIndexes) => {
        const isBeforeOrEqualToRow = (pinnedRowIndex) => {
            const pinnedRow = rows[pinnedRowIndex];
            if (!pinnedRow) {
                return false;
            }
            return row.index >= pinnedRow.index;
        };
        let foundRowIndex = -1;
        for (const pinnedRowIndex of pinnedIndexes) {
            if (isBeforeOrEqualToRow(pinnedRowIndex)) {
                foundRowIndex = pinnedRowIndex;
            }
            else if (foundRowIndex !== -1) {
                break;
            }
        }
        if (foundRowIndex === -1) {
            return undefined;
        }
        return foundRowIndex;
    }, [rows]);
    const getLastHiddenPinnedByParent = useCallback((row, alreadyAdded) => {
        const pinnedIndexes = pinnedByParentId[idToKey$1(row.parentId)];
        if (!pinnedIndexes || !pinnedIndexes.length) {
            return undefined;
        }
        const lastPinnedBeforeRow = getLastPinnedBeforeRow(row, pinnedIndexes);
        if (lastPinnedBeforeRow === undefined) {
            return undefined;
        }
        const lastHiddenPinned = rows[lastPinnedBeforeRow];
        if (!lastHiddenPinned || alreadyAdded.includes(lastHiddenPinned.id)) {
            return undefined;
        }
        return lastHiddenPinned;
    }, [pinnedByParentId, rows, getLastPinnedBeforeRow]);
    const withPinnedRows = useCallback((allRows) => {
        if (!allRows.length)
            return [];
        const rowsWithPinned = [];
        const alreadyAdded = allRows.map(({ id }) => id);
        const [firstRow] = allRows;
        firstRow.path.forEach((item) => {
            const pinnedIndex = pinned[idToKey$1(item.id)];
            if (pinnedIndex === undefined)
                return;
            const parent = rows[pinnedIndex];
            if (!parent || alreadyAdded.includes(parent.id))
                return;
            rowsWithPinned.push(parent);
            alreadyAdded.push(parent.id);
        });
        const lastHiddenPinned = getLastHiddenPinnedByParent(firstRow, alreadyAdded);
        if (lastHiddenPinned) {
            rowsWithPinned.push(lastHiddenPinned);
        }
        return rowsWithPinned.concat(allRows);
    }, [pinned, rows, getLastHiddenPinnedByParent]);
    return withPinnedRows;
}

function useUpdateRowOptions({ rows, updateRowOptions, }) {
    return rows.map((row) => {
        if (!row.isLoading) {
            return updateRowOptions(row);
        }
        return row;
    });
}

/**
 * Hook, which builds rows, based on the tree.
 * @returns rows and other IDataSourceView fields.
 */
function useDataRows(props) {
    var _a;
    const { tree, getId, getParentId, dataSourceState, getRowOptions, rowOptions, getItemStatus, cascadeSelection, isLoading, isFetching, setDataSourceState, isFoldedByDefault, getCompleteTreeForCascadeSelection = () => __awaiter(this, void 0, void 0, function* () { return tree; }), } = props;
    const maxVisibleRowIndex = useMemo(() => dataSourceState.topIndex + dataSourceState.visibleCount, [tree, dataSourceState.topIndex, dataSourceState.visibleCount]);
    const getEstimatedChildrenCount = useCallback((id) => {
        if (id === undefined) {
            const { count, status } = tree.getItems(id);
            return count !== undefined && status === FULLY_LOADED ? count : undefined;
        }
        const item = tree.getById(id);
        if (item === NOT_FOUND_RECORD)
            return undefined;
        const nodeInfo = tree.getItems(id);
        if ('assumedCount' in nodeInfo && nodeInfo.assumedCount === undefined) {
            return undefined;
        }
        const { count, status } = nodeInfo;
        if (count !== undefined && (status === FULLY_LOADED || status === EMPTY)) {
            // nodes are already loaded, and we know the actual count
            return count;
        }
        return nodeInfo.assumedCount;
    }, [props, tree]);
    const getMissingRecordsCount = useCallback((id, totalRowsCount, loadedChildrenCount) => {
        const { count } = tree.getItems(id);
        // Estimate how many more nodes there are at current level, to put 'loading' placeholders.
        if (count !== undefined) {
            // Exact count known
            return count - loadedChildrenCount;
        }
        const estimatedChildCount = getEstimatedChildrenCount(id);
        // estimatedChildCount = undefined for top-level rows only.
        if (id === undefined && totalRowsCount < maxVisibleRowIndex) {
            return maxVisibleRowIndex - totalRowsCount; // let's put placeholders down to the bottom of visible list
        }
        if (estimatedChildCount > loadedChildrenCount) {
            // According to assumedCount (put into estimatedChildCount), there are more rows on this level
            return estimatedChildCount - loadedChildrenCount;
        }
        // We have a bad estimate - it even less that actual items we have
        // This would happen is assumedCount provides a guess count, and we scroll thru children past this count
        // let's guess we have at least 1 item more than loaded
        return 1;
    }, [maxVisibleRowIndex, tree, getEstimatedChildrenCount]);
    const { handleOnCheck, isRowChecked, isRowChildrenChecked, isItemCheckable, handleSelectAll } = useCheckingService({
        tree,
        dataSourceState,
        setDataSourceState,
        cascadeSelection,
        getParentId,
        rowOptions,
        getRowOptions,
        getCompleteTreeForCascadeSelection,
        getItemStatus,
    });
    const foldingService = useFoldingService({
        dataSourceState, setDataSourceState, isFoldedByDefault, getId,
    });
    const focusService = useFocusService({ setDataSourceState });
    const selectingService = useSelectingService({
        tree,
        getParentId,
        dataSourceState,
        setDataSourceState,
    });
    const { getRowProps, getUnknownRowProps, getLoadingRowProps, updateRowOptions } = useDataRowProps(Object.assign(Object.assign(Object.assign({ tree,
        getId,
        dataSourceState,
        rowOptions,
        getRowOptions,
        getEstimatedChildrenCount,
        handleOnCheck,
        isRowChecked,
        isRowChildrenChecked,
        isItemCheckable }, foldingService), selectingService), focusService));
    const { rows: allRows, pinned, pinnedByParentId, stats } = useBuildRows({
        tree,
        dataSourceState,
        cascadeSelection,
        maxVisibleRowIndex,
        getEstimatedChildrenCount,
        getMissingRecordsCount,
        getRowProps,
        getLoadingRowProps,
        isLoading,
    });
    const updatedRows = useUpdateRowOptions({ rows: allRows, updateRowOptions });
    const withPinnedRows = usePinnedRows({
        rows: updatedRows,
        pinned,
        pinnedByParentId,
    });
    const selectAll = useSelectAll({
        tree,
        checked: dataSourceState.checked,
        selectAll: props.selectAll,
        stats,
        areCheckboxesVisible: (_a = rowOptions === null || rowOptions === void 0 ? void 0 : rowOptions.checkbox) === null || _a === void 0 ? void 0 : _a.isVisible,
        handleSelectAll,
    });
    const isItemLoaded = (item) => {
        return item !== NOT_FOUND_RECORD;
    };
    const getById = (id, index) => {
        const itemStatus = getItemStatus === null || getItemStatus === void 0 ? void 0 : getItemStatus(id);
        const item = tree.getById(id);
        if (!isItemLoaded(item)) {
            if (isInProgress(itemStatus)) {
                return getLoadingRowProps(id, index, []);
            }
            return getUnknownRowProps(id, index, []);
        }
        return getRowProps(item, index);
    };
    const listProps = useMemo(() => {
        const itemsInfo = tree.getItems(undefined);
        const { count, ids } = itemsInfo;
        const isTreeLikeStructure = ids.some((id) => {
            const info = tree.getItems(id);
            return ('assumedCount' in info) || info.ids.length > 0;
        });
        const isFlatList = !isTreeLikeStructure;
        const completeFlatListRowsCount = isFlatList && count != null ? count : undefined;
        let rowsCount;
        if (completeFlatListRowsCount !== undefined) {
            // We have a flat list, and know exact count of items on top level. So, we can have an exact number of rows w/o iterating the whole tree.
            rowsCount = completeFlatListRowsCount;
        }
        else if (!stats.hasMoreRows) {
            // We are at the bottom of the list. Some children might still be loading, but that's ok - we'll re-count everything after we load them.
            rowsCount = updatedRows.length;
        }
        else {
            // We definitely have more rows to show below the last visible row.
            // We need to add at least 1 row below, so VirtualList or other component would not detect the end of the list, and query loading more rows later.
            // We have to balance this number.
            // To big - would make scrollbar size to shrink when we hit bottom
            // To small - and VirtualList will re-request rows until it will fill it's last block.
            // So, it should be at least greater than VirtualList block size (default is 20)
            // Probably, we'll move this const to props later if needed;
            const rowsToAddBelowLastKnown = 20;
            rowsCount = Math.max(updatedRows.length, maxVisibleRowIndex + rowsToAddBelowLastKnown);
        }
        return {
            rowsCount,
            knownRowsCount: updatedRows.length,
            exactRowsCount: updatedRows.length,
            selectAll,
            isReloading: isFetching,
        };
    }, [updatedRows.length, selectAll, stats.hasMoreRows, maxVisibleRowIndex, tree, isFetching]);
    const rows = useMemo(() => {
        const from = dataSourceState.topIndex;
        const count = dataSourceState.visibleCount;
        const visibleRowsWithPins = withPinnedRows(updatedRows.slice(from, from + count));
        if (stats.hasMoreRows) {
            // We don't run rebuild rows on scrolling. We rather wait for the next load to happen.
            // So there can be a case when we haven't updated rows (to add more loading rows), and view is scrolled down
            // We need to add more loading rows in such case.
            const lastRow = updatedRows[updatedRows.length - 1];
            while (visibleRowsWithPins.length < count && from + visibleRowsWithPins.length < listProps.rowsCount) {
                const index = from + visibleRowsWithPins.length;
                const row = getLoadingRowProps('_loading_' + index, index);
                row.indent = lastRow.indent;
                row.path = lastRow.path;
                row.depth = lastRow.depth;
                visibleRowsWithPins.push(row);
            }
        }
        return visibleRowsWithPins;
    }, [
        tree,
        updatedRows,
        dataSourceState.topIndex,
        dataSourceState.visibleCount,
        withPinnedRows,
        listProps,
        getLoadingRowProps,
    ]);
    const getSelectedRowsCount = () => {
        var _a, _b;
        const count = (_b = (_a = dataSourceState.checked) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        if (!count) {
            return (dataSourceState.selectedId !== undefined && dataSourceState.selectedId !== null) ? 1 : 0;
        }
        return count;
    };
    const clearAllChecked = useCallback(() => handleSelectAll(false), [handleSelectAll]);
    return {
        listProps,
        rows,
        getSelectedRowsCount,
        getById,
        clearAllChecked,
        selectAll,
    };
}

class BaseDataSource {
    constructor(props) {
        this.props = props;
        this.trees = new Map();
        this.getId = (item) => {
            var _a, _b;
            if (item == null)
                return null;
            const id = ((_b = (_a = this.props).getId) === null || _b === void 0 ? void 0 : _b.call(_a, item)) || item.id;
            if (id == null) {
                throw new Error(`Item ID not found. Check 'getId' prop value. Item: ${JSON.stringify(item)}`);
            }
            return id;
        };
    }
    destroy() {
        this.trees.clear();
    }
    reload() {
        this.trees.forEach((reload) => reload());
    }
}

class ArrayDataSource extends BaseDataSource {
    constructor(props) {
        super(props);
        this.getById = (id) => {
            return this.itemsStorage.getItemsMap().get(id);
        };
        this.defaultGetParentId = (item) => {
            return item['parentId'];
        };
        this.setProps(props);
        const params = { getId: this.getId, complexIds: props.complexIds };
        this.itemsStorage = new ItemsStorage({ items: [], params: params });
    }
    setProps(props) {
        this.props = props;
    }
    setItem(item) {
        const id = this.getId(item);
        const prevItem = this.getById(id);
        if (!prevItem) {
            this.itemsStorage.setItems([item]);
        }
    }
    useView(value, onValueChange, options, deps = []) {
        var _a, _b;
        const _c = this.props, { items } = _c, restDSProps = __rest(_c, ["items"]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const _d = useTree(Object.assign(Object.assign(Object.assign({ type: 'sync' }, restDSProps), options), { items, setItems: this.itemsStorage.setItems, dataSourceState: value, setDataSourceState: onValueChange, 
            // These defaults are added for compatibility reasons.
            // We'll require getId and getParentId callbacks in other APIs, including the views.
            getId: this.getId, getParentId: (_b = (_a = options === null || options === void 0 ? void 0 : options.getParentId) !== null && _a !== void 0 ? _a : this.props.getParentId) !== null && _b !== void 0 ? _b : this.defaultGetParentId }), [...deps, this]), { tree, selectionTree, reload, totalCount } = _d, restProps = __rest(_d, ["tree", "selectionTree", "reload", "totalCount"]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            this.trees.set(tree, reload);
            return () => {
                this.trees.delete(tree);
            };
        }, [tree, reload]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const cascadeSelectionService = useCascadeSelectionService({
            tree: selectionTree,
        });
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { rows, listProps, selectAll, getById, getSelectedRowsCount, clearAllChecked } = useDataRows(Object.assign(Object.assign({ tree }, restProps), cascadeSelectionService));
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useMemo(() => ({
            getVisibleRows: () => rows,
            getListProps: () => (Object.assign(Object.assign({}, listProps), { totalCount })),
            selectAll,
            getConfig: () => restProps,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        }), [
            rows,
            listProps,
            selectAll,
            restProps,
            totalCount,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        ]);
    }
}

const useColumnsConfig = (initialColumns, columnsConfig) => {
    const config = getColumnsConfig(initialColumns, columnsConfig);
    const defaultConfig = getColumnsConfig(initialColumns, {});
    const columns = applyColumnsConfig(initialColumns, config);
    return { columns, config, defaultConfig };
};

/**
 * NextJs doesn't support useLayoutEffect, this code suppresses the warning by replacing useLayoutEffect to useEffect in SSR.
 * See also the discussion here: https://github.com/facebook/react/issues/14927#issuecomment-572720368
 */
const useLayoutEffectSafeForSsr = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

const getUpdatedRowHeights = (virtualListInfo) => {
    const newRowHeights = [...virtualListInfo.rowHeights];
    const { listContainer, rowsSelector } = virtualListInfo;
    const rows = rowsSelector
        ? listContainer.querySelectorAll(rowsSelector)
        : listContainer.children;
    Array.from(rows).forEach((node, index) => {
        const topIndex = virtualListInfo.value.topIndex || 0;
        const { height } = node.getBoundingClientRect();
        if (!height)
            return;
        newRowHeights[topIndex + index] = height;
    });
    return newRowHeights;
};
const getAverageRowHeight = (rowHeights) => {
    const notEmptyRowsHeights = rowHeights.filter((height) => height !== undefined);
    if (!notEmptyRowsHeights.length) {
        return 1;
    }
    const totalRowHeights = notEmptyRowsHeights.reduce((sum, next) => sum + next, 0);
    return totalRowHeights / notEmptyRowsHeights.length;
};
const getUpdatedRowOffsets = ({ rowOffsets, rowsCount, listOffset, rowHeights, averageRowHeight }) => {
    const newRowOffsets = [...rowOffsets];
    for (let n = 0; n <= rowsCount; n++) {
        newRowOffsets[n] = n === 0
            ? listOffset
            : newRowOffsets[n - 1] + (rowHeights[n] || averageRowHeight);
    }
    return newRowOffsets;
};
const getNewEstimatedContainerHeight = (rowOffsets, rowsCount, listOffset) => rowOffsets[rowsCount] - listOffset;
const getUpdatedRowsInfo = (virtualListInfo) => {
    if (!virtualListInfo.scrollContainer
        || !virtualListInfo.listContainer
        || virtualListInfo.listOffset == null
        || !virtualListInfo.value) {
        return {
            rowHeights: virtualListInfo.rowHeights,
            rowOffsets: virtualListInfo.rowOffsets,
            estimatedHeight: virtualListInfo.estimatedHeight,
        };
    }
    const rowHeights = getUpdatedRowHeights(virtualListInfo);
    const averageRowHeight = getAverageRowHeight(rowHeights);
    const rowOffsets = getUpdatedRowOffsets(Object.assign(Object.assign({}, virtualListInfo), { rowHeights, averageRowHeight }));
    const estimatedHeight = getNewEstimatedContainerHeight(rowOffsets, virtualListInfo.rowsCount, virtualListInfo.listOffset);
    return {
        estimatedHeight,
        rowHeights,
        rowOffsets,
        averageRowHeight,
    };
};
const getNewTopIndex = (info) => {
    const { overdrawRows, blockSize, value } = info;
    let newTopIndex = getRealTopIndex(info);
    newTopIndex = newTopIndex - overdrawRows;
    newTopIndex = Math.max(0, newTopIndex);
    const topIndexDiff = Math.abs(value.topIndex - newTopIndex);
    // Number of rows to be scrolled up or down to trigger topIndex change.
    // This tolerance is required to avoid problems when scroll position is close to blocks boundaries, and even tiny difference
    // in row heights (e.g. 1px margin collapse) can cause endless loop of re-renderings
    const loadingThreshold = 5;
    if (topIndexDiff < loadingThreshold) {
        return value.topIndex;
    }
    return Math.floor(newTopIndex / blockSize) * blockSize; // Align to blockSize
};
const getNewBottomIndex = (info) => {
    const { rowsCount, overdrawRows, blockSize } = info;
    let bottomIndex = getRealBottomIndex(info);
    bottomIndex = bottomIndex + overdrawRows; // draw more rows at the bottom to remove visible blank areas while scrolling down
    bottomIndex = Math.floor(bottomIndex / blockSize) * blockSize; // Align to block size
    return Math.min(bottomIndex, rowsCount !== null && rowsCount !== void 0 ? rowsCount : 0); // clamp to rowsCount
};
const getRealTopIndex = ({ rowsCount, scrollContainer, rowOffsets }) => {
    var _a;
    let realTopIndex = 0;
    const containerScrollTop = (_a = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.scrollTop) !== null && _a !== void 0 ? _a : 0;
    while (realTopIndex < rowsCount && rowOffsets[realTopIndex] < containerScrollTop) {
        realTopIndex += 1;
    }
    return realTopIndex;
};
const getRealBottomIndex = ({ rowsCount, scrollContainer, rowOffsets, value: { topIndex } }) => {
    var _a, _b;
    let bottomIndex = topIndex;
    const containerScrollTop = (_a = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.scrollTop) !== null && _a !== void 0 ? _a : 0;
    const containerScrollBottom = (_b = containerScrollTop + (scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.clientHeight)) !== null && _b !== void 0 ? _b : 0;
    while (bottomIndex < rowsCount && rowOffsets[bottomIndex] < containerScrollBottom) {
        bottomIndex++;
    }
    return bottomIndex;
};
const getRowsToFetchForScroll = (virtualListInfo) => {
    var _a;
    const topIndex = getNewTopIndex(virtualListInfo);
    const bottomIndex = getNewBottomIndex(Object.assign(Object.assign({}, virtualListInfo), { value: Object.assign(Object.assign({}, virtualListInfo.value), { topIndex }) }));
    const { value, blockSize } = virtualListInfo;
    // We never reduce visible count intentionally - it can be set so a larger value intentionally.
    // Also, reducing it can cause bouncing between two near values, causing unnecessary re-renders.
    const visibleCount = Math.max((_a = value.visibleCount) !== null && _a !== void 0 ? _a : blockSize, bottomIndex - topIndex);
    return { visibleCount, topIndex };
};
const getScrollToCoordinate = (info, scrollTo) => {
    var _a;
    const topCoordinate = getTopCoordinate(info, scrollTo);
    const { index, align } = scrollTo;
    if (!align || align === 'top') {
        return topCoordinate;
    }
    const realTopIndex = getRealTopIndex(info);
    const realBottomIndex = getRealBottomIndex(Object.assign(Object.assign({}, info), { value: Object.assign(Object.assign({}, info.value), { topIndex: realTopIndex }) }));
    if (index < realTopIndex) {
        return topCoordinate;
    }
    if (index >= realBottomIndex - 1) {
        return getTopCoordinate(info, Object.assign(Object.assign({}, scrollTo), { index: scrollTo.index + 1 })) - ((_a = info.scrollContainer) === null || _a === void 0 ? void 0 : _a.clientHeight);
    }
    return undefined;
};
const getTopCoordinate = ({ rowOffsets, listOffset, value, rowHeights }, scrollTo) => {
    var _a;
    let rowCoordinate = rowOffsets[scrollTo.index];
    if (rowCoordinate === undefined) {
        const { topIndex = 0, visibleCount = 0 } = value;
        const visibleRowsCount = topIndex + visibleCount;
        const assumedRowsCount = Math.max(scrollTo.index - visibleRowsCount, 0);
        const averageRowHeight = getAverageRowHeight(rowHeights);
        const assumedRowsHeight = assumedRowsCount * averageRowHeight;
        const heightOfExistingRows = (_a = rowOffsets[visibleRowsCount]) !== null && _a !== void 0 ? _a : rowOffsets[rowOffsets.length - 1];
        rowCoordinate = heightOfExistingRows + assumedRowsHeight;
    }
    return rowCoordinate - listOffset;
};
const assumeHeightForScrollToIndex = (value, estimatedHeight, averageRowHeight) => {
    var _a;
    const { topIndex = 0, visibleCount = 0, scrollTo } = value;
    const scrollToIndex = (_a = scrollTo === null || scrollTo === void 0 ? void 0 : scrollTo.index) !== null && _a !== void 0 ? _a : 0;
    const skipRowsCount = Math.max(0, scrollToIndex - (topIndex + visibleCount - 1));
    return estimatedHeight + skipRowsCount * averageRowHeight;
};
const getTopIndexWithOffset = (index, overdrawRows, blockSize) => {
    let topIndex = index - overdrawRows; // draw more rows at the top to remove visible blank areas while scrolling up
    topIndex = Math.floor(topIndex / blockSize) * blockSize; // Align to blockSize
    return Math.max(0, topIndex);
};
const getOffsetYForIndex = (index, rowOffsets, listOffset) => {
    if (rowOffsets.length === 0 || index == null)
        return 0;
    const offsetY = rowOffsets[index] - listOffset;
    if (isNaN(offsetY)) {
        return 0;
    }
    return offsetY;
};

function useVirtualList(props) {
    const { onValueChange, value, rowsCount, onScroll, blockSize = 20, overdrawRows = 20, rowsSelector, } = props;
    const [estimatedHeight, setEstimatedHeight] = React.useState(0);
    const [listOffset, setListOffset] = React.useState();
    const [scrolledTo, setScrolledTo] = React.useState(null);
    const listContainer = React.useRef();
    const scrollContainer = React.useRef();
    const rowHeights = React.useRef([]);
    const rowOffsets = React.useRef([]);
    const virtualListInfo = React.useMemo(() => ({
        scrollContainer: scrollContainer.current,
        listContainer: listContainer.current,
        rowHeights: rowHeights.current,
        rowOffsets: rowOffsets.current,
        value,
        rowsCount,
        blockSize,
        overdrawRows,
        listOffset,
        estimatedHeight,
        rowsSelector,
    }), [
        scrollContainer.current,
        listContainer.current,
        rowHeights.current,
        rowOffsets.current,
        value,
        rowsCount,
        blockSize,
        overdrawRows,
        listOffset,
        estimatedHeight,
        rowsSelector,
    ]);
    useLayoutEffectSafeForSsr(() => {
        if (!scrollContainer.current || !listContainer.current)
            return;
        const { top: scrollContainerTop } = scrollContainer.current.getBoundingClientRect();
        const { top: listContainerTop } = listContainer.current.getBoundingClientRect();
        const newListOffset = listContainerTop - scrollContainerTop;
        setListOffset(newListOffset);
    }, [scrollContainer.current, listContainer.current]);
    const getTopIndexAndVisibleCountOnScroll = React.useCallback(() => {
        var _a, _b;
        if (!virtualListInfo.scrollContainer || !virtualListInfo.value) {
            return {
                visibleCount: (_a = virtualListInfo.value) === null || _a === void 0 ? void 0 : _a.visibleCount,
                topIndex: (_b = virtualListInfo.value) === null || _b === void 0 ? void 0 : _b.topIndex,
            };
        }
        return getRowsToFetchForScroll(virtualListInfo);
    }, [virtualListInfo]);
    useLayoutEffectSafeForSsr(() => {
        var _a;
        const rowsInfo = getUpdatedRowsInfo(virtualListInfo);
        rowHeights.current = rowsInfo.rowHeights;
        rowOffsets.current = rowsInfo.rowOffsets;
        if (scrollContainer.current && value)
            onScroll === null || onScroll === void 0 ? void 0 : onScroll(scrollContainer.current);
        if (!scrollContainer.current || !value)
            return;
        if ((value === null || value === void 0 ? void 0 : value.scrollTo) !== scrolledTo && ((_a = value === null || value === void 0 ? void 0 : value.scrollTo) === null || _a === void 0 ? void 0 : _a.index) != null) {
            handleForceScrollToIndex(rowsInfo);
        }
        else {
            handleScrollOnRerender(rowsInfo);
        }
    });
    const handleForceScrollToIndex = (rowsInfo) => {
        const assumedHeight = assumeHeightForScrollToIndex(value, rowsInfo.estimatedHeight, rowsInfo.averageRowHeight);
        const estimatedHeightToSet = rowsCount >= value.scrollTo.index
            ? rowsInfo.estimatedHeight
            : assumedHeight;
        setEstimatedHeight(estimatedHeightToSet);
        scrollToIndex(value.scrollTo);
    };
    const handleScrollOnRerender = (rowsInfo) => {
        const { topIndex } = value;
        const { topIndex: newTopIndex, visibleCount } = getNewRowsOnScroll();
        if (estimatedHeight !== rowsInfo.estimatedHeight) {
            setEstimatedHeight(rowsInfo.estimatedHeight);
        }
        if (topIndex !== newTopIndex || visibleCount !== value.visibleCount) {
            onValueChange(Object.assign(Object.assign({}, value), { topIndex: newTopIndex, visibleCount }));
        }
    };
    const getNewRowsOnScroll = React.useCallback(() => {
        const { topIndex, visibleCount } = getTopIndexAndVisibleCountOnScroll();
        if (topIndex !== value.topIndex || visibleCount > value.visibleCount) {
            return { topIndex, visibleCount };
        }
        return value;
    }, [getTopIndexAndVisibleCountOnScroll, onValueChange, value]);
    const scrollContainerToPosition = React.useCallback((scrollTo) => {
        const topCoordinate = getScrollToCoordinate(virtualListInfo, scrollTo);
        if (topCoordinate === undefined) {
            return [true, true]; // already at the necessary position, scroll doesn't have to be performed.
        }
        if (isNaN(topCoordinate)) {
            return [false, false];
        }
        scrollContainer.current.scrollTo({ top: topCoordinate, behavior: scrollTo.behavior });
        const scrollPositionDiff = (+topCoordinate.toFixed(0)) - (+scrollContainer.current.scrollTop.toFixed(0));
        return [
            scrollPositionDiff <= 1 // if scroll position is equal to expected one
                && virtualListInfo.rowHeights[scrollTo.index] !== undefined, // and required row with necessary index is present
            true,
        ];
    }, [scrollContainer.current, rowOffsets.current, virtualListInfo]);
    const scrollToIndex = React.useCallback((scrollTo) => {
        var _a, _b;
        const topIndex = getTopIndexWithOffset(scrollTo.index, overdrawRows, blockSize);
        const { visibleCount } = getTopIndexAndVisibleCountOnScroll();
        const [wasScrolled, ok] = scrollContainerToPosition(scrollTo);
        if ((ok && !wasScrolled) || value.topIndex !== topIndex || value.visibleCount !== visibleCount) {
            onValueChange(Object.assign(Object.assign({}, value), { topIndex, visibleCount, scrollTo }));
        }
        const realTopIndex = getRealTopIndex(virtualListInfo);
        // prevents from cycling, while force scrolling to a row, which will never appear, when using LazyListView.
        const shouldScrollToUnknownIndex = value.topIndex === topIndex && ((_a = value.scrollTo) === null || _a === void 0 ? void 0 : _a.index) > realTopIndex;
        if ((ok && wasScrolled) || shouldScrollToUnknownIndex) {
            if (((_b = value.scrollTo) === null || _b === void 0 ? void 0 : _b.index) === scrollTo.index) {
                setScrolledTo(value.scrollTo);
            }
            else {
                onValueChange(Object.assign(Object.assign({}, value), { scrollTo }));
                setScrolledTo(scrollTo);
            }
        }
    }, [
        scrollContainer.current,
        rowOffsets.current,
        value === null || value === void 0 ? void 0 : value.topIndex,
        value === null || value === void 0 ? void 0 : value.scrollTo,
        overdrawRows,
        blockSize,
        scrollContainerToPosition,
        virtualListInfo,
    ]);
    const offsetY = React.useMemo(() => getOffsetYForIndex(value === null || value === void 0 ? void 0 : value.topIndex, rowOffsets.current, listOffset), [rowOffsets.current, listOffset, value === null || value === void 0 ? void 0 : value.topIndex]);
    const handleScroll = React.useCallback(() => {
        var _a;
        if (!scrollContainer.current && !value)
            return;
        onScroll === null || onScroll === void 0 ? void 0 : onScroll(scrollContainer.current);
        if (value.scrollTo !== scrolledTo && ((_a = value.scrollTo) === null || _a === void 0 ? void 0 : _a.index) != null) {
            return;
        }
        const newValue = getNewRowsOnScroll();
        if (value.topIndex !== newValue.topIndex || value.visibleCount !== newValue.visibleCount) {
            onValueChange(Object.assign(Object.assign({}, value), newValue));
        }
    }, [value, onScroll, scrolledTo, scrollContainer.current, getNewRowsOnScroll]);
    return {
        estimatedHeight,
        offsetY,
        listOffset,
        scrollContainerRef: scrollContainer,
        listContainerRef: listContainer,
        handleScroll,
        scrollToIndex,
    };
}

function useScrollShadows({ root }) {
    const [vertical, setVertical] = React.useState({ top: false, bottom: false });
    const [horizontal, setHorizontal] = React.useState({ left: false, right: false });
    const resizeObserver = React.useRef();
    function shouldHaveRightShadow(rootRight) {
        if (!rootRight)
            return false;
        const { scrollLeft, clientWidth, scrollWidth } = rootRight;
        return scrollWidth - clientWidth - scrollLeft > 1 && !horizontal.right;
    }
    function shouldNotHaveRightShadow(rootRight) {
        const { scrollLeft, clientWidth, scrollWidth } = rootRight;
        return scrollWidth - clientWidth - scrollLeft <= 1 && horizontal.right;
    }
    function shouldHaveLeftShadow(rootLeft) {
        if (!rootLeft)
            return false;
        return rootLeft.scrollLeft > 0 && !horizontal.left;
    }
    function shouldNotHaveLeftShadow(rootLeft) {
        return rootLeft.scrollLeft === 0 && horizontal.left;
    }
    function shouldHaveTopShadow(rootTop) {
        if (!rootTop)
            return false;
        return rootTop.scrollTop > 0 && !vertical.top;
    }
    function shouldNotHaveTopShadow(rootTop) {
        return rootTop.scrollTop === 0 && vertical.top;
    }
    function shouldHaveBottomShadow(rootBottom) {
        if (!rootBottom)
            return false;
        const { scrollHeight, scrollTop, clientHeight } = rootBottom;
        return scrollHeight - clientHeight - scrollTop > 1 && !vertical.bottom;
    }
    function shouldNotHaveBottomShadow(rootBottom) {
        if (!rootBottom)
            return false;
        const { scrollHeight, scrollTop, clientHeight } = rootBottom;
        return scrollHeight - clientHeight - scrollTop <= 1 && vertical.bottom;
    }
    const updateScrollShadows = React.useCallback(() => {
        if (!root)
            return;
        // Horizontal shadow states
        if (shouldHaveLeftShadow(root))
            setHorizontal(Object.assign(Object.assign({}, horizontal), { left: true }));
        else if (shouldNotHaveLeftShadow(root))
            setHorizontal(Object.assign(Object.assign({}, horizontal), { left: false }));
        else if (shouldHaveRightShadow(root))
            setHorizontal(Object.assign(Object.assign({}, horizontal), { right: true }));
        else if (shouldNotHaveRightShadow(root))
            setHorizontal(Object.assign(Object.assign({}, horizontal), { right: false }));
        // Vertical shadow states
        if (shouldHaveTopShadow(root))
            setVertical(Object.assign(Object.assign({}, vertical), { top: true }));
        else if (shouldNotHaveTopShadow(root))
            setVertical(Object.assign(Object.assign({}, vertical), { top: false }));
        else if (shouldHaveBottomShadow(root))
            setVertical(Object.assign(Object.assign({}, vertical), { bottom: true }));
        else if (shouldNotHaveBottomShadow(root))
            setVertical(Object.assign(Object.assign({}, vertical), { bottom: false }));
    }, [
        root, vertical, horizontal, setVertical, setHorizontal,
    ]);
    React.useEffect(() => {
        if (!root)
            return;
        root.addEventListener('scroll', updateScrollShadows);
        return () => root.removeEventListener('scroll', updateScrollShadows);
    }, [
        root, horizontal, setHorizontal, vertical, setVertical,
    ]);
    React.useEffect(() => {
        if (!root)
            return;
        resizeObserver.current = new ResizeObserver((entries) => {
            requestAnimationFrame(() => {
                if (!Array.isArray(entries) || !entries.length)
                    return;
                updateScrollShadows();
            });
        });
        resizeObserver.current.observe(root);
        return () => resizeObserver.current.disconnect();
    }, [root, resizeObserver.current]);
    React.useEffect(() => {
        if (!root)
            return;
        window.addEventListener('resize', updateScrollShadows);
        return () => window.removeEventListener('resize', updateScrollShadows);
    }, [updateScrollShadows, root]);
    return {
        verticalTop: vertical.top || shouldHaveTopShadow(root),
        verticalBottom: vertical.bottom || shouldHaveBottomShadow(root),
        horizontalLeft: horizontal.right || shouldHaveRightShadow(root),
        horizontalRight: horizontal.left || shouldHaveLeftShadow(root),
    };
}

const useForceUpdate = () => {
    const [, updateState] = useState();
    return useCallback(() => updateState({}), []);
};

const useUuiError = (props) => {
    const forceUpdate = useForceUpdate();
    const { uuiApi, uuiErrors, uuiRouter, uuiModals, } = useUuiContext();
    const { getErrorInfo, options: { errorConfig, recoveryConfig } = {} } = props;
    const apiErrors = [];
    const apiNotifications = [];
    const onRouteChange = () => {
        let hasError = false;
        if (uuiApi.getActiveCalls().some((c) => c.status === 'error')) {
            uuiApi.reset();
            hasError = true;
        }
        if (uuiErrors.currentError !== null) {
            uuiErrors.recover();
            hasError = true;
        }
        hasError && forceUpdate();
    };
    useEffect(() => {
        let routerUnsubscribe;
        if (isClientSide) {
            routerUnsubscribe = uuiRouter.listen(onRouteChange);
        }
        uuiApi.subscribe(forceUpdate);
        uuiErrors.subscribe(forceUpdate);
        return () => {
            uuiApi.unsubscribe(forceUpdate);
            uuiErrors.unsubscribe(forceUpdate);
            routerUnsubscribe === null || routerUnsubscribe === void 0 ? void 0 : routerUnsubscribe();
        };
    }, []);
    const getDefaultErrorInfo = (errorCode) => {
        switch (errorCode) {
            case 403:
                return errorConfig === null || errorConfig === void 0 ? void 0 : errorConfig.permissionDenied;
            case 404:
                return errorConfig === null || errorConfig === void 0 ? void 0 : errorConfig.notFound;
            case 500:
                return errorConfig === null || errorConfig === void 0 ? void 0 : errorConfig.serverError;
            case 503:
                return errorConfig === null || errorConfig === void 0 ? void 0 : errorConfig.serviceUnavailable;
            default:
                return errorConfig === null || errorConfig === void 0 ? void 0 : errorConfig.default;
        }
    };
    const getError = (error, errorInfo) => {
        const resultError = getErrorInfo ? getErrorInfo(error, errorInfo) : errorInfo;
        return { errorType: 'error', errorInfo: resultError };
    };
    uuiApi.getActiveCalls().forEach((c) => {
        if (c.status === 'error' && c.options.errorHandling === 'page') {
            apiErrors.push(c);
        }
        else if (c.status === 'error' && c.options.errorHandling === 'notification') {
            apiNotifications.push(c);
        }
    });
    if (apiErrors.length) {
        uuiModals.closeAll();
        return getError(apiErrors[0], getDefaultErrorInfo(apiErrors[0].httpStatus));
    }
    else if (apiNotifications.length) {
        return { errorType: 'notification', errorInfo: apiNotifications };
    }
    else if (uuiApi.status === 'recovery') {
        return { errorType: 'recovery', errorInfo: recoveryConfig[uuiApi.recoveryReason] };
    }
    else if (uuiErrors.currentError != null) {
        const error = uuiErrors.currentError;
        let status;
        let info = {};
        if (error instanceof UuiError) {
            status = error.info.status;
            info = error.info;
        }
        const defaultErrorInfo = getDefaultErrorInfo(status);
        return getError(error, Object.assign(Object.assign({}, defaultErrorInfo), info));
    }
    else {
        return { errorType: undefined, errorInfo: undefined };
    }
};

const stateToQueryObject = (state, currentQuery) => {
    const queryObject = Object.assign(Object.assign({}, currentQuery), { filter: state.filter, presetId: state.presetId, sorting: state.sorting, viewState: state.viewState, columnsConfig: state.columnsConfig, page: state.page, pageSize: state.pageSize });
    return clearEmptyValueFromRecord(queryObject) || {};
};
const getValueFromUrl = (query) => {
    return {
        filter: query.filter,
        columnsConfig: query.columnsConfig,
        presetId: query.presetId,
        page: query.page,
        pageSize: query.pageSize,
        sorting: query.sorting,
        viewState: query.viewState,
    };
};
const normalizeTableStateValue = (newValue, prevValue, filters) => {
    const newFilter = clearEmptyValueFromRecord(newValue.filter);
    const newViewState = clearEmptyValueFromRecord(newValue.viewState);
    const filtersConfig = normalizeFilterConfig(newValue === null || newValue === void 0 ? void 0 : newValue.filtersConfig, newFilter, filters);
    const newTableState = Object.assign(Object.assign({}, newValue), { filtersConfig: filtersConfig, filter: newFilter, viewState: newViewState });
    // reset paging on filter change
    if ((prevValue === null || prevValue === void 0 ? void 0 : prevValue.page) !== undefined && !isEqual(prevValue === null || prevValue === void 0 ? void 0 : prevValue.filter, newFilter)) {
        newTableState.page = 1;
    }
    return newTableState;
};
const normalizeFilterConfig = (filtersConfig, filterValue, filters) => {
    if (!filters) {
        return undefined;
    }
    const result = {};
    let order = null;
    filters.forEach((filter) => {
        var _a, _b;
        if (filter.isAlwaysVisible || (filterValue === null || filterValue === void 0 ? void 0 : filterValue[filter.field]) || (filtersConfig === null || filtersConfig === void 0 ? void 0 : filtersConfig[filter.field])) {
            const newOrder = ((_a = filtersConfig === null || filtersConfig === void 0 ? void 0 : filtersConfig[filter === null || filter === void 0 ? void 0 : filter.field]) === null || _a === void 0 ? void 0 : _a.order) || getOrderBetween(order, null);
            const isVisible = (_b = filtersConfig === null || filtersConfig === void 0 ? void 0 : filtersConfig[filter === null || filter === void 0 ? void 0 : filter.field]) === null || _b === void 0 ? void 0 : _b.isVisible;
            result[filter.field] = {
                isVisible: isVisible !== null && isVisible !== void 0 ? isVisible : true,
                order: newOrder,
            };
            order = newOrder;
        }
    });
    return result;
};

const useTableStateImpl = (params) => {
    var _a;
    const context = useUuiContext();
    const [presets, setPresets] = useState((_a = params === null || params === void 0 ? void 0 : params.initialPresets) !== null && _a !== void 0 ? _a : []);
    const setColumnsConfig = useCallback((columnsConfig) => {
        params.onValueChange((val) => (Object.assign(Object.assign({}, val), { columnsConfig })));
    }, []);
    const setFiltersConfig = useCallback((filtersConfig) => {
        params.onValueChange((val) => (Object.assign(Object.assign({}, val), { filtersConfig })));
    }, []);
    const setFilter = useCallback((filter) => {
        params.onValueChange((val) => (Object.assign(Object.assign({}, val), { filter })));
    }, []);
    const getActivePresetId = () => {
        var _a;
        const presetId = (_a = params.value) === null || _a === void 0 ? void 0 : _a.presetId;
        return presetId ? +presetId : undefined;
    };
    const choosePreset = useCallback((preset) => {
        params.onValueChange((val) => (Object.assign(Object.assign({}, val), { filter: preset.filter, columnsConfig: preset.columnsConfig, filtersConfig: preset.filtersConfig, sorting: preset.sorting, presetId: preset.id, viewState: preset.viewState })));
    }, []);
    const getNewPresetOrder = useCallback(() => {
        var _a;
        const maxOrder = (_a = orderBy(presets, (i) => i.order, 'desc')[0]) === null || _a === void 0 ? void 0 : _a.order;
        return getOrderBetween(maxOrder, null);
    }, [presets]);
    const createPreset = useCallback((preset) => __awaiter(void 0, void 0, void 0, function* () {
        var _b;
        const newId = yield ((_b = params === null || params === void 0 ? void 0 : params.onPresetCreate) === null || _b === void 0 ? void 0 : _b.call(params, preset));
        const newPreset = Object.assign(Object.assign({}, preset), { id: newId });
        setPresets((prevValue) => [...prevValue, newPreset]);
        choosePreset(newPreset);
        return newId;
    }), [params === null || params === void 0 ? void 0 : params.onPresetCreate]);
    const createNewPreset = useCallback((name) => {
        const currentTableStateValue = params.value;
        const newPreset = {
            id: null,
            name: name,
            filter: currentTableStateValue.filter,
            columnsConfig: currentTableStateValue.columnsConfig,
            filtersConfig: currentTableStateValue.filtersConfig,
            sorting: currentTableStateValue.sorting,
            viewState: currentTableStateValue.viewState,
            isReadonly: false,
            order: getNewPresetOrder(),
        };
        return createPreset(newPreset);
    }, [params.value, getNewPresetOrder]);
    const hasPresetChanged = useCallback((preset) => {
        const currentTableStateValue = params.value;
        return (!isEqual(preset.filter, currentTableStateValue.filter)
            || !isEqual(preset.columnsConfig, currentTableStateValue.columnsConfig)
            || !isEqual(preset.sorting, currentTableStateValue.sorting)
            || !isEqual(preset.viewState, currentTableStateValue.viewState));
    }, [params.value]);
    const duplicatePreset = useCallback((preset) => __awaiter(void 0, void 0, void 0, function* () {
        const newPreset = Object.assign(Object.assign({}, preset), { isReadonly: false, id: null, name: preset.name + '_copy', order: getNewPresetOrder() });
        return createPreset(newPreset);
    }), [createPreset, getNewPresetOrder]);
    const deletePreset = useCallback((preset) => {
        const removePreset = () => {
            params.onValueChange((val) => (Object.assign(Object.assign({}, val), { presetId: undefined })));
            setPresets((prevValue) => prevValue.filter((p) => p.id !== preset.id));
        };
        const promiseFulfilled = (params === null || params === void 0 ? void 0 : params.onPresetDelete) ? params.onPresetDelete(preset) : Promise.resolve();
        return promiseFulfilled
            .then(removePreset)
            .catch(() => null);
    }, [params === null || params === void 0 ? void 0 : params.onPresetDelete]);
    const updatePreset = useCallback((preset) => __awaiter(void 0, void 0, void 0, function* () {
        setPresets((prevValue) => {
            const newPresets = [...prevValue];
            newPresets.splice(prevValue.findIndex((p) => p.id === preset.id), 1, preset);
            return newPresets;
        });
        params === null || params === void 0 ? void 0 : params.onPresetUpdate(preset);
    }), [params === null || params === void 0 ? void 0 : params.onPresetUpdate]);
    const getPresetLink = useCallback((preset) => {
        return (window.location.origin
            + context.uuiRouter.createHref({
                pathname: context.uuiRouter.getCurrentLink().pathname,
                query: stateToQueryObject(Object.assign(Object.assign({}, preset), { presetId: preset.id }), context.uuiRouter.getCurrentLink().query),
            }));
    }, []);
    const setTableState = useCallback((newValue) => {
        params.onValueChange(typeof newValue === 'function' ? newValue : () => newValue);
    }, []);
    return {
        tableState: params.value,
        setTableState,
        setColumnsConfig,
        setFiltersConfig,
        setFilter,
        presets,
        activePresetId: getActivePresetId(),
        choosePreset,
        createNewPreset,
        hasPresetChanged,
        duplicatePreset,
        deletePreset,
        updatePreset,
        getPresetLink,
    };
};
const useTableState = (params) => {
    const context = useUuiContext();
    const externalValue = useRef(params.value);
    const [tableStateValue, setTableStateValue] = useState(() => {
        var _a;
        const value = getValueFromUrl(context.uuiRouter.getCurrentLink().query);
        const activePreset = (_a = params.initialPresets) === null || _a === void 0 ? void 0 : _a.find((p) => p.id === value.presetId);
        const filtersConfig = normalizeFilterConfig(activePreset === null || activePreset === void 0 ? void 0 : activePreset.filtersConfig, value.filter, params === null || params === void 0 ? void 0 : params.filters);
        return Object.assign(Object.assign({}, value), { filtersConfig, topIndex: 0, visibleCount: 40 });
    });
    const getTableStateValue = () => {
        if (params === null || params === void 0 ? void 0 : params.onValueChange) {
            return params.value;
        }
        const valueFromUrl = getValueFromUrl(context.uuiRouter.getCurrentLink().query);
        const urlKeys = Object.keys(valueFromUrl);
        urlKeys.forEach((urlKey) => {
            if (!isEqual(valueFromUrl[urlKey], tableStateValue[urlKey]) || !(urlKey in tableStateValue)) {
                tableStateValue[urlKey] = valueFromUrl[urlKey];
            }
        });
        return tableStateValue;
    };
    const setValueToUrl = (value) => {
        const oldQuery = context.uuiRouter.getCurrentLink().query;
        const newQuery = stateToQueryObject(value, context.uuiRouter.getCurrentLink().query);
        if (JSON.stringify(oldQuery) !== JSON.stringify(newQuery)) {
            context.uuiRouter.redirect({
                pathname: context.uuiRouter.getCurrentLink().pathname,
                query: newQuery,
            });
        }
    };
    const onValueChange = useCallback((update) => {
        if (params.onValueChange) {
            const newValue = update(externalValue.current);
            const resultValue = normalizeTableStateValue(newValue, externalValue.current, params.filters);
            externalValue.current = resultValue;
            params.onValueChange(resultValue);
        }
        else {
            setTableStateValue((currentValue) => {
                const newValue = update(currentValue);
                const resultValue = normalizeTableStateValue(newValue, currentValue, params.filters);
                setValueToUrl(resultValue);
                return resultValue;
            });
        }
    }, []);
    return useTableStateImpl(Object.assign(Object.assign({}, params), { onValueChange, value: getTableStateValue() }));
};

const useLayer = () => {
    const context = useUuiContext();
    const layer = useRef();
    useEffect(() => {
        layer.current = context.uuiLayout.getLayer();
        return () => { var _a; return layer.current && ((_a = context.uuiLayout) === null || _a === void 0 ? void 0 : _a.releaseLayer(layer.current)); };
    }, []);
    return layer.current;
};

/**
 * Hook that provides the ability to observe size changes of various elements.
 * @returns An observer that tracks size changes of the observed elements.
 */
function useResizeObserver(props) {
    const onResize = useMemo(() => {
        if (props.delay === undefined) {
            return props.onResize;
        }
        return debounce(props.onResize, props.delay, { leading: false, trailing: true });
    }, [props.delay, props.onResize]);
    const resizeObserver = useMemo(() => new ResizeObserver(onResize), [onResize]);
    const observables = props.observables.filter(Boolean);
    useEffect(() => {
        observables.forEach((observable) => resizeObserver.observe(observable));
        return () => {
            resizeObserver.disconnect();
        };
    }, [observables.length]);
    return resizeObserver;
}

class AsyncDataSource extends ArrayDataSource {
    constructor(props) {
        super(Object.assign(Object.assign({}, props), { items: [] }));
        this.api = null;
        const params = { getId: this.getId, complexIds: this.props.complexIds };
        this.api = props.api;
        this.itemsStatusCollector = new ItemsStatusCollector(newMap(params), params);
    }
    setProps(newProps) {
        const props = Object.assign({}, newProps);
        // We'll receive items=null on updates (because we inherit ArrayDataSource, but nobody would actually pass items there - they are expected to come from API)
        // so this tweak is required to not reset items on any update
        props.items = newProps.items || this.props.items;
        super.setProps(props);
        if (newProps.items && newProps.items !== this.props.items) {
            this.itemsStorage.setItems(newProps.items, { reset: true });
        }
    }
    reload() {
        this.setProps(Object.assign(Object.assign({}, this.props), { items: [] }));
        const params = { getId: this.getId, complexIds: this.props.complexIds };
        this.itemsStorage = new ItemsStorage({ items: [], params });
        this.itemsStatusCollector = new ItemsStatusCollector(newMap(params), params);
        super.reload();
    }
    useView(value, onValueChange, options, deps = []) {
        var _a, _b;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const forceUpdate = useForceUpdate();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const [itemsMap, setItemsMap] = useState(this.itemsStorage.getItemsMap());
        const _c = Object.assign(Object.assign({}, this.props), options), props = __rest(_c, ["items"]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const _d = useTree(Object.assign(Object.assign({ type: 'async', api: this.api }, props), { itemsMap, setItems: this.itemsStorage.setItems, itemsStatusCollector: this.itemsStatusCollector, isLoaded: this.props.items.length > 0, getId: this.getId, getParentId: (_b = (_a = options === null || options === void 0 ? void 0 : options.getParentId) !== null && _a !== void 0 ? _a : this.props.getParentId) !== null && _b !== void 0 ? _b : this.defaultGetParentId, dataSourceState: value, setDataSourceState: onValueChange }), [...deps, this]), { tree, reload, selectionTree, totalCount } = _d, restProps = __rest(_d, ["tree", "reload", "selectionTree", "totalCount"]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            const unsubscribe = this.itemsStorage.subscribe((newItemsMap) => {
                if (itemsMap !== newItemsMap) {
                    setItemsMap(newItemsMap);
                }
            });
            return () => {
                unsubscribe();
            };
        }, [this.itemsStorage]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            const unsubscribe = this.itemsStatusCollector.subscribe(() => {
                forceUpdate();
            });
            return () => {
                unsubscribe();
            };
        }, [this.itemsStatusCollector]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            this.trees.set(tree, reload);
            return () => {
                this.trees.delete(tree);
            };
        }, [tree, reload]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const cascadeSelectionService = useCascadeSelectionService({
            tree: selectionTree,
        });
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { rows, listProps, selectAll, getById, getSelectedRowsCount, clearAllChecked } = useDataRows(Object.assign(Object.assign({ tree }, restProps), cascadeSelectionService));
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useMemo(() => ({
            getVisibleRows: () => rows,
            getListProps: () => (Object.assign(Object.assign({}, listProps), { totalCount })),
            selectAll,
            getConfig: () => restProps,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        }), [
            rows,
            listProps,
            selectAll,
            restProps,
            totalCount,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        ]);
    }
}

function useMemoWithDestructor(create, update, destroy, deps) {
    const ref = useRef();
    const prevDeps = useRef(deps);
    const isDepsChanged = prevDeps.current.length !== deps.length || prevDeps.current.some((devVal, index) => devVal !== deps[index]);
    if (ref.current == null || isDepsChanged) {
        prevDeps.current = deps;
        ref.current = create();
    }
    update(ref.current);
    const current = ref.current;
    useEffect(() => {
        // Value here is memoized in closure at the time of its creation.
        // So we are not destroying the value we just created above.
        return () => current && destroy(current);
    }, deps);
    return ref.current;
}

function useAsyncDataSource(props, deps) {
    return useMemoWithDestructor(() => new AsyncDataSource(Object.assign({}, props)), (dataSource) => dataSource.setProps(props /* due to broken inheritance of AsyncDataSource from ArrayDataSource */), (dataSource) => dataSource.destroy(), deps);
}

function useArrayDataSource(props, deps) {
    return useMemoWithDestructor(() => new ArrayDataSource(Object.assign({}, props)), (dataSource) => dataSource.setProps(props), (dataSource) => dataSource.destroy(), deps);
}

class LazyDataSource extends BaseDataSource {
    constructor(props) {
        var _a;
        super(props);
        this.getById = (id) => {
            const map = this.itemsStorage.getItemsMap();
            return map.has(id) ? map.get(id) : null;
        };
        this.props = Object.assign(Object.assign({}, props), { flattenSearchResults: (_a = props.flattenSearchResults) !== null && _a !== void 0 ? _a : true });
        const params = { getId: this.getId, complexIds: this.props.complexIds };
        this.itemsStorage = new ItemsStorage({ items: [], params });
        this.itemsStatusCollector = new ItemsStatusCollector(newMap(params), params);
    }
    setProps(props) {
        var _a;
        this.props = Object.assign(Object.assign(Object.assign({}, this.props), props), { flattenSearchResults: (_a = props.flattenSearchResults) !== null && _a !== void 0 ? _a : true });
    }
    setItem(item) {
        this.itemsStorage.setItems([item]);
    }
    clearCache() {
        const params = { getId: this.getId, complexIds: this.props.complexIds };
        this.itemsStorage = new ItemsStorage({ items: [], params });
        this.itemsStatusCollector = new ItemsStatusCollector(newMap(params), params);
        super.reload();
    }
    useView(value, onValueChange, props, deps = []) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const forceUpdate = useForceUpdate();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const [itemsMap, setItemsMap] = useState(this.itemsStorage.getItemsMap());
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const _a = useTree(Object.assign(Object.assign(Object.assign({ type: 'lazy' }, this.props), { itemsMap, setItems: this.itemsStorage.setItems, itemsStatusCollector: this.itemsStatusCollector, dataSourceState: value, setDataSourceState: onValueChange, 
            // These defaults are added for compatibility reasons.
            // We'll require getId and getParentId callbacks in other APIs, including the views.
            getId: this.getId }), props), [...deps, this]), { tree, selectionTree, reload, totalCount, loadMissingRecordsOnCheck } = _a, restProps = __rest(_a, ["tree", "selectionTree", "reload", "totalCount", "loadMissingRecordsOnCheck"]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            const unsubscribe = this.itemsStorage.subscribe((newItemsMap) => {
                if (itemsMap !== newItemsMap) {
                    setItemsMap(newItemsMap);
                }
            });
            return () => {
                unsubscribe();
            };
        }, [this.itemsStorage]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            const unsubscribe = this.itemsStatusCollector.subscribe(() => {
                forceUpdate();
            });
            return () => {
                unsubscribe();
            };
        }, [this.itemsStatusCollector]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(() => {
            this.trees.set(tree, reload);
            return () => {
                this.trees.delete(tree);
            };
        }, [tree, reload]);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const cascadeSelectionService = useCascadeSelectionService({
            tree: selectionTree,
            loadMissingRecordsOnCheck,
        });
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { rows, listProps, selectAll, getById, getSelectedRowsCount, clearAllChecked } = useDataRows(Object.assign(Object.assign({ tree }, restProps), cascadeSelectionService));
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useMemo(() => ({
            getVisibleRows: () => rows,
            getListProps: () => (Object.assign(Object.assign({}, listProps), { totalCount })),
            selectAll,
            getConfig: () => restProps,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        }), [
            rows,
            listProps,
            selectAll,
            restProps,
            totalCount,
            reload,
            getById,
            getSelectedRowsCount,
            clearAllChecked,
        ]);
    }
}

function useLazyDataSource(props, deps) {
    return useMemoWithDestructor(() => new LazyDataSource(Object.assign({}, props)), (dataSource) => dataSource.setProps(props), (dataSource) => dataSource.destroy(), deps);
}

const i18n = {
    lenses: {
        validation: {
            isRequiredMessage: 'The field is mandatory',
            lessThanMinimumValueMessage: (minValue) => `Value should not be less than ${minValue}`,
            greaterThanMaximumValueMessage: (maxValue) => `Value should not be greater than ${maxValue}`,
            greaterThanMaximumLengthMessage: (maxLength) => `Maximum length is ${maxLength} characters`,
        },
    },
    locale: undefined,
};

const blankValidationState = {};
const isIterable = (value) => typeof value === 'object' && Symbol.iterator in value;
const shouldAccessWithGet = (value) => typeof value === 'object' && 'get' in value;
const getValue$1 = (key, value) => {
    if (value === null || typeof value !== 'object') {
        return undefined;
    }
    if (shouldAccessWithGet(value)) {
        return value.get(key);
    }
    return value[key];
};
const validate = (value, meta, initValue, validateOn) => {
    const validateRec = (innerValue, path, innerMeta, innerInitValue) => {
        const itemResult = validateValue$1(innerValue, path, innerMeta);
        const validateItem = (key, validationMeta) => {
            const childValue = getValue$1(key, innerValue);
            const newPath = [childValue, ...path];
            const initChildValue = getValue$1(key, innerInitValue);
            const isChildChanged = childValue !== initChildValue;
            let childResult;
            switch (validateOn) {
                case 'change': {
                    childResult = isChildChanged ? validateRec(childValue, newPath, validationMeta, initChildValue) : { isInvalid: false };
                    break;
                }
                case 'save': {
                    childResult = validateRec(childValue, newPath, validationMeta, initChildValue);
                }
            }
            itemResult.isInvalid = childResult.isInvalid || itemResult.isInvalid;
            itemResult.validationProps = itemResult.validationProps || {};
            itemResult.validationProps[key] = childResult;
        };
        if (innerMeta.props) {
            for (const key in innerMeta.props) {
                const childMeta = innerMeta.props[key];
                if (childMeta) {
                    validateItem(key, childMeta);
                }
            }
        }
        if (innerMeta.all && innerValue != null) {
            if (!Array.isArray(innerValue) && isIterable(innerValue)) {
                for (const [key] of innerValue) {
                    validateItem(key, innerMeta.all);
                }
            }
            else {
                for (const key in innerValue) {
                    validateItem(key, innerMeta.all);
                }
            }
        }
        return itemResult;
    };
    return validateRec(value, [value], meta, initValue);
};
const validateValue$1 = (value, path, meta) => {
    if (meta.validators) {
        const customValidationMessages = meta.validators
            .map((validator) => validator.apply(null, path))
            .reduce((a, b) => a.concat(b), [])
            .filter((msg) => !!msg);
        if (customValidationMessages.length > 0) {
            return {
                isInvalid: true,
                validationMessage: customValidationMessages[0],
            };
        }
    }
    if (meta.isRequired) {
        if (value == null || (typeof value === 'string' && value.trim() === '') || (Array.isArray(value) && value.length === 0)) {
            return {
                isInvalid: true,
                validationMessage: i18n.lenses.validation.isRequiredMessage,
            };
        }
    }
    if (meta.minValue != null && value != null && value < meta.minValue) {
        return {
            isInvalid: true,
            validationMessage: i18n.lenses.validation.lessThanMinimumValueMessage(meta.minValue),
        };
    }
    if (meta.maxValue != null && value != null && value > meta.maxValue) {
        return {
            isInvalid: true,
            validationMessage: i18n.lenses.validation.greaterThanMaximumValueMessage(meta.maxValue),
        };
    }
    if (meta.maxLength != null && value != null && value.length > meta.maxLength) {
        return {
            isInvalid: true,
            validationMessage: i18n.lenses.validation.greaterThanMaximumLengthMessage(meta.maxLength),
        };
    }
    return {
        isInvalid: false,
    };
};

function validateServerErrorState(currentFormState, lastSentFormState, serverValidation) {
    let result = { isInvalid: false };
    if (serverValidation.validationProps) {
        Object.keys(serverValidation.validationProps).forEach((key) => {
            const childProps = serverValidation.validationProps[key];
            validateItem(key, currentFormState[key], lastSentFormState[key], childProps, result);
        });
    }
    else {
        result = validateValue(currentFormState, lastSentFormState, serverValidation);
    }
    return result;
}
function validateValue(newValue, oldValue, validationProp) {
    if (!validationProp.isInvalid)
        return { isInvalid: false };
    return newValue === oldValue
        ? {
            isInvalid: true,
            validationMessage: validationProp.validationMessage,
        }
        : {
            isInvalid: false,
        };
}
function validateItem(key, currentFormStatePart, lastSavedFormStatePart, serverValidation, parentResult) {
    const valueResult = validateValue(currentFormStatePart, lastSavedFormStatePart, serverValidation);
    const recursiveResult = validateServerErrorState(currentFormStatePart, lastSavedFormStatePart, serverValidation);
    recursiveResult.isInvalid = recursiveResult.isInvalid || valueResult.isInvalid;
    if (valueResult.validationMessage) {
        recursiveResult.validationMessage = valueResult.validationMessage;
    }
    parentResult.validationProps = parentResult.validationProps || {};
    parentResult.validationProps[key] = recursiveResult;
    parentResult.isInvalid = parentResult.isInvalid || recursiveResult.isInvalid;
}

function mergeValidation(clientValidation, serverValidation) {
    const result = serverValidation.isInvalid ? serverValidation : clientValidation;
    if (clientValidation.isInvalid)
        mergeValidationProps(clientValidation.validationProps, result);
    return result;
}
function mergeValidationProps(validationProps, resultPart) {
    if (!validationProps)
        return;
    if (!resultPart.validationProps)
        resultPart.validationProps = {};
    Object.keys(validationProps).forEach((key) => {
        var _a, _b, _c;
        const prop = validationProps[key];
        const isInvalid = prop.isInvalid || ((_a = resultPart.validationProps[key]) === null || _a === void 0 ? void 0 : _a.isInvalid) || false;
        const validationMessage = (_b = prop.validationMessage) !== null && _b !== void 0 ? _b : (_c = resultPart.validationProps[key]) === null || _c === void 0 ? void 0 : _c.validationMessage;
        resultPart.validationProps[key] = validationMessage
            ? {
                isInvalid,
                validationMessage,
            }
            : {
                isInvalid,
            };
        if (prop.isInvalid) {
            mergeValidationProps(prop.validationProps, resultPart.validationProps[key]);
        }
    });
}

const identityLens = {
    get(big) {
        return big;
    },
    set(big, small) {
        return small;
    },
    getValidationState(big) {
        return big;
    },
    getMetadata(big) {
        return big;
    },
};
function getMetadata(big) {
    const metadata = big || { all: { props: {} } };
    const metadataProps = metadata.all;
    const { isDisabled, isRequired, isReadonly } = metadata;
    return Object.assign(Object.assign({}, metadataProps), { isDisabled, isReadonly, isRequired });
}
function getValidationState(big, field, defaultValidationStateProps = {}) {
    const validationStateProps = (big || blankValidationState).validationProps || defaultValidationStateProps;
    return validationStateProps[field];
}
function prop(name) {
    return {
        get(big) {
            if (big == null) {
                return undefined;
            }
            else {
                return big[name];
            }
        },
        set(big, small) {
            const newObject = Object.assign(Object.assign({}, big), { [name]: small });
            return newObject;
        },
        getValidationState(big) {
            return getValidationState(big, name, { [name]: { isInvalid: false } });
        },
        getMetadata(big) {
            const metadata = big || { props: {} };
            const metadataProps = metadata.props || {};
            const { isDisabled, isRequired, isReadonly } = metadata;
            return Object.assign({ isDisabled, isReadonly, isRequired }, metadataProps[name]);
        },
    };
}
function key(id) {
    return {
        get(big) {
            if (big == null) {
                return undefined;
            }
            else {
                return big.get(id);
            }
        },
        set(big, small) {
            const newMap = cloneMap(big);
            return newMap.set(id, small);
        },
        getValidationState(big) {
            return getValidationState(big, id);
        },
        getMetadata(big) {
            return getMetadata(big);
        },
    };
}
function index(num) {
    return {
        get(big) {
            if (big == null) {
                return undefined;
            }
            else {
                return big[num];
            }
        },
        set(big, small) {
            const newArray = [...big];
            newArray[num] = small;
            return newArray;
        },
        getValidationState(big) {
            return getValidationState(big, num);
        },
        getMetadata(big) {
            return getMetadata(big);
        },
    };
}
function defaultValue(value) {
    return {
        get(big) {
            if (big === undefined || big === null) {
                return value;
            }
            else {
                return big;
            }
        },
        set(big, small) {
            return small;
        },
        getMetadata(big) {
            return big;
        },
        getValidationState(big) {
            return big;
        },
    };
}
function compose(left, right) {
    if (left === identityLens) {
        return right;
    }
    if (right === identityLens) {
        return left;
    }
    return {
        get(big) {
            const middle = left.get(big);
            const small = right.get(middle);
            return small;
        },
        set(big, small) {
            let middle = left.get(big);
            middle = right.set(middle, small);
            return left.set(big, middle);
        },
        getValidationState(big) {
            const middle = left.getValidationState && left.getValidationState(big);
            const small = right.getValidationState && right.getValidationState(middle);
            return small;
        },
        getMetadata(big) {
            const middle = left.getMetadata && left.getMetadata(big);
            const small = right.getMetadata && right.getMetadata(middle);
            return small;
        },
    };
}

class LensBuilder {
    constructor(lens) {
        this.lens = lens;
        this.handleValueChange = null;
        this.cache = new Map();
        this.handleValueChange = (newValue) => {
            this.lens.set(null, newValue);
        };
    }
    get() {
        return this.lens.get(null);
    }
    key(id) {
        return this.compose(key(id), id);
    }
    set(value) {
        this.lens.set(null, value);
    }
    update(fn) {
        this.lens.set(null, fn(this.lens.get(null)));
    }
    compose(lens, cacheKey) {
        if (cacheKey != null && this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        const result = new LensBuilder(compose(this.lens, lens));
        if (cacheKey != null) {
            this.cache.set(cacheKey, result);
        }
        if (this.cache.size > LensBuilder.MAX_CACHE_SIZE) {
            const { value } = this.cache.keys().next();
            this.cache.delete(value);
        }
        return result;
    }
    prop(name) {
        return this.compose(prop(name), name);
    }
    index(index$1) {
        return this.compose(index(index$1), index$1);
    }
    onChange(fn) {
        return this.compose({
            get: (i) => i, set: fn, getValidationState: this.lens.getValidationState, getMetadata: this.lens.getMetadata,
        }, fn);
    }
    default(value) {
        return this.compose(defaultValue(value), value);
    }
    toProps() {
        const validationState = this.lens.getValidationState && this.lens.getValidationState(null);
        const metadata = this.lens.getMetadata && this.lens.getMetadata(null);
        return Object.assign(Object.assign({ value: this.lens.get(null), onValueChange: this.handleValueChange }, validationState), metadata);
    }
}
LensBuilder.MAX_CACHE_SIZE = 1000;

/** @deprecated This helper to be removed in future versions, as it's intended for Class-components, and very rarely used */
function onEditableComponent(component) {
    return new LensBuilder({
        get() {
            return component.props.value;
        },
        set(big, small) {
            component.props.onValueChange(small);
            return small;
        },
        getValidationState() {
            const { isInvalid, validationMessage, validationProps } = component.props;
            return { isInvalid, validationMessage, validationProps };
        },
        getMetadata() {
            const { isReadonly, isDisabled, isRequired, props, all, } = component.props;
            return {
                isReadonly, isDisabled, isRequired, props, all,
            };
        },
    });
}
function onEditable(editable) {
    return new LensBuilder({
        get() {
            return editable.value;
        },
        set(big, small) {
            editable.onValueChange(small);
            return small;
        },
        getValidationState() {
            return editable;
        },
    });
}
/** @deprecated This helper to be removed in future versions, as it's intended for Class-components, and very rarely used */
function onState(component) {
    return new LensBuilder({
        get() {
            return component.state;
        },
        set(_, small) {
            component.setState(small);
            return small;
        },
    });
}

var L = /*#__PURE__*/Object.freeze({
    __proto__: null,
    onEditable: onEditable,
    onEditableComponent: onEditableComponent,
    onState: onState
});

const Lens = L;

function useLock({ handleLeave }) {
    const context = useUuiContext();
    const [status, setStatus] = useState('unblocked');
    const block = () => {
        setStatus('blocked');
    };
    const unblock = () => {
        setStatus('unblocked');
    };
    const blockRouter = () => {
        let unblockRouter;
        const routerWillLeave = (nextLocation) => {
            const currentLocation = context.uuiRouter.getCurrentLink();
            return handleLeave(nextLocation, currentLocation)
                .then((res) => {
                unblockRouter();
                context.uuiRouter.redirect(nextLocation);
                if (res === 'remain') {
                    setStatus('remain');
                }
            })
                .catch(() => { });
        };
        unblockRouter = context.uuiRouter.block((location) => {
            routerWillLeave(location);
        });
        return unblockRouter;
    };
    useEffect(() => {
        if (!handleLeave || status === 'unblocked')
            return;
        if (status === 'remain') {
            setStatus('blocked');
            return;
        }
        const unblockRouter = blockRouter();
        return () => {
            unblockRouter === null || unblockRouter === void 0 ? void 0 : unblockRouter();
        };
    }, [handleLeave, status]);
    return {
        block,
        unblock,
        isLocked: status !== 'unblocked',
    };
}

const getKeys = (a, b, c) => {
    if (Array.isArray(a) && Array.isArray(b) && Array.isArray(c)) {
        return Object.keys(Object.assign(Object.assign(Object.assign({}, a), b), c));
    }
    return Array.from(new Set([...getObjectOrMapKeys(a), ...getObjectOrMapKeys(b), ...getObjectOrMapKeys(c)]));
};
const getObjectOrMapKeys = (a) => {
    if (typeof a !== 'object') {
        return [];
    }
    if (!Array.isArray(a) && Symbol.iterator in a && typeof a[Symbol.iterator] === 'function') {
        const keys = [];
        for (const [key] of a) {
            keys.push(key);
        }
        return keys;
    }
    return Object.keys(a);
};
const getValue = (a, key) => {
    if (('get' in a && typeof a.get === 'function')) {
        return a.get(key);
    }
    return a[key];
};
/**
 * Determines if useForm should create a new undo checkpoint.
 * c is the new change, a and b are previous checkpoints.
 * Returns false only if:
 * - a and b has exactly the same structure (types of fields recursively)
 * - scalar fields changed between b and c, are the same as between a and b.
 * In other words, it returns true only if user just edited the very same scalar field, as he did the last time
 */
function shouldCreateUndoCheckpoint(a, b, c) {
    // The field type is changed this time.
    // Probably is was null and became an object, or array become object.
    // Consider this a major change (adding row, creating some object for the first time)
    if (typeof b !== typeof c || Array.isArray(b) !== Array.isArray(c)) {
        return true;
    }
    // The field is an object of array - need to recurse thru it
    if (typeof c === 'object' && typeof b === 'object' && typeof c === 'object') {
        // Ignore that a, b, or c might be an empty array or object and has different structure.
        // If it's type changed, we already exited with 'true' on the first step
        // If some there's a difference between keys, values, array length
        // - we'll find this on the next level of recursion
        a = a || {};
        b = b || {};
        c = c || {};
        const keys = getKeys(a, b, c);
        return keys.some((key) => shouldCreateUndoCheckpoint(getValue(a, key), getValue(b, key), getValue(c, key)));
    }
    // The field is scalar (null, undefined, boolean, string, number, NaN)
    // In this case, we only need a checkpoint if it's changed for the first time.
    // E.g.
    // 'a' => 'ab' && 'ab' => 'abc' - false, we created checkpoint last time
    // 'a' => 'ab' && 'ab' => 'ab' - false, this field wasn't changed this time
    // 'a' => 'a' && 'a' => 'a'  - false, this field wasn't changed at all
    // 'a' => 'a' && 'a' => 'ab' - true, this field is changed for the first time
    return a === b && b !== c;
}

function useForm(props) {
    const context = useUuiContext();
    const initialForm = useRef({
        isChanged: false,
        isInProgress: false,
        form: props.value,
        validationState: { isInvalid: false },
        serverValidationState: undefined,
        formHistory: [props.value],
        historyIndex: 0,
        isInSaveMode: false,
    });
    const propsRef = useRef(props);
    propsRef.current = props;
    const getMetadata = (value) => propsRef.current.getMetadata ? propsRef.current.getMetadata(value) : {};
    const prevFormValue = useRef(props.value);
    const formState = useRef(initialForm.current);
    const forceUpdate = useForceUpdate();
    const updateFormState = (update) => {
        const newState = update(formState.current);
        formState.current = newState;
        forceUpdate();
    };
    const handleSave = useCallback((isSavedBeforeLeave) => {
        let savePromise;
        updateFormState((currentState) => {
            let newState = Object.assign(Object.assign({}, currentState), { isInSaveMode: true });
            newState.isInSaveMode = true;
            newState = updateValidationStates(newState);
            if (!newState.validationState.isInvalid) {
                newState.isInProgress = true;
                savePromise = propsRef.current
                    .onSave(formState.current.form)
                    .then((response) => handleSaveResponse(response, isSavedBeforeLeave))
                    .catch((err) => handleError(err));
            }
            else {
                savePromise = Promise.reject();
            }
            return newState;
        });
        return savePromise;
    }, []);
    const removeUnsavedChanges = useCallback(() => {
        context.uuiUserSettings.set(props.settingsKey, null);
    }, [context.uuiUserSettings, props.settingsKey]);
    const handleLeave = useCallback((nextLocation, currentLocation) => __awaiter(this, void 0, void 0, function* () {
        if (props.beforeLeave) {
            const res = yield props.beforeLeave(nextLocation, currentLocation);
            if (res === true) {
                return handleSave(true);
            }
            if (res === false) {
                removeUnsavedChanges();
                return Promise.resolve();
            }
            if (res === 'remain') {
                return Promise.resolve('remain');
            }
        }
        return Promise.resolve();
    }), [
        props.beforeLeave,
        handleSave,
        removeUnsavedChanges,
    ]);
    const { isLocked, block, unblock } = useLock({ handleLeave });
    const getMergedValidationState = () => {
        const { form, lastSentForm, serverValidationState, validationState, } = formState.current;
        if (serverValidationState) {
            const serverValidation = validateServerErrorState(form, lastSentForm, serverValidationState);
            return mergeValidation(validationState, serverValidation);
        }
        return validationState;
    };
    const lens = useMemo(() => new LensBuilder({
        get: () => formState.current.form,
        set: (_, small) => {
            handleFormUpdate(() => small);
            return small;
        },
        getValidationState: getMergedValidationState,
        getMetadata: () => getMetadata(formState.current.form),
    }), []);
    useEffect(() => {
        const unsavedChanges = getUnsavedChanges();
        if (!unsavedChanges || !props.loadUnsavedChanges || isEqual(unsavedChanges, initialForm.current.form))
            return;
        props
            .loadUnsavedChanges()
            .then(() => handleFormUpdate(() => unsavedChanges))
            .catch(() => null);
    }, []);
    useEffect(() => {
        if (!isEqual(props.value, prevFormValue.current)) {
            resetForm(Object.assign(Object.assign({}, formState.current), { form: props.value, formHistory: formState.current.isChanged ? formState.current.formHistory : [props.value] }));
            prevFormValue.current = props.value;
        }
    }, [props.value]);
    const getUnsavedChanges = () => {
        return context.uuiUserSettings.get(props.settingsKey);
    };
    const handleFormUpdate = (update, options) => updateFormState((currentState) => {
        var _a;
        options = options !== null && options !== void 0 ? options : {};
        options.addCheckpoint = (_a = options.addCheckpoint) !== null && _a !== void 0 ? _a : true;
        const newForm = update(currentState.form);
        let { historyIndex, formHistory } = currentState;
        // Determine if change is significant and we need to create new checkpoint.
        // If false - we'll just update the latest checkpoint.
        // We need to always create a checkpoint at the first change, to save initial form state.
        const needCheckpoint = historyIndex === 0 || shouldCreateUndoCheckpoint(formHistory[historyIndex - 1], formHistory[historyIndex], newForm);
        if (options.addCheckpoint && needCheckpoint) {
            historyIndex++;
        }
        formHistory = formHistory.slice(0, historyIndex).concat(newForm);
        if (options.addCheckpoint || context.uuiUserSettings.get(props.settingsKey)) {
            context.uuiUserSettings.set(props.settingsKey, newForm);
        }
        const isChanged = !isEqual(initialForm.current.form, newForm);
        if (isChanged === true) {
            block();
        }
        else {
            unblock();
        }
        let newState = Object.assign(Object.assign({}, currentState), { form: newForm, isChanged: isChanged, historyIndex,
            formHistory });
        if (currentState.isInSaveMode || props.validationOn === 'change') {
            newState = updateValidationStates(newState);
        }
        return newState;
    });
    const resetForm = (withNewState) => updateFormState((currentState) => {
        const newFormState = Object.assign(Object.assign({}, currentState), withNewState);
        if (newFormState !== currentState) {
            initialForm.current = newFormState;
            return newFormState;
        }
    });
    const updateValidationStates = (state) => {
        const valueToValidate = state.form;
        const metadata = getMetadata(valueToValidate);
        const isInSaveMode = state.isInSaveMode;
        const validationMode = isInSaveMode || !props.validationOn ? 'save' : props.validationOn;
        const validationState = validate(valueToValidate, metadata, initialForm.current.form, validationMode);
        const newState = Object.assign(Object.assign({}, state), { validationState });
        if (!validationState.isInvalid) {
            // When form became valid, we switch inSaveMode to false
            newState.isInSaveMode = false;
        }
        return newState;
    };
    const handleError = (err) => {
        var _a, _b;
        updateFormState((currentValue) => (Object.assign(Object.assign({}, currentValue), { isInProgress: false })));
        (_b = (_a = propsRef.current).onError) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    const handleSaveResponse = (response, isSavedBeforeLeave) => {
        var _a, _b;
        const newFormValue = (response && response.form) || formState.current.form;
        const newState = Object.assign(Object.assign({}, formState.current), { historyIndex: 0, formHistory: [newFormValue], isChanged: response && ((_a = response.validation) === null || _a === void 0 ? void 0 : _a.isInvalid) ? formState.current.isChanged : false, form: newFormValue, isInProgress: false, serverValidationState: (response && response.validation) || formState.current.serverValidationState, lastSentForm: response && ((_b = response.validation) === null || _b === void 0 ? void 0 : _b.isInvalid) ? response.form || formState.current.form : formState.current.lastSentForm });
        if (response && response.validation) {
            flushSync(() => {
                updateFormState(() => newState);
            });
            return;
        }
        flushSync(() => {
            resetForm(newState);
        });
        removeUnsavedChanges();
        unblock();
        if (propsRef.current.onSuccess && response) {
            propsRef.current.onSuccess(response.form, isSavedBeforeLeave);
        }
    };
    const handleUndo = useCallback(() => updateFormState((currentState) => {
        const { formHistory, historyIndex } = currentState;
        const previousIndex = historyIndex - 1;
        if (previousIndex >= 0) {
            const previousItem = formHistory[previousIndex];
            let newState = Object.assign(Object.assign({}, currentState), { isChanged: previousIndex !== 0, form: previousItem, historyIndex: previousIndex });
            if (currentState.validationState.isInvalid) {
                newState = updateValidationStates(newState);
            }
            return newState;
        }
        else {
            return currentState;
        }
    }), []);
    const handleRedo = useCallback(() => updateFormState((currentState) => {
        const { formHistory, historyIndex } = currentState;
        const nextIndex = historyIndex + 1;
        if (nextIndex < currentState.formHistory.length) {
            const nextItem = formHistory[nextIndex];
            let newState = Object.assign(Object.assign({}, currentState), { form: nextItem, historyIndex: nextIndex, isChanged: true });
            if (currentState.validationState.isInvalid) {
                newState = updateValidationStates(newState);
            }
            return newState;
        }
        else {
            return currentState;
        }
    }), []);
    const validate$1 = useCallback(() => {
        const formSate = Object.assign(Object.assign({}, formState.current), { isInSaveMode: true });
        const newState = updateValidationStates(formSate);
        updateFormState(() => newState);
        return newState.validationState;
    }, []);
    const handleRevert = useCallback(() => {
        resetForm(initialForm.current);
    }, [props.value]);
    const handleValueChange = useCallback((newValue) => {
        handleFormUpdate(() => newValue);
    }, []);
    const handleSetValue = useCallback((value) => {
        handleFormUpdate((currentValue) => {
            const newValue = value instanceof Function ? value(currentValue) : value;
            return newValue;
        });
    }, []);
    const handleReplaceValue = useCallback((value) => {
        updateFormState((currentValue) => {
            const newFormValue = value instanceof Function ? value(currentValue.form) : value;
            return Object.assign(Object.assign({}, currentValue), { form: newFormValue });
        });
    }, []);
    const saveCallback = useCallback(() => {
        handleSave().catch(() => { });
    }, [handleSave]);
    const handleClose = useCallback(() => {
        return isLocked ? handleLeave() : Promise.resolve();
    }, [isLocked]);
    const setServerValidationState = useCallback((value) => {
        updateFormState((currentValue) => {
            const newValue = value instanceof Function ? value(currentValue.serverValidationState) : value;
            return Object.assign(Object.assign({}, currentValue), { serverValidationState: newValue });
        });
    }, []);
    const mergedValidationState = getMergedValidationState();
    return {
        setValue: handleSetValue,
        replaceValue: handleReplaceValue,
        isChanged: formState.current.isChanged,
        close: handleClose,
        lens,
        save: saveCallback,
        undo: handleUndo,
        redo: handleRedo,
        revert: handleRevert,
        validate: validate$1,
        canUndo: formState.current.historyIndex > 0,
        canRedo: formState.current.historyIndex < formState.current.formHistory.length - 1,
        canRevert: formState.current.form !== props.value,
        value: formState.current.form,
        onValueChange: handleValueChange,
        isInvalid: mergedValidationState.isInvalid,
        validationMessage: mergedValidationState.validationMessage,
        validationProps: mergedValidationState.validationProps,
        serverValidationState: formState.current.serverValidationState,
        setServerValidationState,
        isInProgress: formState.current.isInProgress,
    };
}

function Form(_a) {
    var { renderForm } = _a, props = __rest(_a, ["renderForm"]);
    const useFormProps = useForm(props);
    return React__default.createElement(React__default.Fragment, null, renderForm(useFormProps));
}

/**
 * This hook creates UUI context compatible with Next.js pages router
 *
 * @example
 * const { services } = useUuiServicesSsr({ ... });
 * <UuiContext.Provider value={ services }> ... </UuiContext.Provider>
 * // And then, use it in code like this:
 * const services = useUuiContext<TApi, AppContextType>();
 *
 * @param props
 */
function useUuiServicesSsr(props) {
    const { router } = props, restProps = __rest(props, ["router"]);
    const nextRouterWithAdapter = useMemo(() => new NextRouterAdapter(router), [router]);
    const { services } = useUuiServices(Object.assign(Object.assign({}, restProps), { router: nextRouterWithAdapter }));
    return { services };
}

/**
 * Creates app router adapter instance for Nextjs
 */
const useNextAppRouter = ({ router, pathname, searchParams, }) => {
    const appRouterAdapter = useMemo(() => new NextAppRouterAdapter(router), [router]);
    // avoid re-creation router adapter by updating router related stuff here
    useEffect(() => {
        appRouterAdapter.updateURLParams(pathname, searchParams);
    }, [appRouterAdapter, searchParams, pathname]);
    return appRouterAdapter;
};

export { AnalyticsContext, ApiCallError, ApiContext, ArrayDataSource, AsyncDataSource, BaseDataSource, CascadeSelectionTypes, CompositeKeysMap, ContextProvider, DndActor, DndContext, DragGhost, EMPTY, ErrorContext, FAILED_RECORD, FULLY_LOADED, FetchingHelper, Form, GAListener, HistoryAdaptedRouter, IEditableDebouncer, ItemsMap, ItemsStorage, LOADED_RECORD, LOADING_RECORD, LayoutContext, LazyDataSource, Lens, Lock, LockContext, ModalContext, ModalOperationCancelled, NOT_FOUND_RECORD, NextAppRouterAdapter, NextRouterAdapter, NotificationContext, PARTIALLY_LOADED, PENDING_RECORD, PatchOrdering, Router6AdaptedRouter, StubAdaptedRouter, Tree, UuiContext, UuiError, applyColumnsConfig, arrayToMatrix, blankValidationState, blurFocusedElement, clearEmptyValueFromRecord, cloneMap, closestTargetParentByCondition, createSkinComponent, cx, deleteCookie, devLogger, directionMode, formatBytes, forwardRef, getBeforeUnloadSingletone, getCalculatedValue, getColumnsConfig, getCookie, getDecimalLength, getFilterPredicate, getMinMaxValidatedValue, getOffset, getOrderBetween, getOrderComparer, getRouter6BlockFn, getScrollParentOfEventTarget, getSearchFilter, getSeparatedValue, i18n, indexToOrder, isAnyParentHasClass, isClientSide, isEventTargetInsideClickable, isEventTargetInsideDraggable, isEventTargetInsideInput, isFocusReceiverInsideFocusLock, isMobile, isUrl, labelMod, maxOrderStr, mergeValidation, minOrderStr, mobilePopperModifier, newMap, orderBy, prependHttp, preventDefaultIfTargetFocused, queryToSearch, range, releasePointerCaptureOnEventTarget, runDataQuery, searchToQuery, setCookie, simplifyPredicates, useArrayDataSource, useAsyncDataSource, useCascadeSelectionService, useColumnsConfig, useDataRows, useFoldingService, useForceUpdate, useForm, useLayer, useLayoutEffectSafeForSsr, useLazyDataSource, useLazyFetchingAdvisor, useNextAppRouter, usePrevious, useResizeObserver, useScrollShadows, useTableState, useTableStateImpl, useTree, useUuiContext, useUuiError, useUuiServices, useUuiServicesSsr, useVirtualList, uuiContextTypes, uuiDataTableHeaderCell, uuiDndState, uuiElement, uuiMarkers, uuiMod, uuiScrollShadows, validate, validateServerErrorState, withMods };
//# sourceMappingURL=index.esm.js.map
